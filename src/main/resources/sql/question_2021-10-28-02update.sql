
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (867, '以下说法不正确的是？', 'A、Integer i1 = 10; Integer i2 = 10; i1和i2指向同一个对象\n\nB、整数型包装类型应使用equals做相等的比较\n\nC、基本类型优于包装类型\n\nD、浮点型包装类型建议使用equals或flt.compareTo(another)==0做相等的比较', 'D', '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (868, '以下说法正确的是', 'A、class Swan {\n    public static void fly() {\n        System.out.println(\"swan can fly ...\");\n    }\n}\nclass UglyDuck extends Swan {\n    public static void fly() {\n        System.out.println(\"ugly duck can\'t fly ...\");\n    }\n}\npublic class TestFly {\n    public static void main(String[] args) {\n        Swan swan = new Swan();\n        Swan uglyDuck = new UglyDuck();\n        swan.fly();\n        uglyDuck.fly();\n    }\n}\n输出：\nswan can fly …\nUglyDuck can fly …\n\nB、class WhoKnows {\n    static String sentence = \"I don\'t know.\";\n    public static void main(String[] args) {\n        String sentence = \"I know!\";\n        System.out.println(sentence);\n    }\n}\n输出\"I know!\"\n\nC、public class Obscure {\n    static String System;\n    public static void main(String[] args) {\n        System.out.println(\"hello, obscure world!\");\n    }\n}\n代码输出\"hello, obscure world!\"\n', 'B', 'A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (869, '以下代码正确的是：', 'A   String[] arr = new String[]{\"1\",\"2\",\"3\",\"4\",\"5\"};\n\nList<String> list =Arrays.asList(arr);\n\nlist.remove(\"5\");\n\nlist.add(\"6\");\n\nB   Map<String,String> map = new HashMap<>();\n\nmap.put(\"1\",\"a\");\n\nmap.put(\"2\",\"b\");\n\nList<String> list = new ArrayList<>();\n\nlist.addAll(map.values());\n\nlist.addAll(Collections.singleton(\"c\"));\n\nC   List<String> list = Collections.emptyList();\n\nlist.add(\"1\");\n\nD   List<String> list = new ArrayList<>();\n\nlist.add(\"1\");\n\nlist.add(\"2\");\n\nArrayList<String> subList = (ArrayList<String>) list.subList(0,0);', 'B', 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (870, '将list转换为数组时最佳SIZE\nList<String> list = new ArrayList<>(DEFAULT_CAPACITY);\n\nlist.add(\"1\");\n\nlist.add(\"2\");\n\nString[] array = list.toArray(new String[SIZE]);', 'A、0  \nB、1  \nC、2 \nD、3', 'A', '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (871, '以下说法正确的是', 'A、建议使用String存储敏感数据，使用结束后立即赋为空\n\nB、使用java.net.Socket类在不安全的传输通道中传输敏感数据\n\nC、调用SecurityManager执行的安全检查，进行安全检查的方法必须声明为private或final\n\nD、编写自定义类加载器时，需要复写getPermissions()方法时，可以忽略了基类的getPermissions()', 'C', 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (872, '以下代码输出什么\nMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>(16,0.75f,true){\n@Override\nprotected boolean removeEldestEntry(Map.Entry eldest){\n        return size()\n> 5;\n}\n\n};\n\nfor(int i = 0; i < 10; i++){\nmap.put(i,i);\n\n}\n\nmap.get(6);\n\nSystem.out.println(map.keySet());', 'A、[5,6,7,8,9]\n\nB、[9,8,7,6,5]\n\nC、[5,7,8,9,6]\n\nD、[6,5,7,8,9] ', 'C', '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (873, '以下代码返回值为\nclass Point {\n    private int x;\n\n    public static void main(String[] args) {\n        System.out.println(test1().x);\n        System.out.println(test2());\n        System.out.println(test3());\n    }\n    public static Point test1() {\n        Point p = new Point();\n        try {\n            p.x = 20;\n            return p;\n        } finally {\n            p.x = 30;\n        }\n    }\n    public static int test2() {\n        int a = 100;\n        try {\n            a = 200;\n            return a;\n        } finally {\n            a = 300;\n        }\n    }\n    public static int test3() {\n        int a = 100;\n        try {\n            a = 200;\n            return a;\n        } finally {\n            a = 300;\n            return a;\n        }\n    }\n}', 'A、30 200 200\n\nB、20 200 300\n\nC、30 200 300\n\nD、20 300 200', 'C', '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (874, '可能触发fullgc的条件', 'A、MaxDirectMemeorySize写满\n\nB、永生代（Perm）或Metaspace被写满\n\nC、年老代（tenured）被写满\n\nD、显示调用System.gc', 'ABCD', '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (875, '属于java并发库的线程同步类', 'A、Exchanger \nB、Semaphore \nC、CountDownLatch  \nD、CyclicBarrier  \nE、Phaser', 'ABCDE', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (876, '关于溢出描述正确的是', 'A、java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。\n\nB、java.lang.StackOverflowError: 线程栈空间不足\n\nC、java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (877, '以下说法不正确的是', 'A、当关闭断言时，会导致程序的运行结果不一致\n\nprivate ArrayList<String> names;\n\nvoid process(int index) {\n\nassert names.remove(null);\n\n// ...\n\n}\nB、建议子类通过重载扩大方法的可访问性，这样可以拥有更大的访问权限\nC、对于实现了java.lang.Cloneable接口的类，应该将方法clone()的可访问性从protected增加为public\nD、如果忽略方法的返回值或对函数调用失败情况未正确处理，可能会导致安全风险。', 'B', 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);

UPDATE question  SET title='以下说法不正确的是',options='A、当关闭断言时，会导致程序的运行结果不一致\n\nprivate ArrayList<String> names;\n\nvoid process(int index) {\n\nassert names.remove(null);\n\n// ...\n\n}\nB、建议子类通过重载扩大方法的可访问性，这样可以拥有更大的访问权限\nC、对于实现了java.lang.Cloneable接口的类，应该将方法clone()的可访问性从protected增加为public\nD、如果忽略方法的返回值或对函数调用失败情况未正确处理，可能会导致安全风险。',answer='B',parsing='A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0,error_times=0,right_times=0,doubted_times=0  WHERE id=877;
