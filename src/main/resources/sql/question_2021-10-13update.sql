UPDATE question  SET title='已知如下代码public static void main(String[] args) {	int nr = 5;	do{		System.out.print(nr)	}while(--nr>5);	System.out.print("finished");}执行后的输出包含什么？',options='A. 5B. 4C. finishedD. 6',answer='AC',original_information='52、已知如下代码1public static void main(String[] args) {2int nr = 5;3do{4System.out.print(nr)5}while(--nr>5);6System.out.print("finished");7}执行后的输出包含什么？A. 5B. 4C. finishedD. 6答案：AC',q_type='MULTI_CHOICE',hide_answer='0'  WHERE id=52;
UPDATE question  SET title='下列单例实现正确的是',options='A.package apitest;public final class Helper {    public Helper() {    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {（这是双重锁机制带来的问题导致的）        if (helper == null) {            ()            synchronized (this) {                if (helper == null) {                    helper = new Helper();                }            }        }        return helper;    }}B.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        Helper h = helper;        if (h == null) {            synchronized (this) {                h = helper;（这个是什么含义呢）                if (h == null) {                    h = new Helper(42);                    helper = h;                }            }        }        return h;    }}C.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper(42);                }            }        }        return helper;    }}D.public final class Helper {    public Helper() {}}final class Foo {    private static class Holder{        static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;    }    public Helper getInstance(){        return Holder.helper;    }}',answer='BD',original_information='49、下列单例实现正确的是A.1public final class Helper{2public Helper() { }3}4final class Foo{5private Helper helper = null;6public Helper getHelper(){（这是双重锁机制带来的问题导致的）7if(helper ==null){()8synchronized (this){9if(helper ==null){10helper = new Helper();11}12}13}14return helper;15}16}B.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10Helper h =helper;11if (h == null) {12synchronized (this) {13h=helper;（这个是什么含义呢）14if (h == null) {15h = new Helper(42);16helper = h;17}18}19}20return h;21}22}C.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10if (helper == null) {11synchronized (this) {12if (helper == null) {13helper = new Helper(42);14}15}16}17return helper;18}19}D.1public final class Helper {2public Helper() {}3}4final class Foo {5private static class Holder{6static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;7}8public Helper getInstance(){9return Holder.helper;10}11}答案：BD',q_type='MULTI_CHOICE',hide_answer='0'  WHERE id=49;
UPDATE question  SET title='下列单例实现正确的是',options='A.package apitest;public final class Helper {    public Helper() {    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {（这是双重锁机制带来的问题导致的）        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper();                }            }        }        return helper;    }}B.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        Helper h = helper;        if (h == null) {            synchronized (this) {                h = helper;（这个是什么含义呢）                if (h == null) {                    h = new Helper(42);                    helper = h;                }            }        }        return h;    }}C.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper(42);                }            }        }        return helper;    }}D.public final class Helper {    public Helper() {}}final class Foo {    private static class Holder{        static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;    }    public Helper getInstance(){        return Holder.helper;    }}',answer='BD',original_information='49、下列单例实现正确的是A.1public final class Helper{2public Helper() { }3}4final class Foo{5private Helper helper = null;6public Helper getHelper(){（这是双重锁机制带来的问题导致的）7if(helper ==null){()8synchronized (this){9if(helper ==null){10helper = new Helper();11}12}13}14return helper;15}16}B.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10Helper h =helper;11if (h == null) {12synchronized (this) {13h=helper;（这个是什么含义呢）14if (h == null) {15h = new Helper(42);16helper = h;17}18}19}20return h;21}22}C.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10if (helper == null) {11synchronized (this) {12if (helper == null) {13helper = new Helper(42);14}15}16}17return helper;18}19}D.1public final class Helper {2public Helper() {}3}4final class Foo {5private static class Holder{6static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;7}8public Helper getInstance(){9return Holder.helper;10}11}答案：BD',q_type='MULTI_CHOICE',hide_answer='0'  WHERE id=49;
UPDATE question  SET title='下列单例实现正确的是',options='A.package apitest;public final class Helper {    public Helper() {    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {（这是双重锁机制带来的问题导致的）        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper();                }            }        }        return helper;    }}B.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        Helper h = helper;        if (h == null) {            synchronized (this) {                h = helper;（这个是什么含义呢）                if (h == null) {                    h = new Helper(42);                    helper = h;                }            }        }        return h;    }}C.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper(42);                }            }        }        return helper;    }}D.public final class Helper {    public Helper() {}}final class Foo {    private static class Holder{        static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;    }    public Helper getInstance(){        return Holder.helper;    }}',answer='BD',parsing='选项A的private Helper helper = null; 没有加volatile进行修饰，可能线程A和线程B都进入了第一个判断，但是A先获取锁，B被阻塞，A释放后创建了helper对象但是B又能获取锁创建一个新的helper对象违背单例模式原则选项B在获取锁后重新赋值了h的值类似与volatile通知线程修改副本值，所以即使没有加入volatile修饰也是可行的选项C同选项A一样选项D是饿汉式非懒加载，但是线程安全故选择：BD',original_information='49、下列单例实现正确的是A.1public final class Helper{2public Helper() { }3}4final class Foo{5private Helper helper = null;6public Helper getHelper(){（这是双重锁机制带来的问题导致的）7if(helper ==null){()8synchronized (this){9if(helper ==null){10helper = new Helper();11}12}13}14return helper;15}16}B.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10Helper h =helper;11if (h == null) {12synchronized (this) {13h=helper;（这个是什么含义呢）14if (h == null) {15h = new Helper(42);16helper = h;17}18}19}20return h;21}22}C.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10if (helper == null) {11synchronized (this) {12if (helper == null) {13helper = new Helper(42);14}15}16}17return helper;18}19}D.1public final class Helper {2public Helper() {}3}4final class Foo {5private static class Holder{6static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;7}8public Helper getInstance(){9return Holder.helper;10}11}答案：BD',q_type='MULTI_CHOICE',hide_answer='1'  WHERE id=49;
UPDATE question  SET title='属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是（）',options='A.public class GpsLocation implements Serializable {    private double from;    private double to;    private String id; // non-sensitive field    // other content}（完全裸露在外）B.public class GpsLocation implements Serializable {    private double from;    private double to;    private String id; // non-sensitive field    // other content        private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField("id", String.class)};}（看来它认为from和to是敏感信息，明确了只能序列化的字段）C.public class GpsLocation implements Serializable {    private volatile double from;    private volatile double to;    private String id; // non-sensitive field    // other content}D .public class GpsLocation implements Serializable {    private transient double from;    private transient double to;    private String id; // non-sensitive field    // other content}',answer='BD',parsing='防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确',original_information='48、属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是（）A.1public class GpsLocation implements Serializable{2private double from;3private double to;4private String id; // non-sensitive field5// other content6}（完全裸露在外）B.1public class GpsLocation implements Serializable{2private double from;3private double to;4private String id; // non-sensitive field5// other content6private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField("id", String.class)};7}（看来它认为from和to是敏感信息，明确了只能序列化的字段）C.1public class GpsLocation implements Serializable{2private volatile double from;3private volatile double to;4private String id; // non-sensitive field5// other content6}D.1public class GpsLocation implements Serializable{2private transient double from;3private transient double to;4private String id; // non-sensitive field5// other content6}答案：BD',q_type='MULTI_CHOICE',hide_answer='0'  WHERE id=48;
UPDATE question  SET title='以下代码可能导致命令注入的的有()',options='AString encodeIP=HWEncoder.encodeForOS(new WindowsCodec(),args[0]);String cmd="cmd.exe /c ping "+encodeIP;Bif(Pattern.matches("[0-9A-Za-z@]+”, dir)) {Process proc=rt.exec(cmd.exec/c" + dir);}CFile dir=new File(args[0]);if(!validate(dir)){（对文件进行了检查）System.out.println("An illegal directory”);}DProcessor proc=rt.exec("cmd.exe /c dir ” + args[0]);',answer='D',parsing='选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入选项B：使用正则校验，过滤特殊字符选项C：对文件的有效性进行校验选项D：无任何校验，可能导致命令注入',original_information='39、以下代码可能导致命令注入的的有()A1String encodeIP = HWEncoder.encodeForOS(new WindowsCodec(), args[0]);2String cmd = "cmd.exe /c ping " + encodeIP;B1if (Pattern.matches("[0-9A-Za-z@]+”, dir)) {2Process proc = rt.exec(cmd.exec /c " + dir);3}C1File dir = new File(args[0]);2if (!validate(dir)) {（对文件进行了检查）3System.out.println("An illegal directory”);4}D1Processor proc = rt.exec("cmd.exe /c dir ” + args[0]);答案：D',q_type='SINGLE_CHOICE',hide_answer='0'  WHERE id=39;
UPDATE question  SET title='以下描述错误的是',options='Apublic String getProductSummary(int index) {    return products[index];}//该代码中index未校验，可能相起数组越界访问BString userName = "name”;ResultSet rs = st.executeQuery("select * from user where name = ‘” + userName + "’”);//该代码可能会产生SQL注入漏洞（是不是里面的双引号起的作用）CRuntime.getRuntime().exec("cmd.exe /c dir ” + args[0]);//该代码可能会引起命令注入DString command = System.getProPerty("command”);Runtime.getRuntime().exec("command”);//该代码可能会引起OS命令注入（这个和环境变量耦合在一起的使用命令）',answer='B',parsing='B 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验',original_information='38、以下描述错误的是A1public String getProductSummary(int index) {2return products[index];3}4//该代码中index未校验，可能相起数组越界访问B1String userName = "name”;2ResultSet rs = st.executeQuery("select * from user where name = ‘” + userName + "’”);3//该代码可能会产生SQL注入漏洞（是不是里面的双引号起的作用）C1Runtime.getRuntime().exec("cmd.exe /c dir ” + args[0]);2//该代码可能会引起命令注入D1String command = System.getProPerty("command”);2Runtime.getRuntime().exec("command”);3//该代码可能会引起OS命令注入（这个和环境变量耦合在一起的使用命令）答案：B',q_type='SINGLE_CHOICE',hide_answer='0'  WHERE id=38;
UPDATE question  SET title='根据安全编码规范，以下代码中正确的时（）（不能和操作耦合在一起去思考）',options='Aassert (Patten.matches("[0-9A-Za-z@]+", dir);Process proc = rt.exec("cmd.exe /c " + dir);BArrayList<String> names;//…assert names.remove(null);Cassert index++ != MAX_LENGTH;  这里的自增操作Dboolean isNullsRemoved = names.remove(null);assert isNullsRemoved // 所以每次都会出现这个情况啊',answer='D',parsing='没懂A为啥不对',original_information='33、根据安全编码规范，以下代码中正确的时（）（不能和操作耦合在一起去思考）A1assert (Patten.matches("[0-9A-Za-z@]+”, dir);2Process proc = rt.exec(”cmd.exe /c " + dir);B1ArrayList<String> names;2//…3assert names.remove(null);C1assert index++ != MAX_LENGTH;  这里的自增操作D1boolean isNullsRemoved = names.remove(null);2assert isNullsRemoved // 所以每次都会出现这个情况啊答案：D',q_type='SINGLE_CHOICE',hide_answer='0'  WHERE id=33;
UPDATE question  SET title='以下代码片断输出的结果是：（Integer.valueOf()如果数值比较小，还是会复用之前的数据的，intern应该是重建一个integer）public class Demo {    public static void main(String[] args) {        Integer fst = 1;        Integer snd = new Integer(1);        System.out.println(fst == snd);        System.out.println(new Integer(1) == snd);        System.out.println(fst == Integer.valueOf(1));        Integer trd = 256;        System.out.println(trd == Integer.valueOf(256));    }}',options='A false,false,true,falseB false,false,true,trueC false,false,false,falseD true,false,false,false',answer='A',original_information='30、以下代码片断输出的结果是：（Integer.valueOf()如果数值比较小，还是会复用之前的数据的，intern应该是重建一个integer）1Public class Demo {2Public static void main(String[] args) {3Integer fst = 1;4Integer snd = new Integer(1);5System.out.println(fst == snd);6System.out.println(new Integer(1) == snd);7System.out.println(fst == Integer.valueOf(1));8Integer trd = 256;9System.out.println(trd == Integer.valueOf(256));10}11}A false,false,true,falseB false,false,true,trueC false,false,false,falseD true,false,false,false答案：A',q_type='SINGLE_CHOICE',hide_answer='0'  WHERE id=30;
UPDATE question  SET title='如下代码执条结果是：public class Foo {    public static void main(String[] args) {        for (float flt = (float)1000000000;flt < 1000000010; flt++) {            System.out.println(flt);        }    }}',options='A 1000000000​1000000001​1000000002​ ….​1000000010​B 1000000000.0​C 输出结果不确定',answer='C',original_information='29、如下代码执条结果是：1public class Foo {2public static void main(String[] args) {3for (float flt = (float)1000000000;flt < 1000000010; flt++) {4System.out.println(flt);5}6}7}​A 1000000000​1000000001​1000000002​ ….​1000000010​B 1000000000.0​ C 输出结果不确定答案：C',q_type='SINGLE_CHOICE',hide_answer='0'  WHERE id=29;
UPDATE question  SET title='下面锁用的正确的是：',options='Aprivate int count=0;private final Integer lock=new Integer(count);public void doSomething(){    Synchronized(lock){    Count++;    }} Bprivate final String lock="LOCK”;public void doSomething(){    synchronized (lock){    //..    }}C Boolean isInitialized=Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）public void doSomething(){    synchronized (isInitialized){    //..    }}    Dprivate int count=0;private final integer lock=count;锁必须不能是公共人可以获取的东西public void doSomething(){    synchronized (lock){        lock++;    }}（因为别的程序还要用）',answer='A',original_information='27、下面锁用的正确的是：A1private int count = 0;2private final Integer lock = new Integer(count);3public void doSomething() {4Synchronized (lock) {5Count++;6}B1private final String lock = "LOCK”;2public void doSomething() {3synchronized (lock) {4//..5}6}C1Boolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）2public void doSomething() {3synchronized (isInitialized) {4//..5}6}D1private int count = 0;2Private final integer lock = count;锁必须不能是公共人可以获取的东西3public void doSomething() {4synchronized (lock) {5lock++;6}7}（因为别的程序还要用）答案：A',q_type='SINGLE_CHOICE',hide_answer='0'  WHERE id=27;
alter table question
    add doubtful tinyint default 1 null comment '存疑的0存疑1不存疑';

alter table question
    add `likeable` tinyint default 1 null comment '收藏 0收藏1不收藏';
UPDATE question  SET likeable=0,doubtful=0;
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '在对n个元素进行快速排序的过程中，最坏情况下需要进行多少趟排序？','A. 	nB. 	n-1C. 	n/2D. 	logn','D','D在对n个元素进行快速排序的过程中，最坏情况下需要进行多少趟排序？A. 	nB. 	n-1C. 	n/2D. 	logn','SINGLE_CHOICE',1,1,1 ,805);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下哪一项不属于工程化软件开发所面临的根本性困难？','A. 	软件是庞大的逻辑产品B. 	软件开发工具所提供的开发支持弱C. 	软件的复杂程度高D. 	软件系统的问题空间和解空间之间的巨大鸿沟','B','B以下哪一项不属于工程化软件开发所面临的根本性困难？A. 	软件是庞大的逻辑产品B. 	软件开发工具所提供的开发支持弱C. 	软件的复杂程度高D. 	软件系统的问题空间和解空间之间的巨大鸿沟','SINGLE_CHOICE',1,1,1 ,806);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于开源，以下说法正确的是（）','A. 	产品为实现某原创专利，独立开发的代码，此代码可确认为自研代码。B. 	产品使用了某款开源软件，但该软件对应社区已无人维护，产品由于业务需求必须继续备案使用，此时该软件完全由产品自行维护，因此可认为是自研代码。C. 	产品某开发人员参照某java开源软件的代码，以C#重写实现，此种情况可认为是自研代码。D. 	产品使用了某款开源软件，并对其进行了深度修改，修改量高达95%，剩余5%产品又修改了函数和变量名，FOSSID扫描时并没有被识别未疑似开源软件，此时产品可以将其确认为自研代码。','A','A关于开源，以下说法正确的是（）A. 	产品为实现某原创专利，独立开发的代码，此代码可确认为自研代码。B. 	产品使用了某款开源软件，但该软件对应社区已无人维护，产品由于业务需求必须继续备案使用，此时该软件完全由产品自行维护，因此可认为是自研代码。C. 	产品某开发人员参照某java开源软件的代码，以C#重写实现，此种情况可认为是自研代码。D. 	产品使用了某款开源软件，并对其进行了深度修改，修改量高达95%，剩余5%产品又修改了函数和变量名，FOSSID扫描时并没有被识别未疑似开源软件，此时产品可以将其确认为自研代码。','SINGLE_CHOICE',1,1,1 ,807);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下描述或做法正确的是：（）A. 	产品A软件开发人员在编写代码时，拷贝Apache license 2.0 的XXC++开源软件中的排序算法实现代码，以提升开发升效率B. 	某产品共130K行代码，其中仅10行代码与开源代码相似度较高；该10行代码可以直接确认为自研代码。C. 	产品A使用的开源软件被爆出存在严重漏洞（CVSS>7），产品A的安全SE分析&应用发现该漏洞涉及的代码产品A未调用，可以不需要对产品','A的现网版本打补丁D. 	开源软件的选用，是产品在需求分析&应用和架构设计时决定的；同时产品需基于全量全视角视图管理确保产品及配套的平台、开源及第三方软件版本归一，并满足生命周期要求','A','A以下描述或做法正确的是：（）A. 	产品A软件开发人员在编写代码时，拷贝Apache license 2.0 的XXC++开源软件中的排序算法实现代码，以提升开发升效率B. 	某产品共130K行代码，其中仅10行代码与开源代码相似度较高；该10行代码可以直接确认为自研代码。C. 	产品A使用的开源软件被爆出存在严重漏洞（CVSS>7），产品A的安全SE分析&应用发现该漏洞涉及的代码产品A未调用，可以不需要对产品A的现网版本打补丁D. 	开源软件的选用，是产品在需求分析&应用和架构设计时决定的；同时产品需基于全量全视角视图管理确保产品及配套的平台、开源及第三方软件版本归一，并满足生命周期要求','SINGLE_CHOICE',1,1,1 ,808);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）','A. 	由于该特性设计文档已经基线，所以不能更新。B. 	根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。C. 	由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。D. 	更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。','D','D某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）A. 	由于该特性设计文档已经基线，所以不能更新。B. 	根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。C. 	由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。D. 	更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。','SINGLE_CHOICE',1,1,1 ,809);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '函数搬移是代码重构的一个重要方法，下列重构使用了函数搬移方法的是（）A. 	从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。B. 	将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。C. 	当发现类A某个函数不仅仅适用于当前类，还适用于其它的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。D. 	类','A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及其相关操作。','D','D函数搬移是代码重构的一个重要方法，下列重构使用了函数搬移方法的是（）A. 	从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。B. 	将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。C. 	当发现类A某个函数不仅仅适用于当前类，还适用于其它的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。D. 	类A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及其相关操作。','SINGLE_CHOICE',1,1,1 ,810);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '使用UML对系统进行动态建模，不能使用以下哪种图？（）','A. 	顺序图B. 	类图C. 	状态图D. 	活动图','C','C使用UML对系统进行动态建模，不能使用以下哪种图？（）A. 	顺序图B. 	类图C. 	状态图D. 	活动图','SINGLE_CHOICE',1,1,1 ,811);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '在软件需求工程中，需求管理贯穿整个过程。需求管理最基本的任务是明确需求，使项目团队和用户达成共识，建立（）','A. 	需求跟踪说明B. 	需求变更管理文档C. 	需求分析计划D. 	需求基线','D','D在软件需求工程中，需求管理贯穿整个过程。需求管理最基本的任务是明确需求，使项目团队和用户达成共识，建立（）A. 	需求跟踪说明B. 	需求变更管理文档C. 	需求分析计划D. 	需求基线','SINGLE_CHOICE',1,1,1 ,812);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用以下哪个设计模式最为恰当？（）A. 	适配器模式（ADAPTER）B. 	迭代器模式（ITER','ATOR）C. 	访问者模式（VISITOR）D. 	观察者模式（OBSERVER）','D','D某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用以下哪个设计模式最为恰当？（）A. 	适配器模式（ADAPTER）B. 	迭代器模式（ITERATOR）C. 	访问者模式（VISITOR）D. 	观察者模式（OBSERVER）','SINGLE_CHOICE',1,1,1 ,813);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '从数据组织重构的角度看，下面描述不合理的是（）','A. 	开发初期如果类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。B. 	对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。C. 	对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。','A','A从数据组织重构的角度看，下面描述不合理的是（）A. 	开发初期如果类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。B. 	对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。C. 	对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。','SINGLE_CHOICE',1,1,1 ,814);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '对需求管理，理解不正确的是（）A. 	纯软件需求决策由软件RMT负责B. 	产品软硬件结合需求决策由对应产品SPDT RMT负责C. 	需求冲突时可在CCB会议仲裁D. 	产品R','AT负责各产品系列的软硬结合需求分析','A','A对需求管理，理解不正确的是（）A. 	纯软件需求决策由软件RMT负责B. 	产品软硬件结合需求决策由对应产品SPDT RMT负责C. 	需求冲突时可在CCB会议仲裁D. 	产品RAT负责各产品系列的软硬结合需求分析','SINGLE_CHOICE',1,1,1 ,815);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '违反密钥用途单一规则的有（ ）A. 	同一个预共享密钥，既可以用于认证，又可以用于完整性保护。B. 	一个密钥可以通过算法派生成两个密钥，一个用于计算M','AC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。C. 	分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务。D. 	数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务。','A','A违反密钥用途单一规则的有（ ）A. 	同一个预共享密钥，既可以用于认证，又可以用于完整性保护。B. 	一个密钥可以通过算法派生成两个密钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。C. 	分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务。D. 	数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务。','SINGLE_CHOICE',1,1,1 ,816);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于随机数的描述，错误的是( )','A. 	真正意义上的随机数其结果是不可预测的，安全随机数并非真正意义上的随机数。B. 	现代密码学是基于密钥安全的，随机数的质量决定密钥的质量。C. 	C标准库函数random( )所产生的随机数不属于安全随机数。D. 	安全随机数的要求是不可预测、绝对安全。','A','A关于随机数的描述，错误的是( )A. 	真正意义上的随机数其结果是不可预测的，安全随机数并非真正意义上的随机数。B. 	现代密码学是基于密钥安全的，随机数的质量决定密钥的质量。C. 	C标准库函数random( )所产生的随机数不属于安全随机数。D. 	安全随机数的要求是不可预测、绝对安全。','SINGLE_CHOICE',1,1,1 ,817);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下对文件的操作做法中错误的是（）','A. 	校验文件路径时使用getCanonicalPath()获取文件路径B. 	使用Files.newByteChannel()在文件创建时指定合适的权限C. 	临时文件使用完毕之后、系统终止之前，应该显式地对其进行删除D. 	从ZipInputStream中解压文件时仅调用ZipEntry.getSize()方法判断解压文件大小','D','D以下对文件的操作做法中错误的是（）A. 	校验文件路径时使用getCanonicalPath()获取文件路径B. 	使用Files.newByteChannel()在文件创建时指定合适的权限C. 	临时文件使用完毕之后、系统终止之前，应该显式地对其进行删除D. 	从ZipInputStream中解压文件时仅调用ZipEntry.getSize()方法判断解压文件大小','SINGLE_CHOICE',1,1,1 ,818);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于java中调用外部进程的说法中，错误的是（ ）','A. 	外部程序运行时由java.lang.Process对象描述。这个对象包含一个输入流，输出流，以及一个错误流。B. 	外部进程的输出流是一个OutputStream对象，可以通过Process的静态方法getOutputStream获取。C. 	一个外部进程如果试图从一个空的输入流中读取输入，则会一直阻塞，直到为其提供输入。D. 	一个外部进程的输出可能会耗尽该进程输出流与错误流的缓冲区。当发生这种情况时，Java 程序可能会阻塞外部进程，同时阻碍Java程序与外部程序的继续运行。','B','B关于java中调用外部进程的说法中，错误的是（ ）A. 	外部程序运行时由java.lang.Process对象描述。这个对象包含一个输入流，输出流，以及一个错误流。B. 	外部进程的输出流是一个OutputStream对象，可以通过Process的静态方法getOutputStream获取。C. 	一个外部进程如果试图从一个空的输入流中读取输入，则会一直阻塞，直到为其提供输入。D. 	一个外部进程的输出可能会耗尽该进程输出流与错误流的缓冲区。当发生这种情况时，Java 程序可能会阻塞外部进程，同时阻碍Java程序与外部程序的继续运行。','SINGLE_CHOICE',1,1,1 ,819);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下列哪个不是Class类中定义的反射方法？','A. 	getDeclaredFiledsB. 	getDeclaredNamesC. 	getDeclaredMethodsD. 	getDeclaredConstructors','D','D下列哪个不是Class类中定义的反射方法？A. 	getDeclaredFiledsB. 	getDeclaredNamesC. 	getDeclaredMethodsD. 	getDeclaredConstructors','SINGLE_CHOICE',1,1,1 ,820);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '某测试环境发现部署的java进程(pid=17212)经常Full GC,长期内存占用很高,疑似内存泄漏。现在想要确定是哪些类的实例占内存较多,那么应该用下列选项中的哪个命令？','A. 	jmap -histo 17212B. 	top -Hp 17212C. 	jstack 17212D. 	jstat -gcutil 17212','D','D某测试环境发现部署的java进程(pid=17212)经常Full GC,长期内存占用很高,疑似内存泄漏。现在想要确定是哪些类的实例占内存较多,那么应该用下列选项中的哪个命令？A. 	jmap -histo 17212B. 	top -Hp 17212C. 	jstack 17212D. 	jstat -gcutil 17212','SINGLE_CHOICE',1,1,1 ,821);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下列使用NIO对文件读写进行操作，哪个是错误的：A. 	读小文件的所有字节：byte[] bytes = Files.readAllBytes(file.toPath());B. 	读小文本中所有的行：List<String> lines = Files.readAllLines(file.toPath());C. 	将数据写入文件尾：// file与lines为合法参数Files.write(file.toPath(), lines, StandardCharsets.UTF_8, StandardOpenOption.CRE','ATE);D. 	读取大文本：try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {    String line = null;    while ((line = reader.readLine()) != null) {        // ...    }} catch (IOException x) {    // ...}','C','C下列使用NIO对文件读写进行操作，哪个是错误的：A. 	读小文件的所有字节：byte[] bytes = Files.readAllBytes(file.toPath());B. 	读小文本中所有的行：List<String> lines = Files.readAllLines(file.toPath());C. 	将数据写入文件尾：// file与lines为合法参数Files.write(file.toPath(), lines, StandardCharsets.UTF_8, StandardOpenOption.CREATE);D. 	读取大文本：try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {    String line = null;    while ((line = reader.readLine()) != null) {        // ...    }} catch (IOException x) {    // ...}','SINGLE_CHOICE',1,1,1 ,822);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下哪个类不是继承自InputStream/OutputStream ？A. 	ObjectInputStreamB. 	BufferedOutputStreamC. 	RandomAccessFileD. 	Byte','ArrayInputStream','C','C如下哪个类不是继承自InputStream/OutputStream ？A. 	ObjectInputStreamB. 	BufferedOutputStreamC. 	RandomAccessFileD. 	ByteArrayInputStream','SINGLE_CHOICE',1,1,1 ,823);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于下面代码,下列选项中说法正确的是？final int limit = 5;Map<Integer, String> map = new LinkedHashMap(16, 0.75f, true) {    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() > limit;    }};for (int i = 0; i < 10; i++) {    map.put(i, String.valueOf(i));}String v = map.get(6);map.keySet().forEach(System.out::print);','A. 	代码运行后,控制台打印65789B. 	代码运行后,控制台打印95678C. 	代码运行后,控制台打印56789D. 	代码运行后,控制台打印57896','D','D关于下面代码,下列选项中说法正确的是？final int limit = 5;Map<Integer, String> map = new LinkedHashMap(16, 0.75f, true) {    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() > limit;    }};for (int i = 0; i < 10; i++) {    map.put(i, String.valueOf(i));}String v = map.get(6);map.keySet().forEach(System.out::print);A. 	代码运行后,控制台打印65789B. 	代码运行后,控制台打印95678C. 	代码运行后,控制台打印56789D. 	代码运行后,控制台打印57896','SINGLE_CHOICE',1,1,1 ,824);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下关于java Stream的描述正确的是( )','A. 	Stream执行方式跟之前代码处理方式类似，中间操作是立即执行的。B. 	Stream数据源只能是数组、容器或者I/O。C. 	对Stream的修改都会体现到数据源上。D. 	Stream跟迭代器类似，再次遍历需要重新生成。','C','C以下关于java Stream的描述正确的是( )A. 	Stream执行方式跟之前代码处理方式类似，中间操作是立即执行的。B. 	Stream数据源只能是数组、容器或者I/O。C. 	对Stream的修改都会体现到数据源上。D. 	Stream跟迭代器类似，再次遍历需要重新生成。','SINGLE_CHOICE',1,1,1 ,825);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '执行如下语句，最终会运行什么文件（ ）Runtime.getRuntime().exec(\"test.bat & notepad.exe\");','A. 	仅运行test.batB. 	仅运行notepad.exeC. 	仅运行test.bat，并将notepad.exe作为test.bat的参数D. 	运行test.bat和notepad.exe','D','D执行如下语句，最终会运行什么文件（ ）Runtime.getRuntime().exec(\"test.bat & notepad.exe\");A. 	仅运行test.batB. 	仅运行notepad.exeC. 	仅运行test.bat，并将notepad.exe作为test.bat的参数D. 	运行test.bat和notepad.exe','SINGLE_CHOICE',1,1,1 ,826);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下程序的输出为（）String s = \"123456\";String s1 = \"123456\";String s2 = \"123\" + \"456\";String s3 = \"456\";String s4 = \"123\" + s3;System.out.print (s == s1);System.out.print (s == s2);System.out.print (s == s4);','A. 	false false falseB. 	true false falseC. 	true true falseD. 	true true true','C','C如下程序的输出为（）String s = \"123456\";String s1 = \"123456\";String s2 = \"123\" + \"456\";String s3 = \"456\";String s4 = \"123\" + s3;System.out.print (s == s1);System.out.print (s == s2);System.out.print (s == s4);A. 	false false falseB. 	true false falseC. 	true true falseD. 	true true true','SINGLE_CHOICE',1,1,1 ,827);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '有以下一段代码：public class PrintCollection {    public void print(List<String> collection) {        Collections.sort(collection, (s1, s2) -> s1.compareTo(s2));        collection.stream().forEach(System.out::println);    }    public static void main(String[] args) {        List<String> list1 = Arrays.asList(\"4\", \"3\", \"2\", \"1\");        PrintCollection printer = new PrintCollection();        printer.print(list1);    }}请问使用以下哪条命令编译无编译错误？','A. 	javac -source 5 -Xlint:all PrintCollection.javaB. 	javac -source 6 -Xlint:all PrintCollection.javaC. 	javac -source 7 -Xlint:all PrintCollection.javaD. 	javac -source 8 -Xlint:all PrintCollection.java','D','D有以下一段代码：public class PrintCollection {    public void print(List<String> collection) {        Collections.sort(collection, (s1, s2) -> s1.compareTo(s2));        collection.stream().forEach(System.out::println);    }    public static void main(String[] args) {        List<String> list1 = Arrays.asList(\"4\", \"3\", \"2\", \"1\");        PrintCollection printer = new PrintCollection();        printer.print(list1);    }}请问使用以下哪条命令编译无编译错误？A. 	javac -source 5 -Xlint:all PrintCollection.javaB. 	javac -source 6 -Xlint:all PrintCollection.javaC. 	javac -source 7 -Xlint:all PrintCollection.javaD. 	javac -source 8 -Xlint:all PrintCollection.java','SINGLE_CHOICE',1,1,1 ,828);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '无情重构又称童子军原则，指你打开一个代码，如果很难理解，就应该试着去重构它，你离开的时候代码应该比你来的时候更易懂。但是通常我们由于缺乏足够的知识，不能在无情重构中进行复杂的重构，常常以抽取函数为主，但不好的抽取并不能让代码更易理解，反而更复杂。那么今天，你打开了下列的代码，可能不清楚具体的业务背景，但请尝试用函数抽取的方式进行无情重构。你觉得哪部分代码被抽出去作为一个函数，并不能提升代码的可读性（请忽略不同编程语言的规范和语法差异）。( )1 public class BusinessSite {2     private Reading[] readings = new Reading[1000];3     private static final double START_RATE = 0.09;4     private static double END_RATE = 0.05;5     private static int END_AMOUNT = 1000;6 7     public void addReading(Reading newReading) {8         readings[++lastReading] = newReading;9     }10 11    private int lastReading;12 13    public Dollars charge() {14        Dollars result;15        int usage = readings[lastReading].getAmount() - readings[lastReading - 1].getAmount();16        if (usage == 0) {17            return new Dollars(0);18        }19        double t1 = START_RATE - ((END_RATE * END_AMOUNT) - START_RATE) / (END_AMOUNT - 1);20        double t2 = ((END_RATE * END_AMOUNT) - START_RATE) * Math.min(END_AMOUNT, usage) /21                (END_AMOUNT - 1);22        double t3 = Math.max(usage - END_AMOUNT, 0) * END_RATE;23        result = new Dollars(t1 + t2 + t3);24        result = result.plus(new Dollars(usage * 0.0175));2526        Dollars base1 = new Dollars(result.min(new Dollars(50)).times(0.07));27        if (result.isGreaterThan(new Dollars(50))) {28            base1 = new Dollars(base1.plus(result.min(new Dollars(75)).minus(29                    new Dollars(50)).times(0.06)30            ));31        }32        if (result.isGreaterThan(new Dollars(75))) {33            base1 = new Dollars(base1.plus(result.minus(new Dollars(75)).times(0.05)));34        }35        result = result.plus(base1);36        return result;37   }38 }','A. 	第15行B. 	第19～23行C. 	第26～34行D. 	第14～24行','A','A无情重构又称童子军原则，指你打开一个代码，如果很难理解，就应该试着去重构它，你离开的时候代码应该比你来的时候更易懂。但是通常我们由于缺乏足够的知识，不能在无情重构中进行复杂的重构，常常以抽取函数为主，但不好的抽取并不能让代码更易理解，反而更复杂。那么今天，你打开了下列的代码，可能不清楚具体的业务背景，但请尝试用函数抽取的方式进行无情重构。你觉得哪部分代码被抽出去作为一个函数，并不能提升代码的可读性（请忽略不同编程语言的规范和语法差异）。( )1 public class BusinessSite {2     private Reading[] readings = new Reading[1000];3     private static final double START_RATE = 0.09;4     private static double END_RATE = 0.05;5     private static int END_AMOUNT = 1000;6 7     public void addReading(Reading newReading) {8         readings[++lastReading] = newReading;9     }10 11    private int lastReading;12 13    public Dollars charge() {14        Dollars result;15        int usage = readings[lastReading].getAmount() - readings[lastReading - 1].getAmount();16        if (usage == 0) {17            return new Dollars(0);18        }19        double t1 = START_RATE - ((END_RATE * END_AMOUNT) - START_RATE) / (END_AMOUNT - 1);20        double t2 = ((END_RATE * END_AMOUNT) - START_RATE) * Math.min(END_AMOUNT, usage) /21                (END_AMOUNT - 1);22        double t3 = Math.max(usage - END_AMOUNT, 0) * END_RATE;23        result = new Dollars(t1 + t2 + t3);24        result = result.plus(new Dollars(usage * 0.0175));2526        Dollars base1 = new Dollars(result.min(new Dollars(50)).times(0.07));27        if (result.isGreaterThan(new Dollars(50))) {28            base1 = new Dollars(base1.plus(result.min(new Dollars(75)).minus(29                    new Dollars(50)).times(0.06)30            ));31        }32        if (result.isGreaterThan(new Dollars(75))) {33            base1 = new Dollars(base1.plus(result.minus(new Dollars(75)).times(0.05)));34        }35        result = result.plus(base1);36        return result;37   }38 }A. 	第15行B. 	第19～23行C. 	第26～34行D. 	第14～24行','SINGLE_CHOICE',1,1,1 ,829);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '基于《密码算法应用规范》,下列哪种随机数生成方式自身会出现安全漏洞？A. 	Linux操作系统的/dev/random设备接口B. 	OpenSSL1.1.X的RAND_priv_bytesC. 	NIST SP 800-90','A标准中的DualEC-DRBG生成器D. 	JDK的java.security.SecureRandom','A','A基于《密码算法应用规范》,下列哪种随机数生成方式自身会出现安全漏洞？A. 	Linux操作系统的/dev/random设备接口B. 	OpenSSL1.1.X的RAND_priv_bytesC. 	NIST SP 800-90A标准中的DualEC-DRBG生成器D. 	JDK的java.security.SecureRandom','SINGLE_CHOICE',1,1,1 ,830);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '两台设备间需要通过外部网络传输和协商秘钥信息，为了防止传输过程中信息被攻击者篡改，下面哪个方法可以识别出信息被篡改：A. 	使用CRC32校验B. 	使用SHA512校验C. 	使用','ASE256进行加密保护D. 	使用TLS协议来传输信息','B','B两台设备间需要通过外部网络传输和协商秘钥信息，为了防止传输过程中信息被攻击者篡改，下面哪个方法可以识别出信息被篡改：A. 	使用CRC32校验B. 	使用SHA512校验C. 	使用ASE256进行加密保护D. 	使用TLS协议来传输信息','SINGLE_CHOICE',1,1,1 ,831);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '一点都不会！哈希表有14个桶，哈希函数为h(key)=key%11。表中现有数据30、48、66、18、72和90，如果分别采用线性探测法和二次探测再散列处理冲突，则28的位置（从0开始计数）可能是（）A','. 	9B. 	10C. 	11D. 	12','AC','AC一点都不会！哈希表有14个桶，哈希函数为h(key)=key%11。表中现有数据30、48、66、18、72和90，如果分别采用线性探测法和二次探测再散列处理冲突，则28的位置（从0开始计数）可能是（）A. 	9B. 	10C. 	11D. 	12','MULTI_CHOICE',1,1,1 ,832);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '针对重构方法，下列说法错误的是（）A','. 	提取接口（Extract Interface）和提取超类（Extract Superclass）本质上是一回事，均可提取通用代码。B. 	隐藏委托关系（Hide Delegate）会使代码层次更清晰，因此委托类的功能越多越好。C. 	当发现某个子类并未带来该有的派生价值时，可以考虑使用移除子类（Remove Subclass）手法进行重构。D. 	将值域上移到父类（即字段上移 Pull Up Field）会有效减少子类的成员变量，只需要搬移值域，不需要搬移对该值域的操作方法。','BD','BD针对重构方法，下列说法错误的是（）A. 	提取接口（Extract Interface）和提取超类（Extract Superclass）本质上是一回事，均可提取通用代码。B. 	隐藏委托关系（Hide Delegate）会使代码层次更清晰，因此委托类的功能越多越好。C. 	当发现某个子类并未带来该有的派生价值时，可以考虑使用移除子类（Remove Subclass）手法进行重构。D. 	将值域上移到父类（即字段上移 Pull Up Field）会有效减少子类的成员变量，只需要搬移值域，不需要搬移对该值域的操作方法。','MULTI_CHOICE',1,1,1 ,833);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下面哪些设计是符合权限最小化要求的？（）A. 	一个帐号只能拥有该角色必需的权限，不分配不必要的权限。B. 	权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则。C. 	为保证有足够权限读取到数据，连接Web服务数据库应该使用Ad','ministrator帐号。D. 	审计日志只有管理员或日志审计员有权限读取，普通用户无法访问读取。','ABD','ABD下面哪些设计是符合权限最小化要求的？（）A. 	一个帐号只能拥有该角色必需的权限，不分配不必要的权限。B. 	权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则。C. 	为保证有足够权限读取到数据，连接Web服务数据库应该使用Administrator帐号。D. 	审计日志只有管理员或日志审计员有权限读取，普通用户无法访问读取。','MULTI_CHOICE',1,1,1 ,834);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下面保护操作系统的做法正确的有（ ）A. 	关闭没有使用的服务，如：Telnet和FTPB. 	对存有重要信息的文件目录或分区进行加密C. 	启用SELinux，增强系统安全性D. 	使用Aud','itd组件对系统中的重要目录或文件进行审计','ABCD','ABCD下面保护操作系统的做法正确的有（ ）A. 	关闭没有使用的服务，如：Telnet和FTPB. 	对存有重要信息的文件目录或分区进行加密C. 	启用SELinux，增强系统安全性D. 	使用Auditd组件对系统中的重要目录或文件进行审计','MULTI_CHOICE',1,1,1 ,835);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '根据华为Java编程规范,下列选项中变量声明错误的有哪些？A. 	int a, b;B. 	int replacementLen = replacement.length();String string = sequence.toString();int pos = indexIn(string);if (replacementLen == 0) {    return removeFrom(sequence);}if (replacementLen == 1) {    return replaceFrom(sequence, replacement.charA','t(0));}if (pos == -1) {    return string;}C. 	String args[];D. 	public boolean matches(char c) {    switch (c) {        case \'\\t\':        case \'\\n\':        case \'\\u205f\':        case \'\\u3000\':            return true;        case \'\\u2007\':            return false;        default:            return false;    }}','BD','BD根据华为Java编程规范,下列选项中变量声明错误的有哪些？A. 	int a, b;B. 	int replacementLen = replacement.length();String string = sequence.toString();int pos = indexIn(string);if (replacementLen == 0) {    return removeFrom(sequence);}if (replacementLen == 1) {    return replaceFrom(sequence, replacement.charAt(0));}if (pos == -1) {    return string;}C. 	String args[];D. 	public boolean matches(char c) {    switch (c) {        case \'\\t\':        case \'\\n\':        case \'\\u205f\':        case \'\\u3000\':            return true;        case \'\\u2007\':            return false;        default:            return false;    }}','MULTI_CHOICE',1,1,1 ,836);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下说法正确的是（ ）A','. 	Optional类主要解决的问题是空指针异常（NullPointerException）B. 	实现Serializable接口的可序列化类应该显式声明serialVersionUIDC. 	尽量避免实现Serializable接口D. 	不要在控制性条件表达式中执行赋值','BC','BC如下说法正确的是（ ）A. 	Optional类主要解决的问题是空指针异常（NullPointerException）B. 	实现Serializable接口的可序列化类应该显式声明serialVersionUIDC. 	尽量避免实现Serializable接口D. 	不要在控制性条件表达式中执行赋值','MULTI_CHOICE',1,1,1 ,837);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下用例运行失败的有（）A. ','	@Test(timeout = 100)public void testWithTimeout() throws Exception {    TimeUnit.MILLISECONDS.sleep(10);}B. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(10);@Testpublic void testWithTimeout() throws Exception {    TimeUnit.SECONDS.sleep(11);}C. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(5);@Test(timeout = 7 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}D. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(7);@Test(timeout = 5 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}','ABCD','ABCD如下用例运行失败的有（）A. 	@Test(timeout = 100)public void testWithTimeout() throws Exception {    TimeUnit.MILLISECONDS.sleep(10);}B. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(10);@Testpublic void testWithTimeout() throws Exception {    TimeUnit.SECONDS.sleep(11);}C. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(5);@Test(timeout = 7 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}D. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(7);@Test(timeout = 5 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}','MULTI_CHOICE',1,1,1 ,838);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 ‘ 和 “ 符号转义，请问如下针对 mysql 数据库的查询中，哪条是有可能受到sql 注入攻击的？A','. 	\"select * from users where id=\" + request.getParameter(\"id\");B. 	\"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";C. 	\"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";D. 	\"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");','AB','AB如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 ‘ 和 “ 符号转义，请问如下针对 mysql 数据库的查询中，哪条是有可能受到sql 注入攻击的？A. 	\"select * from users where id=\" + request.getParameter(\"id\");B. 	\"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";C. 	\"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";D. 	\"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");','MULTI_CHOICE',1,1,1 ,839);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '当我们做简单业务，通过数据库连接池，获得一个数据库连接Connection，执行一个Statement，获得一个ResultSet后，就结束业务了，那么下面错误的是？A','. 	我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显式地关闭ResultSet和Statement，保持代码简单和简洁。B. 	我们需要先关闭Connection，接着显式地关闭ResultSet和Statement。C. 	我们需要先关闭Connection，接着显式地关闭Statement和ResultSetD. 	我们需要先关闭ResultSet和Statement，然后Connection就自动被关闭了，不需要显式地关闭Connection。','AD','AD当我们做简单业务，通过数据库连接池，获得一个数据库连接Connection，执行一个Statement，获得一个ResultSet后，就结束业务了，那么下面错误的是？A. 	我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显式地关闭ResultSet和Statement，保持代码简单和简洁。B. 	我们需要先关闭Connection，接着显式地关闭ResultSet和Statement。C. 	我们需要先关闭Connection，接着显式地关闭Statement和ResultSetD. 	我们需要先关闭ResultSet和Statement，然后Connection就自动被关闭了，不需要显式地关闭Connection。','MULTI_CHOICE',1,1,1 ,840);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下可能造成死锁的代码是（）A. 	public class LeftRightLock {    private final Object left = new Object();    private final Object right = new Object();    public void functionA() {        synchronized (left) {            synchronized (right) {                doSomething();            }        }    }    public void functionB() {        synchronized (right) {            synchronized (left) {                doSomething();            }        }}……}B. 	public void transferMony(Account fromAccount, Account toAccount, int amount) {    synchronized (fromAccount) {        synchronized (toAccount) {            fromAccount.debit(amount);            toAccount.credit(amount);        }    }}C. 	public class Taxi {    private Point location;    private Point destinztion;    private final Dispatcher dispatcher;    public Taxi(Dispatcher dispatcher) {        this.dispatcher = dispatcher;    }    public synchronized Point getLocation() {        return location;    }    public synchronized void setLocation(Point location) {        this.location = location;        if (this.location.equals(destinztion)) {            dispatcher.notifyAvailable(this);        }}……}public class Dispatcher {    private final Set<Taxi> taxis = new HashSet<>();    private final Set<Taxi> availableTaxis = new HashSet<>();    public synchronized void notifyA','vailable(Taxi taxi) {        availableTaxis.add(taxi);    }    public synchronized Image getImage() {        final Image image = new Image();        for (final Taxi taxi : taxis) {            image.drawMarket(taxi.getLocation());        }        return image;}……}D. 	private final ExecutorService executor = Executors.newSingleThreadExecutor();public void renderPage() throws InterruptedException, ExecutionException{    Future<String> page = executor.submit(new RenderPageTask());    frame.set(page.get());}public class RenderPageTask implements Callable<String> {    @Override    public String call() throws Exception {        final Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));        final Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));        return header.get() + \"page\" + foot.get();    }}','AC','AC以下可能造成死锁的代码是（）A. 	public class LeftRightLock {    private final Object left = new Object();    private final Object right = new Object();    public void functionA() {        synchronized (left) {            synchronized (right) {                doSomething();            }        }    }    public void functionB() {        synchronized (right) {            synchronized (left) {                doSomething();            }        }}……}B. 	public void transferMony(Account fromAccount, Account toAccount, int amount) {    synchronized (fromAccount) {        synchronized (toAccount) {            fromAccount.debit(amount);            toAccount.credit(amount);        }    }}C. 	public class Taxi {    private Point location;    private Point destinztion;    private final Dispatcher dispatcher;    public Taxi(Dispatcher dispatcher) {        this.dispatcher = dispatcher;    }    public synchronized Point getLocation() {        return location;    }    public synchronized void setLocation(Point location) {        this.location = location;        if (this.location.equals(destinztion)) {            dispatcher.notifyAvailable(this);        }}……}public class Dispatcher {    private final Set<Taxi> taxis = new HashSet<>();    private final Set<Taxi> availableTaxis = new HashSet<>();    public synchronized void notifyAvailable(Taxi taxi) {        availableTaxis.add(taxi);    }    public synchronized Image getImage() {        final Image image = new Image();        for (final Taxi taxi : taxis) {            image.drawMarket(taxi.getLocation());        }        return image;}……}D. 	private final ExecutorService executor = Executors.newSingleThreadExecutor();public void renderPage() throws InterruptedException, ExecutionException{    Future<String> page = executor.submit(new RenderPageTask());    frame.set(page.get());}public class RenderPageTask implements Callable<String> {    @Override    public String call() throws Exception {        final Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));        final Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));        return header.get() + \"page\" + foot.get();    }}','MULTI_CHOICE',1,1,1 ,841);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '对于架构威胁建模方法（STRIDE-SD）中的关键活动，以下哪些描述是正确的？A. ','	价值资产识别：根据系统部件和数据对系统所有者的价值，从软件、硬件、服务、人员等维度识别系统中的价值资产B. 	暴露面及其风险分析：对产品暴露的硬件、软件接口及协议栈进行全面的梳理，并评估暴露面风险C. 	攻击路径分析：从价值资产的成功攻击为根节点，逐步展开使攻击成功的各级子节点，直至暴露面，形成攻击树D. 	威胁建模：考虑到系统已被入侵的可能，对系统架构元素建立全面的威胁模型','ABCD','ABCD对于架构威胁建模方法（STRIDE-SD）中的关键活动，以下哪些描述是正确的？A. 	价值资产识别：根据系统部件和数据对系统所有者的价值，从软件、硬件、服务、人员等维度识别系统中的价值资产B. 	暴露面及其风险分析：对产品暴露的硬件、软件接口及协议栈进行全面的梳理，并评估暴露面风险C. 	攻击路径分析：从价值资产的成功攻击为根节点，逐步展开使攻击成功的各级子节点，直至暴露面，形成攻击树D. 	威胁建模：考虑到系统已被入侵的可能，对系统架构元素建立全面的威胁模型','MULTI_CHOICE',1,1,1 ,842);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '张三要给李四写一封信，为了确保内容不被泄漏，张三采用了如下行为：将信的内容按照密码本进行替换，并将密码本放到用只有李四可以打开的带锁的盒子中，然后在信封上写上”信内一共有 200 个字和1000个笔画”，最后将信和盒子快递给李四。从类比角度思考，请问这个过程利用了哪些密码学算法思想( )A','. 	对称加密算法B. 	非对称加密算法(加密)C. 	非对称加密算法(签名)D. 	散列函数','AD','AD张三要给李四写一封信，为了确保内容不被泄漏，张三采用了如下行为：将信的内容按照密码本进行替换，并将密码本放到用只有李四可以打开的带锁的盒子中，然后在信封上写上”信内一共有 200 个字和1000个笔画”，最后将信和盒子快递给李四。从类比角度思考，请问这个过程利用了哪些密码学算法思想( )A. 	对称加密算法B. 	非对称加密算法(加密)C. 	非对称加密算法(签名)D. 	散列函数','MULTI_CHOICE',1,1,1 ,843);
