INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1103, '以下说法正确的是', 'A. 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符\nB. 编码时尽量依赖平台默认的字符编码方式\nC. String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换\nD. 使用java.nio.charset中的类编码解码字符集', 'AD', '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1104, '关于敏感异常，说法不正确的是', 'A. 如果在传递异常的时候未对其中的敏感信息进行过滤，常常会导致信息泄露\nB. 重点关注异常中的文本消息，异常本身的类型不会泄露敏感信息\nC. 对出于问题定位目的，可将敏感异常信息记录到日志中，但必须做好日志的访问控制，防止日志被任意访问，导致敏感信息泄露给非授权用户。\nD. 可以通过限制输入. 安全策略方式过滤掉异常中的敏感信息', 'B', '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1105, '以下说法正确的是', 'A. 将含敏感数据的对象跨信任域传递前需要先加密后签名\nB. 默认情况下，自动签名认证机制使用JAR文件中包含的公钥来验证签名，这就可以保证公钥和签名未被恶意篡改\nC. 一些常用的JSON框架都具有type功能，它可以很方便的将java的对象类型和json数据格式之间进行转换，建议默认开启JSON框架的type功能\nD. 非静态的内部类序列化时会隐式的对外部类实例的非transient对象进行序列化', 'D', '解析：\nA错，先签名后加密\nB错，规则8.3 避免使用URLClassLoader和java.util.jar提供的自动签名检查机制\nC错，必须禁止开启JSON框架的type功能，如果无法禁止type功能，必须使用白名单校验。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1106, 'java中用来对字符串做归一化的方法是', 'A. java.lang.String.intern()\nB. java.lang.String.trim()\nC. java.text.Format.format()\nD. java.text.Normalizer.normalize()', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1107, 'switch支持的类型', 'A. byte\nB. long\nC. char\nD. String', 'ACD', '解析：\nswitch语句支持的类型：\nchar, byte, short, int\nCharacter, Byte, Short, Integer\nenum\nString\n没有boolean，long', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1108, '以下代码输出结果是\nString srcTxt = \"123\\\\d\";\nString rst1 = srcTxt.replaceAll(\"\\\\d\", \"456\");\nString rst2 = srcTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\nString rst3 = srcTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(rst1);\nSystem.out.println(rst2);\nSystem.out.println(rst3);', 'A.\n456456456\\d\n123456\n456456456\\d\nB.\n456456456\\d\n123456\n123456\nC.\n123456\n123456\n123456\nD\n123456\n123456\n45623\\d', 'B', '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1109, '动态代理扩展类是在什么阶段执行的？', 'A. 初始化\nB. 准备\nC. 解析\nD. 加载', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1110, '业务处理日志用', 'A. error\nB. debug\nC. warn\nD. info', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1111, 'JVM GC性能指标吞吐量是指', 'A. CPU运行时间内GC运行的次数\nB. CPU运行用户代码的时间与CPU总消耗时间的比值\nC. CPU运行时间内GC运行次数与所有运行线程次数的比值\nD. CPU运行GC线程的时间与用户代码的时间的比值', 'B', '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1112, '下面代码片段描述正确的是\npublic static int cardinality(Object obj, final Collection<?> col) {\nint count = 0;\nif (col == null) {\nreturn count;\n}\nIterator<?> it = col.iterator();\nwhile (it.hasNext()) {\nObject elt = it.next();\nif ((null == obj && null == elt) || obj.equals(elt)) {\ncount++;\n}\n}\nreturn count;\n}', 'A. 存在空指针异常风险\nB. 存在数组越界风险\nC. 代码编译报错\nD. 代码无异常风险', 'A', '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1113, '哪些语句在编译时不会出现编译警告', 'A. float f = 1.3;\nB. byte b = 257;\nC. boolean b = \"isStoped\";\nD. char i = 1;', 'D', '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1114, '定义本地方法正确的是', 'A. public void native XXX();\nB. public native void XXX();\nC. public native void XXX() {}\nD. public void static native XXX();', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1115, '方法过长意味着：', 'A. 方法需要抽象\nB. 功能不单一\nC. 过于复杂\nD. 不便于他人阅读和修改代码', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1116, '包装类可以用于下面那些：', 'A. 反射方法\nB. 泛型\nC. 集合中类型\nD. POJO RPC某些不需要设置默认值的类型', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1117, '下面是字节流的是：', 'A. writer\nB. inputstream\nC. outputstream\nD. reader', 'BC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1118, '非安全的口令加密算法有：', 'A. DES\nB. RSA\nC. SKIPJACK\nD. ECDSA', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1119, 'String sql = \"select * from product where id =\" + Integer.parseInt(request.getParameter(\"id\"))该代码存在什么样的安全问题?', 'A. XSS\nB. 无安全风险\nC. 无SQL注入风险，但是将String转化为int型变量时可能会有NumberFormatException抛出\nD. SQL注入', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1120, '下列代码存在什么安全风险：\npublic static int cardinality(Object obj, final Collection<?> col) {\nint count = 0;\nif (col == null) {\nreturn count;\n}\nIterator<?> it = col.iterator();\nwhile (it.hasNext()) {\nObject elt = it.next();\nif ((null == obj && null == elt) || obj.equals(elt)) {\ncount++;\n}\n}\nreturn count;\n}', 'A. 内存溢出\nB. 内存泄露\nC. 空指针引用\nD. 无安全风险', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1121, '下面哪种操作是编程规范推荐的写法?', 'A. System.out.print(\"Hello, world!\\n\");\nB. System.out.print(\"Hello, world!\\n\\r\");\nC. stringBuilder.append(System.lineSeparator());', 'C', '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1122, '下边这段代码的输出结果为\nint fst = 5;\nint snd = 2;\nwhile (snd < fst--) {\nsnd++;\n}\nSystem.out.print(snd);', 'A. 5\nB. 2\nC. 3\nD. 4', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1123, '下列程序的输出结果为\nint num = 2;\nswitch (num) {\ncase 1:\nSystem.out.println(\"The input is 1\");\ncase 2:\nSystem.out.println(\"The input is 2\");\ncase 3:\nSystem.out.println(\"The input is 3\");\ndefault:\nSystem.out.println(\"Bad input\");\n}', 'A.\nThe input is 2\nThe input is 3\nB.\nThe input is 1\nC.\nThe input is 2\nD.\nThe input is 2\nThe input is 3\nBad input', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1124, '关于代码格式如下说法错误的是', 'A. 一个源文件按顺序包含版本、package、import、顶层类、且用空行分隔\nB. 对于非空块和块状结构，左大括号放在行尾\nC. 空行不是代码，所以代码中多写几个空行没有关系\nD. 一个类或接口的声明部分应当按照类变量、实例变量，构造器，方法的顺序出现，且用空行分隔', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1125, '哪个异常可能会泄露文件系统结构信息', 'A. java.io.FileNotFountException\nB. java.io.IOException\nC. java.util.MissResourceException\nD. java.sql.SQLException', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1126, '下列对于Stream的操作错误的是', 'A.\nfinal Stream<String> stream = Steam.of(\"Red\", \"Blue\", \"Green\");\nList<String> colors = stream.collection(Collector.toList());\nB.\nIntStream stream = IntStream.of(10, 20, 30, 40, 50);\nC.\nlong count = Stream.of().count();\nD.\nfinal Stream<String> stream = Stream.of(\"Red\", \"Blue\", \"Green\");\nSet<String> colors = Stream.toSet();', 'D', '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1127, '某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场景下会读取转储文件，下列说法错误的', 'A. 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件\nB. 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密\nC. 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除\nD. 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1129, '下列哪些行为符合安全编码规范', 'A. 某产品为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志中\nB. 某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值\nC. 某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力\nD. 某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1130, 'Java的基本类型int在不同的操作系统平台的字长是', 'A. 32位\nB. 64位\nC. 16位\nD. 在32位系统上是32位，在64位系统上是64位', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1131, '下列赋值表达式不会报错的是', 'A. boolean isStop = \"true\";\nB. float fit = 3.1;\nC. int num = 1.0;\nD. char ch = 1;', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1132, '如下代码片段，s2的结果是哪项\nString str = \"123\";\nString s2 = str + 456;', 'A. 编译错误\nB. 123456\nC. 运行时抛异常\nD. 579', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1133, '编译并运行如下Java程序，将输出\npublic static void main(String[] args) {\ntry {\nint num1 = 2;\nint num2 = 0;\nint result = num1 / num2;\nSystem.out.println(result);\n} catch (ArrayIndexOutOfBoundsException e) {\nSystem.out.println(\"1\");\n} catch (NumberFormatException e) {\nSystem.out.println(\"2\");\n} catch (Exception e) {\nSystem.out.println(\"3\");\n} finally {\nSystem.out.println(\"4\");\n}\nSystem.out.println(\"5\");\n}', 'A. 345\nB. 134\nC. 2345\nD. 1345', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1134, '在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类', 'A. Error\nB. Exception\nC. RuntimeException\nD. Throwable', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1135, '关于synchronized的叙述错误的是', 'A. 占用锁的线程在调用wait()后，会自动释放线程占有的锁\nB. sychronized在JVM层面控制线程同步\nC. 占用锁的线程在发生异常时，会自动释放线程占用的锁\nD. synchronized可用于处理读写互斥，读读不互斥的操作场景', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1137, '有关NIO Selector说法错误的是：', 'A. 可以设定Selector的监听事件，包括Connect/Accept/Read/Write\nB. Selector需要与Channel配合使用，Selector是Channel的复用器\nC. Selector本身不是一个文件，不用Close\nD. Selector等事件就绪后，才会返回，避免了大量IO阻塞', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1138, '以下命名风格正确的是：', 'A.\nenum Gender {\nmale, female\n}\nB.\nclass Test {\nprivate boolean isNotFound;\n}\nC.\nclass Test {\nprivate String userName;\n}\nD.\nclass Test {\nprivate static final int NUM_FIVE = 5;\n}', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1139, '如下代码执行结果是：\npublic class Foo {\npublic static void main(String[] args) {\nfor (float flt = (float) 1000000000; flt < 1000000010; flt++) {\nSystem.out.println(flt);\n}\n}\n}', 'A.\n1000000000\n1000000001\n1000000002\n…\n1000000010\nB. 1000000000.0\nC. 输出结果不确定\nD. 死循环', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1140, '以下代码片断输出的结果是：\npublic class Demo {\npublic static void main(String[] args) {\nInteger fst = 1;\nInteger snd = new Integer(1);\nSystem.out.println(fst == snd);\nSystem.out.println(new Integer(1) == snd);\nSystem.out.println(fst == Integer.valueOf(1));\nInteger trd = 256;\nSystem.out.println(trd == Integer.valueOf(256));\n}\n}', 'A. false,false,true,false\nB. false,false,true,true\nC. false,false,false,false\nD. true,false,false,false', 'A', '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1141, '关于遮掩，说法不正确的是', 'A. 如果一个类或者一个包被遮掩了，那么不能通过其简单名引用到它，除非是这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字\nB. 遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式\nC. 一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内\nD. 如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上', 'C', '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1142, '以下描述错误的是：', 'A. 禁止使用主动GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中\nB. 将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作\nC. 进行IO操作时，应该在try-with-resource或者finally里关闭资源\nD. 可以在循环之外的节点主动GC', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1145, '执行如下语句，最终会运行什么文件？\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\");', 'A. 仅运行test.bat，并将notepad.exe作为test.bat的参数\nB. 仅运行notepad.exe\nC. 仅运行test.bat\nD. 运行test.bat和notepad.exe', 'D', '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1146, '以下Stream用法不正确的是', 'A. long test = Stream.of(\"1\",\"2\").count()\nB. List testList = Stream.of(\"1\",\"2\").collect(Collectors.toList())\nC. IntStream t = IntStream.of(10,20,30);\nD. Stream.of(\"1\",\"2\").toSet()', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1147, '可转换为double的数据类型有哪些？', 'A. byte\nB. String\nC. float\nD. long', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1148, 'interface不能被哪些修饰词修饰?', 'A. protected\nB. final\nC. public\nD. private', 'ABD', '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1149, '以下关于抽象类的描述正确的是', 'A. 必须定义前缀为abstract\nB. 所有方法必须定义为抽象\nC. 抽象类可以实例化\nD. 抽象类必须包含一个抽象方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1150, '字节流、字符流区别描述正确的是：', 'A. 字节流关注流，不关注内容，字符流按行读取，关注文本\nB. 字节流的基类InputStream/OutputStream，字符流是Reader/Writer\nC. 字符流是对字节流的装饰，释放时反向逐一关闭\nD. 字符流最终都会按照字节流处理', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1151, '关于方法返回值描述错误的是：', 'A. 方法的返回值必须被正确解析或者使用\nB. 方法可以没有返回值\nC. 返回值可以没有被用到\nD. 方法的返回值可被忽略', 'D', '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1152, '下列接口描述正确的是：', 'A. 类可以多重继承，接口可以多重继承\nB. 类可以多重继承，接口可以单重继承\nC. 类可以单重继承，接口可以多重继承\nD. 类可以单重继承，接口可以单重继承', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1153, '接口ableA，ableB下面正确的是：', 'A. class Test implements ableA, ableB\nB. class Test implements ableA, implements ableB\nC. interface Test implements ableA, implements ableB\nD. interface Test implements ableA, ableB\nE. interface Test extends ableA, ableB', 'AE', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1154, 'JDBC数据库连接的对象类型是：', 'A. Statement\nB. Connection\nC. DriverManager\nD. PreparedStatement', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1155, '关于Java8 Stream的描述正确的是', 'A. Stream跟迭代器类似，再次遍历需要重新生成\nB. Stream执行方式跟之前代码处理方式类似，中间操作立即执行\nC. 对Stream修改体现到数据源上\nD. Stream数据源只能是数组、容器或I/O', 'A', '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1156, '根据安全编程规范，Java类加载表述正确的是：', 'A. URLClassLoader的默认签名检查依赖jar包中的公钥，因此不能仅依赖该机制对jar包进行合法性检查\nB. 开发者不可以自定义类加载器\nC. 在JVM中，将不同ClassLoader实例加载的同一个类视为相同类\nD. 当自定义一个类加载器时，为了保证赋予权限的完整，应该直接覆写getPermissions()方法，无需调用基类的getPermission()方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1157, '以下代码可能导致命令注入的有', 'A.\nString encodeIP = HWEncoder.encodeForOS(new WindowsCodec(), args[0]);\nString cmd = \"cmd.exe /c ping \" + encodeIP;\nB.\nif (Pattern.matches(\"[0-9A-Za-z@]+\", dir)) {\nProcess proc = rt.exec(\"cmd.exec /c \" + dir);\n}\nC.\nFile dir = new File(args[0]);\nif (!validate(dir)) {\nSystem.out.println(\"An illegal directory\");\n}\nD.\nProcessor proc = rt.exec(\"cmd.exe /c dir \" + args[0]);', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1158, '如下哪些是immutable的？', 'A. char\nB. String\nC. short\nD. Integer', 'BD', '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1159, '关于类加载器以下说法正确的是：', 'A. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader', 'ABC', '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1160, 'String str = \"a\" + \"b\" + \"c\" + \"d\";总共会创建几个对象？', 'A. 1\nB. 2\nC. 3\nD. 4\nE. 5', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1161, '下面程序的输出是：\nint count1 = 0;\nfor (int rowNum = 0; rowNum < 3; rowNum++) {\nfor (int colNum = 0; colNum < 4; colNum++) {\nif (colNum % 2 == 1) {\ncontinue;\n}\ncount1++;\n}\n}\nint count2 = 0;\nfor (int rowNum = 0; rowNum < 3; rowNum++) {\nfor (int colNum = 0; colNum < 4; colNum++) {\nif (colNum % 2 == 1) {\nbreak;\n}\ncount2++;\n}\n}\nSystem.out.println(count1 + \",\" + count2);', 'A. 6, 6\nB. 9, 6\nC. 3, 3\nD. 6, 3', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1162, '下列说法错误的是：', 'A. TreeMap可以有\'null\'的key和value\nB. HashTable不允许有\'null\'的key和value\nC. HashMap线程不安全，但效率高\nD. HashTable是线程安全的，推荐使用', 'A', '解析：\nTreeMap键可以为\'null\'，值不允许', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1163, '关于HashMap的描述，以下说法错误的是：', 'A. HashMap能够保证其中元素的顺序\nB. HashMap允许将\'null\'作为值\nC. HashMap允许将\'null\'用作键\nD. HashMap使用键值的形式保存数据', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1164, '属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是', 'A.\npublic class GpsLocation implements Serializable {\nprivate double from;\nprivate double to;\nprivate String id; // non-sensitive field\n// other content\n}\nB.\npublic class GpsLocation implements Serializable {\nprivate double from;\nprivate double to;\nprivate String id; // non-sensitive field\n// other content\nprivate static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"id\", String.class)};\n}\nC.\npublic class GpsLocation implements Serializable {\nprivate volatile double from;\nprivate volatile double to;\nprivate String id; // non-sensitive field\n// other content\n}\nD.\npublic class GpsLocation implements Serializable {\nprivate transient double from;\nprivate transient double to;\nprivate String id; // non-sensitive field\n// other content\n}', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1165, '关于File的描述，正确的是', 'A. File实例不能用于封装目录只用于封装文件\nB. 创建一个File类的实例将导致打开指定文件进行读写\nC. File实例封装了指定文件的信息\nD. File类位于jav.io包中', 'CD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1166, 'Java NIO Channel通道和IO流的区别，说法正确的是：', 'A. 通道可以异步读写，流是同步读写\nB. 通道和流都可以支持Selector选择器多路复用\nC. 通道可以读也可以写，流一般来说是单向的\nD. 通道是面向缓冲区的，流是面向流的', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1167, '以下哪些关键字是与线程安全相关的', 'A. const\nB. synchronized\nC. protected\nD. volatile', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1168, '关于CountDownLatch的描述，正确的是', 'A. CountDownLatch.countDown()计数为0就会释放所有线程\nB. CountDownLatch计数为0后，无法重置\nC. CountDownLatch.countdown()为计数减控制\nD. CountDownLatch.await()只能触发阻塞等待，计数不会-1', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1169, '关于锁的说法错误的是', 'A. Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例\nB. 使用new出来的Integer实例作为对象的内置锁可能导致死锁\nC. 在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁\nD. Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1170, '关于多线程并发如下说法正确的是：', 'A. 对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁\nB. 能用无锁数据结构，就不要用锁\nC. 能用对象锁，就不要用类锁\nD. 能锁区块，就不要锁方法体', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1171, 'Java语言中，如果编写一个多线程程序，可以使用的方法是', 'A. 扩展类Thread\nB. 实现Runnable接口\nC. 实现接口Thread\nD. 扩展类Runnable', 'AB', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1172, '在java中，使用JDBC时，使用PreparedStatement执行sql语句有哪些好处', 'A. 使用PreparedStatement进行sql注入防护是优选方案\nB. 使用PreparedStatement多次执行同一条sql语句可以提升执行的效率\nC. 使用PreparedStatement可以有效解决所有的sql注入问题\nD. 正确使用PreparedStatement，可以有效防止sql注入的发生', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1173, '如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 \' 、 \" 符号转义，请问如下针对mysql数据库的查询中，哪条是有可能受到sql注入攻击的？', 'A. \"select * from users where id=\" + request.getParameter(\"id\");\nB. \"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";\nC. \"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";\nD. \"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1174, '以下路径属于标准化路径（Canonical Path）的是：', 'A. ~/test\nB. /opt/oss/log\nC. $ROOT/etc/conf\nD. /opt/oss/../../etc', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1175, '关于主动调用gc方法的描述，下列说法正确的是', 'A. 在频率/周期性的逻辑中更要尽量避免主动GC的调用\nB. 在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险\nC. 调用主动GC方法后，系统立即进行垃圾回收操作\nD. 如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1176, '正则表达式/a+(bab)?(caac)*/，下列选项中是该正则表达式的子集是?', 'A. /(bab)(caca)/\nB. /a(bab){2}(caac)*/\nC. /a{2}/(*)\nD. /a+(bab){0,1}(ca)+(ca)/\nE. /a(^bab)+(caac){1,}/\nF. /a+(babc){2,}(acc){1,}/', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
