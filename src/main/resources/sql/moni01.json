[{"content":"D 在对n个元素进行快速排序的过程中，最坏情况下需要进行多少趟排序？\n\nA. \t\nn\n\n\nB. \t\nn-1\n\n\nC. \t\nn/2\n\n\nD. \t\nlogn","isHide":false,"id":292,"time":"10-09 18:31","host":"ilearning.huawei.com"},{"content":"A 关于开源，以下说法正确的是（）\n\nA. \t\n产品为实现某原创专利，独立开发的代码，此代码可确认为自研代码。\n\n\nB. \t\n产品使用了某款开源软件，但该软件对应社区已无人维护，产品由于业务需求必须继续备案使用，此时该软件完全由产品自行维护，因此可认为是自研代码。\n\n\nC. \t\n产品某开发人员参照某java开源软件的代码，以C#重写实现，此种情况可认为是自研代码。\n\n\nD. \t\n产品使用了某款开源软件，并对其进行了深度修改，修改量高达95%，剩余5%产品又修改了函数和变量名，FOSSID扫描时并没有被识别未疑似开源软件，此时产品可以将其确认为自研代码。","isHide":false,"id":294,"time":"10-09 18:32","host":"ilearning.huawei.com"},{"content":"D 以下哪一项不属于工程化软件开发所面临的根本性困难？\n\nA. \t\n软件是庞大的逻辑产品\n\n\nB. \t\n软件开发工具所提供的开发支持弱\n\n\nC. \t\n软件的复杂程度高\n\n\nD. \t\n软件系统的问题空间和解空间之间的巨大鸿沟\n\n","isHide":false,"id":296,"time":"10-09 18:32","host":"ilearning.huawei.com"},{"content":"A以下描述或做法正确的是：（）\n\nA. \t\n产品A软件开发人员在编写代码时，拷贝Apache license 2.0 的XXC++开源软件中的排序算法实现代码，以提升开发升效率\n\n\nB. \t\n某产品共130K行代码，其中仅10行代码与开源代码相似度较高；该10行代码可以直接确认为自研代码。\n\n\nC. \t\n产品A使用的开源软件被爆出存在严重漏洞（CVSS>7），产品A的安全SE分析&应用发现该漏洞涉及的代码产品A未调用，可以不需要对产品A的现网版本打补丁\n\n\nD. \t\n开源软件的选用，是产品在需求分析&应用和架构设计时决定的；同时产品需基于全量全视角视图管理确保产品及配套的平台、开源及第三方软件版本归一，并满足生命周期要求\n\n","isHide":false,"id":298,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"D某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）\n\nA. \t\n由于该特性设计文档已经基线，所以不能更新。\n\n\nB. \t\n根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。\n\n\nC. \t\n由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。\n\n\nD. \t\n更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。","isHide":false,"id":300,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"A函数搬移是代码重构的一个重要方法，下列重构使用了函数搬移方法的是（）\n\nA. \t\n从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。\n\n\nB. \t\n将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。\n\n\nC. \t\n当发现类A某个函数不仅仅适用于当前类，还适用于其它的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。\n\n\nD. \t\n类A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及其相关操作。","isHide":false,"id":302,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"D使用UML对系统进行动态建模，不能使用以下哪种图？（）\n\nA. \t\n顺序图\n\n\nB. \t\n类图\n\n\nC. \t\n状态图\n\n\nD. \t\n活动图","isHide":false,"id":304,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"A在软件需求工程中，需求管理贯穿整个过程。需求管理最基本的任务是明确需求，使项目团队和用户达成共识，建立（）\n\nA. \t\n需求跟踪说明\n\n\nB. \t\n需求变更管理文档\n\n\nC. \t\n需求分析计划\n\n\nD. \t\n需求基线","isHide":false,"id":306,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"A某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用以下哪个设计模式最为恰当？（）\n\nA. \t\n适配器模式（ADAPTER）\n\n\nB. \t\n迭代器模式（ITERATOR）\n\n\nC. \t\n访问者模式（VISITOR）\n\n\nD. \t\n观察者模式（OBSERVER）","isHide":false,"id":308,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"B从数据组织重构的角度看，下面描述不合理的是（）\n\nA. \t\n开发初期如果类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。\n\n\nB. \t\n对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。\n\n\nC. \t\n对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知","isHide":false,"id":310,"time":"10-09 18:53","host":"ilearning.huawei.com"},{"content":"A对需求管理，理解不正确的是（）\n\nA. \t\n纯软件需求决策由软件RMT负责\n\n\nB. \t\n产品软硬件结合需求决策由对应产品SPDT RMT负责\n\n\nC. \t\n需求冲突时可在CCB会议仲裁\n\n\nD. \t\n产品RAT负责各产品系列的软硬结合需求分析","isHide":false,"id":312,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"A违反密钥用途单一规则的有（ ）\n\nA. \t\n同一个预共享密钥，既可以用于认证，又可以用于完整性保护。\n\n\nB. \t\n一个密钥可以通过算法派生成两个密钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。\n\n\nC. \t\n分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务。\n\n\nD. \t\n数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务。\n\n","isHide":false,"id":314,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"B关于随机数的描述，错误的是( )\n\nA. \t\n真正意义上的随机数其结果是不可预测的，安全随机数并非真正意义上的随机数。\n\n\nB. \t\n现代密码学是基于密钥安全的，随机数的质量决定密钥的质量。\n\n\nC. \t\nC标准库函数random( )所产生的随机数不属于安全随机数。\n\n\nD. \t\n安全随机数的要求是不可预测、绝对安全。","isHide":false,"id":316,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"C根据华为Java编程规范，这段代码违反了哪个条目？\n\npublic static List<String> decorate(String[] personDescs) {\n    if (personDescs == null || personDescs.length == 0) {\n        return null;\n    }\n    List<String> personNames = new ArrayList<>(personDescs.length);\n    for (String personDesc : personDescs) {\n        String personName = getPersonName(personDesc);\n        if (personName != null && personName.length() != 0) {\n            personNames.add(personName);\n        }\n    }\n    return personNames;\n}\npublic static void main(String[] args) {\n    // Do something here.\n    List<String> personNames = decorate(personDescs);\n    if (personNames == null) {\n        return;\n    }\n    for (String personName : personNames) {\n        // Do something here.\n    }\n}\nA. \t\n使用类名调用静态方法，而不要使用实例或表达式来调用\n\n\nB. \t\n方法的代码块不要嵌套过深，不能超过4层\n\n\nC. \t\n当返回类型为数组或者容器时，应返回长度为0的数组或者容器\n\n\nD. \t\npersonName变量需要判断是否为null\n\n","isHide":false,"id":318,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"A根据Java编程规范，可以出现在代码里的空白字符是（ ）\n\nA. \t\nASCII空格符号\n\n\nB. \t\n全角空格符\n\n\nC. \t\nTab制表符\n\n\nD. \t\n其他选项均可","isHide":false,"id":320,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"B根据编程规范的要求，正常业务处理日志用（）级。\n\nA. \t\ndebug\n\n\nB. \t\ninfo\n\n\nC. \t\nwarn\n\n\nD. \t\nerror","isHide":false,"id":322,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"D以下对文件的操作做法中错误的是（）\n\nA. \t\n校验文件路径时使用getCanonicalPath()获取文件路径\n\n\nB. \t\n使用Files.newByteChannel()在文件创建时指定合适的权限\n\n\nC. \t\n临时文件使用完毕之后、系统终止之前，应该显式地对其进行删除\n\n\nD. \t\n从ZipInputStream中解压文件时仅调用ZipEntry.getSize()方法判断解压文件大小","isHide":false,"id":324,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"A关于java中调用外部进程的说法中，错误的是（ ）\n\nA. \t\n外部程序运行时由java.lang.Process对象描述。这个对象包含一个输入流，输出流，以及一个错误流。\n\n\nB. \t\n外部进程的输出流是一个OutputStream对象，可以通过Process的静态方法getOutputStream获取。\n\n\nC. \t\n一个外部进程如果试图从一个空的输入流中读取输入，则会一直阻塞，直到为其提供输入。\n\n\nD. \t\n一个外部进程的输出可能会耗尽该进程输出流与错误流的缓冲区。当发生这种情况时，Java 程序可能会阻塞外部进程，同时阻碍Java程序与外部程序的继续运行。","isHide":false,"id":326,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"C关于java.nio.ByteBuffer对象的说法中，不正确的是（ ）\n\nA. \t\nwrap()方法将原始类型数组包装成一个buffer对象并返回，对buffer对象的修改会同步修改原始的数据\n\n\nB. \t\nslice()方法会创建一个新的buffer对象，修改这个新buffer对象会导致原始的封装数据也被修改\n\n\nC. \t\nduplicate()方法会创建一个新的buffer对象，修改这个新buffer对象不会影响原始的封装数据\n\n\nD. \t\nasReadOnlyBuffer()方法返回一个只读的对象，不能修改buffer中的数据\n\n","isHide":false,"id":328,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"Cjava的安全管理器SecurityManager的policy文件配置如下：\ngrant {\n… …\npermission java.util.PropertyPermission “java.version”, “read”;\n… …\n};\n\npublic static void main(String... args) {\n    System.setSecurityManager(new SecurityManager());\n    System.setProperty(\"java.version\", \"1.7.0_45\");\n    String javaNewVersion = System.getProperty(\"java.version\");\n    System.err.println(javaNewVersion);\n}\n注：sdk的版本是1.8.0_45\n程序输出的结果是哪一项？\n\nA. \t\n1.7.0_45\n\n\nB. \t\n1.8.0_45\n\n\nC. \t\njava.security.AccessControlException: access denied\n\n\nD. \t\n不确定\n\n","isHide":false,"id":330,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"D下列生成随机数最安全的方法为？\n\nA. \t\nMath.random()\n\n\nB. \t\njava.util.Random()\n\n\nC. \t\njava.util.concurrent.ThreadLocalRandom()\n\n\nD. \t\njava.security.SecureRandom()","isHide":false,"id":332,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"A以下代码运行结果是：\n\npublic class Parent {\n    static int firstVar = 1;\n    static {\n        System.out.println(\"Class Parent:static blocks\" + firstVar);\n        firstVar++;\n    }\n    int secondVar = 1;\n    static {\n        System.out.println(\"Class Parent:static blocks\" + firstVar);\n        firstVar++;\n    }\n    public Parent() {\n        System.out.println(\"constructor Parent: firstVar=\" + firstVar + \",secondVar=\" + secondVar);\n        firstVar++; secondVar++;\n    }\n    {\n        System.out.println(\"Class Parent:common blocks firstVar=\" + firstVar + \",secondVar=\" + secondVar);\n        firstVar++; secondVar++;\n    }\n    // 非静态方法\n    public void bDisplay() {\n        System.out.println(\"Class Parent:static void bDisplay(): \" + \"firstVar=\" + firstVar + \",secondVar=\" + secondVar);\n        secondVar++; firstVar++;\n    }\n    // 静态方法\n    public static void bTest() {\n        System.out.println(\"Class Parent:static void bTest(): firstVar=\" + firstVar);\n        firstVar++;\n    }\n}\npublic class Child extends Parent {\n    static int firstVar = 1;\n    static {\n        System.out.println(\"Class child:static blocks\" + firstVar);\n        firstVar++;\n    }\n    static {\n        System.out.println(\"Class child:static blocks\" + firstVar);\n        firstVar++;\n    }\n    int secondVar = 1;\n    {\n        System.out.println(\"Class child:common blocks firstVar=\" + firstVar + \",secondVar=\" + secondVar);\n        firstVar++;\n        secondVar++;\n    }\n    public Child() {\n        super();\n        System.out.println(\"constructor child: firstVar=\" + firstVar + \",secondVar=\" + secondVar);\n        firstVar++; secondVar++;\n    }\n    public static void aTest() {\n        System.out.println(\"Class child:static void aTest(): firstVar=\" + firstVar);\n        firstVar++;\n    }\n    public void aDisplay() {\n        System.out.println(\"Class child:static void aDisplay():  firstVar=\" + firstVar + \",secondVar=\" + secondVar);\n        firstVar++;\n    }\n    public static void main(String[] args) {\n        Child child = new Child();\n        child.aDisplay();\n    }\n}\nA. \t\nClass Parent:static blocks1\nClass Parent:static blocks2\nClass child:static blocks1\nClass child:static blocks2\nClass Parent:common blocks firstVar=3,secondVar=1\nconstructor Parent: firstVar=4,secondVar=2\nClass child:common blocks firstVar=3,secondVar=1\nconstructor child: firstVar=4,secondVar=2\nClass child:static void aDisplay():  firstVar=5,secondVar=3\n\nB. \t\nClass Parent:static blocks1\nClass child:static blocks1\nClass Parent:static blocks2\nClass child:static blocks2\nClass Parent:common blocks firstVar=3,secondVar=1\nconstructor Parent: firstVar=4,secondVar=2\nClass child:common blocks firstVar=3,secondVar=1\nconstructor child: firstVar=4,secondVar=2\nClass child:static void aDisplay():  firstVar=5,secondVar=3\n\nC. \t\nClass Parent:static blocks1\nClass Parent:static blocks2\nClass Parent:common blocks firstVar=3,secondVar=1\nconstructor Parent: firstVar=4,secondVar=2\nClass child:static blocks1\nClass child:static blocks2\nClass child:common blocks firstVar=3,secondVar=1\nconstructor child: firstVar=4,secondVar=2\nClass child:static void aDisplay():  firstVar=5,secondVar=3\n\nD. \t\nClass Parent:static blocks1\nClass Parent:static blocks2\nClass child:static blocks1\nClass child:static blocks2\nconstructor Parent: firstVar=4,secondVar=2\nClass Parent:common blocks firstVar=3,secondVar=1\nconstructor child: firstVar=4,secondVar=2\nClass child:common blocks firstVar=3,secondVar=1\nClass child:static void aDisplay():  firstVar=5,secondVar=3","isHide":false,"id":334,"time":"10-09 18:54","host":"ilearning.huawei.com"},{"content":"D下列哪个不是Class类中定义的反射方法？\n\nA. \t\ngetDeclaredFileds\n\n\nB. \t\ngetDeclaredNames\n\n\nC. \t\ngetDeclaredMethods\n\n\nD. \t\ngetDeclaredConstructors","isHide":false,"id":336,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"C某测试环境发现部署的java进程(pid=17212)经常Full GC,长期内存占用很高,疑似内存泄漏。现在想要确定是哪些类的实例占内存较多,那么应该用下列选项中的哪个命令？\n\nA. \t\njmap -histo 17212\n\n\nB. \t\ntop -Hp 17212\n\n\nC. \t\njstack 17212\n\n\nD. \t\njstat -gcutil 17212","isHide":false,"id":338,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"C下列程序calc()方法的返回值是？\n\npublic class Test {\n    private static final int TENK = 10000;\n    private static long count = 0;\n    private void add10K() {\n        int idx = 0;\n        while(idx++ < TENK) {\n            count += 1;\n        }\n    }\n    public static long calc() throws InterruptedException {\n        final Test test = new Test();\n        // 创建两个线程，执行 add() 操作\n        Thread th1 = new Thread(test::add10K);\n        Thread th2 = new Thread(test::add10K);\n        // 启动两个线程\n        th1.start();\n        th2.start();\n        // 等待两个线程执行结束\n        th1.join();\n        th2.join();\n        return count;\n    }\n}\nA. \t\n10000\n\n\nB. \t\n20000\n\n\nC. \t\n10000到20000之间的任意数\n\n\nD. \t\n大于20000的任意数","isHide":false,"id":340,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"D以下有关 PreparedStatement的描述错误的是（）\n\nA. \t\nPreparedStatement继承自Statement，都是接口\n\n\nB. \t\nPreparedStatement可以使用占位符，是预编译的，可以有效防止SQL注入\n\n\nC. \t\nPreparedStatement可以通过Connection对象的 prepareStatement()方法创建\n\n\nD. \t\nPreparedStatement中void setString(int parameterIndex, String x) throws SQLException方法从0开始计算替换占位符","isHide":false,"id":342,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"C下列使用NIO对文件读写进行操作，哪个是错误的：\n\nA. \t\n读小文件的所有字节：\n\nbyte[] bytes = Files.readAllBytes(file.toPath());\n\nB. \t\n读小文本中所有的行：\n\nList<String> lines = Files.readAllLines(file.toPath());\n\nC. \t\n将数据写入文件尾：\n\n// file与lines为合法参数\nFiles.write(file.toPath(), lines, StandardCharsets.UTF_8, StandardOpenOption.CREATE);\n\nD. \t\n读取大文本：\n\ntry (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {\n    String line = null;\n    while ((line = reader.readLine()) != null) {\n        // ...\n    }\n} catch (IOException x) {\n    // ...\n}","isHide":false,"id":344,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"B控制变量不被序列化的关键字是：（）\n\nA. \t\nvolatile\n\n\nB. \t\ntransient\n\n\nC. \t\nfinal\n\n\nD. \t\nprivate","isHide":false,"id":346,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"Binterface中声明的变量默认具有的修饰符是（）\n\nA. \t\npublic\n\n\nB. \t\npublic static\n\n\nC. \t\npublic final\n\n\nD. \t\npublic static final","isHide":false,"id":348,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"C如下哪个类不是继承自InputStream/OutputStream ?\n\nA. \t\nObjectInputStream\n\n\nB. \t\nBufferedOutputStream\n\n\nC. \t\nRandomAccessFile\n\n\nD. \t\nByteArrayInputStream","isHide":false,"id":350,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"C如下代码的打印结果是（）\n\nint[] arr = {100, 101, 102};\nOUTER:\nwhile (true) {\n    for (int i = 0; i < arr.length; ++i) {  \n        if (i == 1) {\n            break OUTER;\n        } else {\n            System.out.println(\"A\");\n        }\n    }\n    System.out.println(\"B\");\n}\nSystem.out.println(\"C\");\nA. \t\n3个A和无数个B\n\n\nB. \t\n1个A和1个C\n\n\nC. \t\n1个A和无数个B\n\n\nD. \t\n编译错误\n\n","isHide":false,"id":352,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"D执行如下测试类，输出结果是（）\n\npublic class SampleTest {\n    @BeforeClass\n    public static void beforeClass() {\n        System.out.println(\"BeforeClass\");\n    }\n    @Before\n    public void setUp() {\n        System.out.println(\"Before\");\n    }\n    @After\n    public void tearDown() {\n        System.out.println(\"After\");\n    }\n    @AfterClass\n    public static void afterClass() {\n        System.out.println(\"AfterClass\");\n    }\n    @Test\n    public void firstCase() {\n    }\n    @Test\n    public void secondCase() {\n    }\n}\nA. \t\nBeforeClass\nBefore\nAfter\nAfterClass\n\n\nB. \t\n无输出\n\n\nC. \t\nBeforeClass\nBeforeClass\nBefore\nAfter\nBefore\nAfter\nAfterClass\nAfterClass\n\n\nD. \t\nBeforeClass\nBefore\nAfter\nBefore\nAfter\nAfterClass\n\n","isHide":false,"id":354,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"D以下哪项数据是可信的（ ）\n\nA. \t\nrestful接口中传入的参数\n\n\nB. \t\n函数参数（对于API）\n\n\nC. \t\n页面中的用户输入\n\n\nD. \t\n类中定义的常量值","isHide":false,"id":356,"time":"10-09 18:55","host":"ilearning.huawei.com"},{"content":"C当线程调用start()后，其所处状态为（ ）。\n\nA. \t\n阻塞状态\n\n\nB. \t\n运行状态\n\n\nC. \t\n就绪状态\n\n\nD. \t\n新建状态","isHide":false,"id":358,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"D有以下程序段：\n\nclass MyThread extends Thread {\n    public static void main(String[] args) {\n        MyThread t1 = new MyThread();\n        MyThread t2 = new MyThread();\n        t1.start();\n        System.out.print(\"one.\");\n        t2.start();\n        System.out.print(\"two.\");\n    }\n    public void run() {\n        System.out.print(\"Thread\");\n    }\n}\n则下面正确的选项是？\n\nA. \t\n编译失败\n\n\nB. \t\n程序运行结果为：\none.Threadtwo.Thread\n\n\nC. \t\n程序运行结果是：\none.two.ThreaThread\n\n\nD. \t\n程序运行结果不确定","isHide":false,"id":360,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"C关于下面代码,下列选项中说法正确的是？\n\nfinal int limit = 5;\nMap<Integer, String> map = new LinkedHashMap(16, 0.75f, true) {\n    protected boolean removeEldestEntry(Map.Entry eldest) {\n        return size() > limit;\n    }\n};\nfor (int i = 0; i < 10; i++) {\n    map.put(i, String.valueOf(i));\n}\nString v = map.get(6);\nmap.keySet().forEach(System.out::print);\nA. \t\n代码运行后,控制台打印65789\n\n\nB. \t\n代码运行后,控制台打印95678\n\n\nC. \t\n代码运行后,控制台打印56789\n\n\nD. \t\n代码运行后,控制台打印57896","isHide":false,"id":362,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"C以下关于java Stream的描述正确的是( )\n\nA. \t\nStream执行方式跟之前代码处理方式类似，中间操作是立即执行的。\n\n\nB. \t\nStream数据源只能是数组、容器或者I/O。\n\n\nC. \t\n对Stream的修改都会体现到数据源上。\n\n\nD. \t\nStream跟迭代器类似，再次遍历需要重新生成。","isHide":false,"id":364,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"B如下代码的输出是（）\n\nclass Base {\n    public int id = 100;\n    public void doSomething() {\n        System.out.println(\"Base\");\n    }\n}\nclass Child extends Base {\n    public int id = 101;\n    @Override\n    public void doSomething() {\n        System.out.println(\"Child\");\n    }\n    public static void main(String[] args) {\n        Base base = new Child();\n        System.out.println(base.id);\n        base.doSomething();\n    }\n}\nA. \t\n100\nBase\n\n\nB. \t\n100\nChild\n\n\nC. \t\n101\nBase\n\n\nD. \t\n101\nChild\n\n","isHide":false,"id":366,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"D执行如下语句，最终会运行什么文件（ ）\n\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\");\nA. \t\n仅运行test.bat\n\n\nB. \t\n仅运行notepad.exe\n\n\nC. \t\n仅运行test.bat，并将notepad.exe作为test.bat的参数\n\n\nD. \t\n运行test.bat和notepad.exe\n\n","isHide":false,"id":368,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"C如下程序的输出为（）\n\nString s = \"123456\";\nString s1 = \"123456\";\nString s2 = \"123\" + \"456\";\nString s3 = \"456\";\nString s4 = \"123\" + s3;\nSystem.out.print (s == s1);\nSystem.out.print (s == s2);\nSystem.out.print (s == s4);\nA. \t\nfalse false false\n\n\nB. \t\ntrue false false\n\n\nC. \t\ntrue true false\n\n\nD. \t\ntrue true true","isHide":false,"id":370,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"D以下代码片段中，GC执行时程序运行到“run at this line when GC”这一逻辑行,GC允许回收哪个对象？\n\nclass GcTest {\n    public static final String CONSTANT = \"I am a string\";\n    private static Info staticInfo = new Info();\n    public static void main(String[] args) {\n        Info info = new Info();\n        info.doSomething();\n        info = null;\n        // run at this line when GC\n        System.out.println(\"xxx\");\n    }\n}\nclass Info {\n    void doSomething() {\n        System.out.println(GcTest.CONSTANT);\n    }\n}\nA. \t\nstaticInfo对象\n\n\nB. \t\nCONSTANT对象\n\n\nC. \t\n“I am a string”对象\n\n\nD. \t\n第7行分配的Info对象","isHide":false,"id":372,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"D有以下一段代码：\n\npublic class PrintCollection {\n    public void print(List<String> collection) {\n        Collections.sort(collection, (s1, s2) -> s1.compareTo(s2));\n        collection.stream().forEach(System.out::println);\n    }\n    public static void main(String[] args) {\n        List<String> list1 = Arrays.asList(\"4\", \"3\", \"2\", \"1\");\n        PrintCollection printer = new PrintCollection();\n        printer.print(list1);\n    }\n}\n请问使用以下哪条命令编译无编译错误？\n\nA. \t\njavac -source 5 -Xlint:all PrintCollection.java\n\n\nB. \t\njavac -source 6 -Xlint:all PrintCollection.java\n\n\nC. \t\njavac -source 7 -Xlint:all PrintCollection.java\n\n\nD. \t\njavac -source 8 -Xlint:all PrintCollection.java","isHide":false,"id":374,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"D无情重构又称童子军原则，指你打开一个代码，如果很难理解，就应该试着去重构它，你离开的时候代码应该比你来的时候更易懂。\n但是通常我们由于缺乏足够的知识，不能在无情重构中进行复杂的重构，常常以抽取函数为主，但不好的抽取并不能让代码更易理解，反而更复杂。\n那么今天，你打开了下列的代码，可能不清楚具体的业务背景，但请尝试用函数抽取的方式进行无情重构。\n你觉得哪部分代码被抽出去作为一个函数，并不能提升代码的可读性（请忽略不同编程语言的规范和语法差异）。( )\n\n1 public class BusinessSite {\n2     private Reading[] readings = new Reading[1000];\n3     private static final double START_RATE = 0.09;\n4     private static double END_RATE = 0.05;\n5     private static int END_AMOUNT = 1000;\n6 \n7     public void addReading(Reading newReading) {\n8         readings[++lastReading] = newReading;\n9     }\n10 \n11    private int lastReading;\n12 \n13    public Dollars charge() {\n14        Dollars result;\n15        int usage = readings[lastReading].getAmount() - readings[lastReading - 1].getAmount();\n16        if (usage == 0) {\n17            return new Dollars(0);\n18        }\n19        double t1 = START_RATE - ((END_RATE * END_AMOUNT) - START_RATE) / (END_AMOUNT - 1);\n20        double t2 = ((END_RATE * END_AMOUNT) - START_RATE) * Math.min(END_AMOUNT, usage) /\n21                (END_AMOUNT - 1);\n22        double t3 = Math.max(usage - END_AMOUNT, 0) * END_RATE;\n23        result = new Dollars(t1 + t2 + t3);\n24        result = result.plus(new Dollars(usage * 0.0175));\n25\n26        Dollars base1 = new Dollars(result.min(new Dollars(50)).times(0.07));\n27        if (result.isGreaterThan(new Dollars(50))) {\n28            base1 = new Dollars(base1.plus(result.min(new Dollars(75)).minus(\n29                    new Dollars(50)).times(0.06)\n30            ));\n31        }\n32        if (result.isGreaterThan(new Dollars(75))) {\n33            base1 = new Dollars(base1.plus(result.minus(new Dollars(75)).times(0.05)));\n34        }\n35        result = result.plus(base1);\n36        return result;\n37   }\n38 }\nA. \t\n第15行\n\n\nB. \t\n第19～23行\n\n\nC. \t\n第26～34行\n\n\nD. \t\n第14～24行\n\n","isHide":false,"id":376,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"A基于《密码算法应用规范》,下列哪种随机数生成方式自身会出现安全漏洞？\n\nA. \t\nLinux操作系统的/dev/random设备接口\n\n\nB. \t\nOpenSSL1.1.X的RAND_priv_bytes\n\n\nC. \t\nNIST SP 800-90A标准中的DualEC-DRBG生成器\n\n\nD. \t\nJDK的java.security.SecureRandom","isHide":false,"id":378,"time":"10-09 18:56","host":"ilearning.huawei.com"},{"content":"D两台设备间需要通过外部网络传输和协商秘钥信息，为了防止传输过程中信息被攻击者篡改，下面哪个方法可以识别出信息被篡改：\n\nA. \t\n使用CRC32校验\n\n\nB. \t\n使用SHA512校验\n\n\nC. \t\n使用ASE256进行加密保护\n\n\nD. \t\n使用TLS协议来传输信息","isHide":false,"id":380,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABD哈希表有14个桶，哈希函数为h(key)=key%11。表中现有数据30、48、66、18、72和90，如果分别采用线性探测法和二次探测再散列处理冲突，则28的位置（从0开始计数）可能是（）\n\nA. \t\n9\n\n\nB. \t\n10\n\n\nC. \t\n11\n\n\nD. \t\n12","isHide":false,"id":382,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABCD针对重构方法，下列说法错误的是（）\n\nA. \t\n提取接口（Extract Interface）和提取超类（Extract Superclass）本质上是一回事，均可提取通用代码。\n\n\nB. \t\n隐藏委托关系（Hide Delegate）会使代码层次更清晰，因此委托类的功能越多越好。\n\n\nC. \t\n当发现某个子类并未带来该有的派生价值时，可以考虑使用移除子类（Remove Subclass）手法进行重构。\n\n\nD. \t\n将值域上移到父类（即字段上移 Pull Up Field）会有效减少子类的成员变量，只需要搬移值域，不需要搬移对该值域的操作方法。\n\n","isHide":false,"id":384,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABC下面哪些设计是符合权限最小化要求的？（）\n\nA. \t\n一个帐号只能拥有该角色必需的权限，不分配不必要的权限。\n\n\nB. \t\n权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则。\n\n\nC. \t\n为保证有足够权限读取到数据，连接Web服务数据库应该使用Administrator帐号。\n\n\nD. \t\n审计日志只有管理员或日志审计员有权限读取，普通用户无法访问读取。\n\n","isHide":false,"id":386,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABC下面保护操作系统的做法正确的有（ ）\n\nA. \t\n关闭没有使用的服务，如：Telnet和FTP\n\n\nB. \t\n对存有重要信息的文件目录或分区进行加密\n\n\nC. \t\n启用SELinux，增强系统安全性\n\n\nD. \t\n使用Auditd组件对系统中的重要目录或文件进行审计\n\n","isHide":false,"id":388,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABCD根据华为Java编程规范,下列选项中变量声明错误的有哪些？\n\nA. \t\nint a, b;\n\nB. \t\nint replacementLen = replacement.length();\nString string = sequence.toString();\nint pos = indexIn(string);\nif (replacementLen == 0) {\n    return removeFrom(sequence);\n}\nif (replacementLen == 1) {\n    return replaceFrom(sequence, replacement.charAt(0));\n}\nif (pos == -1) {\n    return string;\n}\n\nC. \t\nString args[];\n\nD. \t\npublic boolean matches(char c) {\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\u205f':\n        case '\\u3000':\n            return true;\n        case '\\u2007':\n            return false;\n        default:\n            return false;\n    }\n}","isHide":false,"id":390,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABCD如下说法正确的是（ ）\n\nA. \t\nOptional类主要解决的问题是空指针异常（NullPointerException）\n\n\nB. \t\n实现Serializable接口的可序列化类应该显式声明serialVersionUID\n\n\nC. \t\n尽量避免实现Serializable接口\n\n\nD. \t\n不要在控制性条件表达式中执行赋值","isHide":false,"id":392,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"AB以下异常列表哪些属于敏感异常？\n\nA. \t\njava.io.FileNotFoundException\n\n\nB. \t\njava.sql.SQLException\n\n\nC. \t\njava.lang.NullPointerException\n\n\nD. \t\njava.io.IOException","isHide":false,"id":394,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABCD如下用例运行失败的有（）\n\nA. \t\n@Test(timeout = 100)\npublic void testWithTimeout() throws Exception {\n    TimeUnit.MILLISECONDS.sleep(10);\n}\n\nB. \t\n@Rule\npublic Timeout globalTimeout = Timeout.seconds(10);\n@Test\npublic void testWithTimeout() throws Exception {\n    TimeUnit.SECONDS.sleep(11);\n}\n\nC. \t\n@Rule\npublic Timeout globalTimeout = Timeout.seconds(5);\n@Test(timeout = 7 * 1000)\npublic void testTimeOut() throws Exception {\n    TimeUnit.SECONDS.sleep(6);\n}\n\nD. \t\n@Rule\npublic Timeout globalTimeout = Timeout.seconds(7);\n@Test(timeout = 5 * 1000)\npublic void testTimeOut() throws Exception {\n    TimeUnit.SECONDS.sleep(6);\n}","isHide":false,"id":396,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABCD如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 ‘ 和 “ 符号转义，请问如下针对 mysql 数据库的查询中，哪条是有可能受到sql 注入攻击的？\n\nA. \t\n\"select * from users where id=\" + request.getParameter(\"id\");\n\nB. \t\n\"select * from users where username='\" + request.getParameter(\"username\") + \"' and password='\" + request.getParameter(\"password\") + \"' limit 1\";\n\nC. \t\n\"select * from papers where title='\" + request.getParameter(\"title\") + \"'\";\n\nD. \t\n\"select * from papers where time='xxxxx' order by \" + request.getParameter(\"columnName\");","isHide":false,"id":398,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"ABD当我们做简单业务，通过数据库连接池，获得一个数据库连接Connection，执行一个Statement，获得一个ResultSet后，就结束业务了，那么下面错误的是?\n\nA. \t\n我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显式地关闭ResultSet和Statement，保持代码简单和简洁。\n\n\nB. \t\n我们需要先关闭Connection，接着显式地关闭ResultSet和Statement。\n\n\nC. \t\n我们需要先关闭Connection，接着显式地关闭Statement和ResultSet\n\n\nD. \t\n我们需要先关闭ResultSet和Statement，然后Connection就自动被关闭了，不需要显式地关闭Connection。","isHide":false,"id":400,"time":"10-09 18:57","host":"ilearning.huawei.com"},{"content":"BCD以下单例类实现正确的是（）\n\nA. \t\npublic final class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\nB. \t\npublic final class Singleton {\n    private static class SingletonHolder {\n        private static Singleton instance = new Singleton();\n    }\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return SingletonHolder.instance;\n    }\n}\n\nC. \t\npublic final class Singleton {\n    private static volatile Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) {\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\nD. \t\npublic final class Singleton {\n    private static Singleton instance = new Singleton();\n    private Singleton() {}\n    public static Singleton getInstance() {\n        return instance;\n    }\n}","isHide":false,"id":402,"time":"10-09 18:58","host":"ilearning.huawei.com"},{"content":"AD以下可能造成死锁的代码是（）\n\nA. \t\npublic class LeftRightLock {\n    private final Object left = new Object();\n    private final Object right = new Object();\n    public void functionA() {\n        synchronized (left) {\n            synchronized (right) {\n                doSomething();\n            }\n        }\n    }\n    public void functionB() {\n        synchronized (right) {\n            synchronized (left) {\n                doSomething();\n            }\n        }\n}\n……\n}\n\nB. \t\npublic void transferMony(Account fromAccount, Account toAccount, int amount) {\n    synchronized (fromAccount) {\n        synchronized (toAccount) {\n            fromAccount.debit(amount);\n            toAccount.credit(amount);\n        }\n    }\n}\n\nC. \t\npublic class Taxi {\n    private Point location;\n    private Point destinztion;\n    private final Dispatcher dispatcher;\n    public Taxi(Dispatcher dispatcher) {\n        this.dispatcher = dispatcher;\n    }\n    public synchronized Point getLocation() {\n        return location;\n    }\n    public synchronized void setLocation(Point location) {\n        this.location = location;\n        if (this.location.equals(destinztion)) {\n            dispatcher.notifyAvailable(this);\n        }\n}\n……\n}\npublic class Dispatcher {\n    private final Set<Taxi> taxis = new HashSet<>();\n    private final Set<Taxi> availableTaxis = new HashSet<>();\n    public synchronized void notifyAvailable(Taxi taxi) {\n        availableTaxis.add(taxi);\n    }\n    public synchronized Image getImage() {\n        final Image image = new Image();\n        for (final Taxi taxi : taxis) {\n            image.drawMarket(taxi.getLocation());\n        }\n        return image;\n}\n……\n}\n\nD. \t\nprivate final ExecutorService executor = Executors.newSingleThreadExecutor();\npublic void renderPage() throws InterruptedException, ExecutionException{\n    Future<String> page = executor.submit(new RenderPageTask());\n    frame.set(page.get());\n}\npublic class RenderPageTask implements Callable<String> {\n    @Override\n    public String call() throws Exception {\n        final Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));\n        final Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));\n        return header.get() + \"page\" + foot.get();\n    }\n}","isHide":false,"id":404,"time":"10-09 18:58","host":"ilearning.huawei.com"},{"content":"AD在使用java中的套接字（socket）时，下列代码实现中，哪些选项可能会导致主线程长时间阻塞？\n\nA. \t\nSocket s = new Socket(\"10.116.123.112\", 6526);\nInputStream stream = s.getInputStream();\n// use thread read data\n\nB. \t\nSocket s = new Socket(\"10.116.123.112\", 6526);\ns.setSoTimeout(2000);\nInputStream stream = s.getInputStream();\n// use thread read data\n\nC. \t\nSocket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526), 1000);\nInputStream stream = s.getInputStream();\n// use thread read data\n\nD. \t\nSocket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526));\nInputStream stream = s.getInputStream();\n// use thread read data\n","isHide":false,"id":406,"time":"10-09 18:58","host":"ilearning.huawei.com"},{"content":"ABCD对于架构威胁建模方法（STRIDE-SD）中的关键活动，以下哪些描述是正确的？\n\nA. \t\n价值资产识别：根据系统部件和数据对系统所有者的价值，从软件、硬件、服务、人员等维度识别系统中的价值资产\n\n\nB. \t\n暴露面及其风险分析：对产品暴露的硬件、软件接口及协议栈进行全面的梳理，并评估暴露面风险\n\n\nC. \t\n攻击路径分析：从价值资产的成功攻击为根节点，逐步展开使攻击成功的各级子节点，直至暴露面，形成攻击树\n\n\nD. \t\n威胁建模：考虑到系统已被入侵的可能，对系统架构元素建立全面的威胁模型","isHide":false,"id":408,"time":"10-09 18:58","host":"ilearning.huawei.com"},{"content":"ABCD张三要给李四写一封信，为了确保内容不被泄漏，张三采用了如下行为：将信的内容按照密码本进行替换，并将密码本放到用只有李四可以打开的带锁的盒子中，然后在信封上写上”信内一共有 200 个字和1000个笔画”，最后将信和盒子快递给李四。从类比角度思考，请问这个过程利用了哪些密码学算法思想( )\n\nA. \t\n对称加密算法\n\n\nB. \t\n非对称加密算法(加密)\n\n\nC. \t\n非对称加密算法(签名)\n\n\nD. \t\n散列函数","isHide":false,"id":410,"time":"10-09 18:58","host":"ilearning.huawei.com"}]
