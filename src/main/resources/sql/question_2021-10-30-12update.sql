INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`,
                                   `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`,
                                   `right_times`, `doubted_times`)
VALUES (1029, ''关于Thread类提供线程控制方法，说法错误的'', ''A. 线程A执行线程B的join方法，则线程A等待直到B执行完成\nB. 线程A通过调用interrupt方法中断其阻塞状态\nC. 若线程A调用方法isAlive返回值为false，则说明A正在执行中，也可能是可运行状态\nD. 调用currentThread()方法返回当前线程的引用'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`,
                                   `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`,
                                   `right_times`, `doubted_times`)
VALUES (1030, ''有关ORM的说法错误的是'', ''A. ORM的缓存机制可以提高数据操作性能，Hibernate没有缓存机制\nB. ORM依赖于JDBC和DataSource\nC. ORM有多种实现，主流的Mybatis与Hibernate\nD. ORM、对象关系转换，即数据库的单条数据与Java对应之间的映射'', ''A'', ''解析：\nHibernate有缓存机制'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`,
                                   `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`,
                                   `right_times`, `doubted_times`)
VALUES (1031, ''以下哪种方式创建的线程池适合使用在很耗时的任务'', ''A. Executors.newCachedThreadPool()\nB. Executors.newFixedThreadPool()\nC. Executors.newWorkStealingPool()\nD. Executors.newSingleThreadExecutor()'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`,
                                   `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`,
                                   `right_times`, `doubted_times`)
VALUES (1032, ''异常对象都派生于哪个接口的实例'', ''A. Throwable\nB. Error\nC. Exception\nD. RuntimeException'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`,
                                   `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`,
                                   `right_times`, `doubted_times`)
VALUES (1033, ''以下类命名符合规范的是：'', ''A. marcoPolo\nB. XMLService\nC. info\nD. TaPromotion'', ''D'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`,
                                   `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`,
                                   `right_times`, `doubted_times`)
VALUES (1034, ''以下关于浮点数，正确用法为'', ''A.\nfor (float flt = (float) 2000000000; flt < 2000000050; flt++) {\n...\n}\nB.\n精确运算使用BigDecimal\nBigDecimal income = new BigDecimal(\"1.03\");\nBigDecimal expense = new BigDecimal(\"0.42\");\nSystem.out.println(income.subtract(expense));\nC.\npublic class NaNComparison {\npublic static void main(String[] args) {\ndouble num = 0.0d;\ndouble result = Math.cos(1 / num);\nif (result == Double.NaN) {\nSystem.out.println(\"result is NaN\");\n}\n}\n}\nD.\nLong sum = 0L;\nfor (long i = 0L; i < Integer.MAX_VALUE; i++) {\nsum += i;\n}'', ''B'', ''解析：\n规则4.1 不能用浮点数作为循环变量\n规则4.4 禁止尝试与NaN进行比较运算,相等操作使用Double或Float的isNaN方法\nD不涉及浮点数'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1035, ''以下说法不正确的是？'', ''A. Integer i1 = 10; Integer i2 = 10; i1和i2指向同一个对象\nB. 整数型包装类型应使用equals做相等的比较\nC. 基本类型优于包装类型\nD. 浮点型包装类型建议使用equals或flt.compareTo(another)==0做相等的比较'', ''D'', ''解析：\n错：不应使用，可以使用BigDecimal类型的equals方法或compareTo方法\n整数型包装类型应该使用equals方法做比较。浮点型包装类型不应用equals或者flt.compareTo(another)==0作相等的比较（compareTo(another)的大小比较可以）。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1036, ''以下代码正确的是'', ''A. short s = 1;s = s + 1;\nB.\nint big = 1999999999;\nfloat 1.0f;\nSystem.out.println(big * one);\nC.\nint ni = 6789;\ndouble d1 = ni / 30;\nD.\nlong nl = 4664382371590123456L;\ndouble d2 = (double) nl * 2;'', ''D'', ''解析：\nA错误，s = s + 1里面1是int，（s + 1）也是int，需要强转为short才能赋值给short\nB错误，float 1.0f; 语句有问题\nC错误，ni / 30里面ni是int，（ni / 30）也是int，会丢失小数点后面的数字\nD正确，建议4.3 明确地进行类型转换，不要依赖隐式类型转换 中的推荐例子'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1037, ''以下会使线程进入到阻塞状态的是'', ''A. wait\nB. sleep\nC. yield\nD. join'', ''ABD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1038, ''关于溢出描述正确的是'', ''A. java.lang.OutOfMemoryError: java heap space可能会导致所有用户线程暂停，不可以通过try/catch解决\nB. java.lang.StackOverflowError: 线程栈空间不足\nC. java.lang.OutOfMemoryError: PermGen space是指方法区（永久代）内存溢出'', ''ABC'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1039, ''下列操作线程安全的是\nprivate volatile int a;\nprivate AtomicInteger b = new AtomicInteger(1);\npublic void setA(int a) {\nthis.a = a;\n}\npublic void increaseA() {\nthis.a++;\n}\npublic int readA() {\nreturn a;\n}\npublic void setB(int b) {\nthis.b.set(b);\n}\npublic void increaseB(int b) {\nthis.b.set(this.b.get() + b);\n}\npublic int readB() {\nreturn b.get();\n}'', ''A. setA\nB. increaseA\nC. readA\nD. setB\nE. increaseB\nF. readB'', ''ACDF'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1040, ''属于java并发库的线程同步类'', ''A. Exchanger\nB. Semaphore\nC. CountDownLatch\nD. CyclicBarrier\nE. Phaser'', ''ABCDE'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1041, ''可能触发fullgc的条件'', ''A. MaxDirectMemeorySize写满\nB. 永生代（Perm）或Metaspace被写满\nC. 年老代（tenured）被写满\nD. 显示调用System.gc'', ''ABCD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1042, ''下面哪些是线程安全的'', ''A. LinkedList\nB. Vector\nC. Hashtable\nD. TreeMap\nE. TreeSet\nF. ConcurrentHashMap\nG. Stack'', ''BCFG'', ''解析：\n线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1043, ''以下说法正确的是'', ''A. 调用Thread.interrupt() 用于请求另外一个线程中止执行，而不是直接中止\nB. 推荐使用Thread.current().isInterrupted()，而不是Thread.interrupted()检查自己是否被interrupt\nC. 检测到当前线程被interrupt后，应抛出InterruptedException，并在finally或try-with-resource中清理执行状态\nD. 调用线程的interrupt方法，只有当线程走到了sleep, wait, join等阻塞这些方法的时候，才会抛出InterruptedException'', ''ACD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1044, ''不正确的Stream的用法'', ''A. long test = Stream.of(\"1\",\"2\").count()\nB. List testList = Stream.of(\"1\",\"2\").collect(Collectors.toList())\nC. IntStream t = IntStream.of(10,20,30);\nD. Stream.of(\"1\",\"2\").toSet()'', ''D'', ''解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1045, ''不属于启动安全管理器的是？'', ''A. 启动程序的时候通过附加参数启动安全管理器：-Djava.security.manager\nB. 若要同时指定配置文件 -Djava.security.manager -Djava.security.policy=\"E:/java.policy\"\nC. 编码方式启动 System.setSecurityManager(new SecurityManager());\nD. 编码方式启动 System.setProperty(\"java.security.manager\", xxx);'', ''D'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1047, ''以下代码输出什么\nComparator<Integer> df = new Comparator<Integer>() {\n@Override\npublic int compare(Integer o1, Integer o2) {\nreturn o1 > o2 ? 1 : (o1 == o2) ? 0 : -1;\n}\n};\nSystem.out.println(df.compare(new Integer(1), new Integer(1)));'', ''A. 0\nB. 1\nC. -1\nD. 运行时异常'', ''C'', ''解析：\no1 == o2比较的是否同一对象，即内存地址相同，故选-1'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1048, ''下面说法正确的'', ''A. volatile保证操作的修改可见性和原子性\nB. volatile和synchronized都可以使用在变量、方法和类级别的\nC. synchronized和ReentrantLock都是可重入锁\nD. synchronized适合一写多读场景'', ''C'', ''解析：\nA错，volatile保证线程可见性，无法保证复合操作的原子性\nB错，volatile只修饰变量'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1049, ''关于IO/NIO说法不正确的是'', ''A. IO是面向流的，NIO是面向缓存的\nB. IO是阻塞IO，NIO支持非阻塞IO\nC. IO值能顺序读取数据，NIO可以通过缓存区前后移动获取数据\nD. IO允许一个线程监听多个输入通道'', ''D'', ''解析：NIO允许一个线程监听多个输入通道'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1050, ''不属于NIO组件的是'', ''A. Buffer\nB. Channel\nC. Selectors\nD. Reader'', ''D'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1051, ''关于classloader，说法不正确的是'', ''A. 类加载机制就是从文件系统将一系列的class文件读入JVM内存中为后续程序运行提供资源的动作\nB. 类加载器的顺序为AppClassLoader、Extention ClassLoader、Bootstrap Classloder\nC. 类加载机制采用的双亲委派方式实现\nD. BootStrap ClassLoader负责加载JDK中的核心类库，如：rt.jar、resources.jar、charsets.jar'', ''B'', ''解析：\n顺序应该为Bootstrap CLassloder、Extention ClassLoader、AppClassLoader'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1052, ''不属于NIO Buffer中的属性变量'', ''A. capacity\nB. flag\nC. position\nD. limit'', ''B'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1053, ''以下代码输出什么\nArrayList<String> arrayList1 = new ArrayList<String>();\narrayList1.add(new String());\nArrayList<Object> arrayList2 = arrayList1;\nSystem.out.println(arrayList2.size());'', ''A. 1\nB. 0\nC. 编译错误\nD. 运行时异常'', ''C'', ''解析：\n数组是协变的，而集合不是协变的。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1054, ''高并发场景，推荐使用'', ''A. ConcurrentHashMap\nB. HashTable\nC. 有锁的HashMap\nD. TreeMap'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1055, ''main函数调用thread.setRunning(false)后，thread线程输出什么\nclass Scratch extends Thread {\nprivate boolean isRunning = true;\npublic boolean isRunning() {\nreturn isRunning;\n}\npublic void setRunning(boolean isRunning) {\nthis.isRunning = isRunning;\n}\n@Override\npublic void run() {\nSystem.out.println(\"begin\");\nwhile (isRunning) {\n}\nSystem.out.println(\"end\");\n}\n}\nclass Run {\npublic static void main(String[] args) {\ntry {\nScratch thread = new Scratch();\nthread.start();\nThread.sleep(1000);\nthread.setRunning(false);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\n}'', ''A. begin\nB. begin end\nC. 抛出异常'', ''A'', ''解析：\n因为isRunning不是volatile，导致线程里面的isRunning一直无法获取最新的值，所以一直处于死循环内部。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1056, ''在main函数中调用t.interrupt，t线程会怎么样\nclass Scratch extends Thread {\nprivate boolean stop = false;\npublic static void main(String[] args) throws InterruptedException {\nScratch t = new Scratch();\nt.start();\nThread.sleep(3000);\nt.interrupt();\nThread.sleep(3000);\nSystem.out.println(\"exit\");\n}\n@Override\npublic void run(){\nwhile(!stop){\nSystem.out.println(\"running\");\n}\nSystem.out.println(\"stop\");\n}\n}'', ''A. 一直打印running\nB. 打印running后线程退出\nC. 打印running、stop线程退出'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1057, ''以下代码输出什么\nString str = \"abc@x.y+com\";\nString str1 = \"ab_c@x.y.com\";\nString regex = \"^[a-zA-Z0-9.-_]+@([a-zA-Z0-9]+.)+com$\";\nSystem.out.println(str.matches(regex));\nSystem.out.println(str1.matches(regex));'', ''A. true true\nB. true false\nC. false true\nD. false false'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1058, ''以下代码输出什么\nList<String> stringArrayList = new ArrayList<String>();\nList<Integer> integerArrayList = new ArrayList<Integer>();\nSystem.out.println(stringArrayList.getClass().equals(integerArrayList.getClass()));'', ''A. true\nB. false\nC. 编译错误\nD. 运行时异常'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1059, ''以下代码输出什么\nList arrayList = new ArrayList();\narrayList.add(\"aaaa\");\narrayList.add(100);\nSystem.out.println((String)arrayList.get(1));'', ''A. 100\nB. 编译错误\nC. 运行异常\nD. aaaa'', ''C'', ''解析：\njava.lang.Integer cannot be cast to java.lang.String'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1060, ''以下代码执行两遍，文件text.txt中的内容为\nFileOutputStream outputStream = new FileOutputStream(\"test.txt\",true);\noutputStream.write(\"ABCDE\".getBytes(StandardCharsets.UTF_8));\noutputStream.close();'', ''A. ABCDE\nB. ABCDEABCDE\nC. 什么都没有\nD. EDCBAEDCBA'', ''B'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1061, ''以下代码输出什么？\nList<String> string = new ArrayList<String>();\nstring.add(\"hello\");\nstring.add(2, \"ok\");\nSystem.out.println(string.get(1));'', ''A. \"hello\"\nB. \"ok\"\nC. 编译错误\nD. 运行时异常'', ''D'', ''解析：\njava.lang.IndexOutOfBoundsException: Index: 2, Size: 1'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1062, ''在64位虚拟机，如下数据类型中，长度不是4字节的类型有哪些'', ''A. char\nB. int\nC. long\nD. short'', ''ACD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1063, ''如下类型，哪些是值不可变类型'', ''A. char\nB. Integer\nC. String\nD. short'', ''BC'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1064, ''SocketChannel可以向Selector注册哪些事件'', ''A. SelectionKey.OP_ACCEPT\nB. SelectionKey.OP_CONNECT\nC. SelectionKey.OP_WRITE\nD. SelectionKey.OP_READ'', ''BCD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1065, ''Java反射机制的作用包括'', ''A. 在运行时判断任意一个对象所属的类。\nB. 在运行时构造任意一个类的对象。\nC. 在运行时判断任意一个类所具有的成员变量和方法。\nD. 在运行时调用任意一个对象的方法。'', ''ABCD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1066, ''关于集合，以下说法正确的是'', ''A. HashMap使用的是数组+链表（或红黑树）的方式，查找key时，先判断key的equals是否相等，相等时再判断hashCode是否一致\nB. HashMap和HashSet的默认值大小为16，HashTable的默认值大小为11\nC. LinkedHashMap保持插入的顺序，TreeMap保持key的自然顺序\nD. Collection的直接子类包含Set、List、Map和Queue'', ''BC'', ''解析：\nA错，先判断hashCode是否一致，再判断key的equals是否相等\nD错，Collection的直接子类包含List、Set和Queue，不包括Map'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1067, ''下面哪个不是Class类中定义的反射方法'', ''A. getDeclaredFields\nB. getDeclaredNames\nC. getDeclaredMethods\nD. getDeclaredConstructors'', ''B'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1068, ''以下程序输出什么\nint i = 9;\nswitch (i) {\ndefault:\nSystem.out.println(\"default\");\ncase 0:\nSystem.out.println(\"zero\");\nbreak;\ncase 1:\nSystem.out.println(\"one\");\ncase 2:\nSystem.out.println(\"two\");\n}'', ''A. default\nB. default, zero\nC. 什么都不输出\nD. 编译错误'', ''B'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1069, ''以下说法不正确的是'', ''A. 类单继承，接口可以多继承\nB. 抽象类中的抽象方法只能声明，不能实现\nC. 抽象类中不能包含非抽象方法\nD. 接口的方法可以有方法体，但必须加default或static关键字'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1070, ''以下程序运行结果为\nclass Parent{\nstatic {\nSystem.out.println(\"Parent static body\");\n}\n{\nSystem.out.println(\"Parent non-static body\");\n}\nParent(){\nSystem.out.println(\"Parent()\");\n}\n}\npublic class Order extends Parent {\nstatic {\nSystem.out.println(\"static body\");\n}\n{\nSystem.out.println(\"non-static body\");\n}\nOrder (){\nSystem.out.println(\"Order()\");\n}\npublic static void main(String[] args){\nOrder order = new Order ();\n}\n}'', ''A.\nParent static body\nstatic body\nParent non-static body\nParent()\nnon-static body\nOrder()\nB.\nParent static body\nstatic body\nParent non-static body\nnon-static body\nParent()\nOrder()\nC.\nParent static body\nParent non-static body\nParent()\nstatic body\nnon-static body\nOrder()\nD.\nParent static body\nParent non-static body\nstatic body\nnon-static body\nParent()\nOrder()'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1071, ''以下遍历list，推荐使用的是'', ''A.\nfor(int i = 0; i < list.size(); i++){\n}\nB.\nfor(A a : list){\n}\nC.\nfor(Iterator<A> iter = list.iterator(); iter.hasNext(); ){\n}'', ''B'', ''解析：\n对于数组类型的数据遍历，选项A的普通for循环比选项B的增强型for循环性能略占优势，但对于链表类型的数据遍历，普通for循环比增强型for循环性能要差很多，数据量大时，普通for循环会出现卡死甚至导致系统崩溃，且增强型for循环在代码阅读上更简洁，因此建议增强型for循环。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1072, ''关于异常以下说法不正确的是'', ''A. throws出现在方法函数头，throw出现在函数体\nB. 受检异常在编译层面会进行检查，如果调用一个抛出受检异常的函数，必须进行try-catch处理异常或在函数签名申明throws此异常，否则编译失败\nC. 并语法(ExceptionType|...|ExceptionType变量），子类异常必须在父类异常之前\nD. 通过多个catch捕获异常，子类异常必须在父类异常之前'', ''C'', ''解析：\njava语法中的异常捕获子类异常与父类异常的顺序没有强制要求'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1073, ''下面描述错误的是：'', ''A. HashMap不允许null值(key和value都不可以)，而Hashtable允许将null作为一个entry的key或者value\nB. Hashtable是线程安全的，也就是说是同步的，HashMap线程不安全的，不是同步的\nC. Hashtable和HashMap都实现了Map接口\nD. ConcurrentHashMap不可存放key，value值都为null的数据'', ''A'', ''解析：\nHashMap的key和value都允许null值。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1074, ''以下代码返回值为\nclass Point {\nprivate int x;\npublic static void main(String[] args) {\nSystem.out.println(test1().x);\nSystem.out.println(test2());\nSystem.out.println(test3());\n}\npublic static Point test1(){\nPoint p = new Point();\ntry{\np.x = 20;\nreturn p;\n}\nfinally{\np.x =30;\n}\n}\npublic static int test2(){\nint a =100;\ntry{\na = 200;\nreturn a;\n}\nfinally{\na = 300;\n}\n}\npublic static int test3(){\nint a =100;\ntry{\na = 200;\nreturn a;\n}\nfinally{\na = 300;\nreturn a;\n}\n}\n}'', ''A. 30 200 200\nB. 20 200 300\nC. 30 200 300\nD. 20 300 200'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1075, ''以下代码输出？\nint[] a = {100, 101, 102};\nOUTER:\nfor (int i = 0; i < 3; i++) {\nfor (int j = 0; j < a.length; j++) {\nif (j == 1) {\ncontinue OUTER;\n} else {\nSystem.out.println(\''A\'');\n}\n}\nSystem.out.println(\''B\'');\n}\nSystem.out.println(\''C\'');'', ''A. 一个A，一个B，一个C\nB. 一个A，一个C\nC. 三个A，一个C\nD. 三个A，三个B，一个C'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1076, ''以下代码输出什么\nMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>(16,0.75f,true){\n@Override\nprotected boolean removeEldestEntry(Map.Entry eldest){\nreturn size() > 5;\n}\n};\nfor(int i = 0; i < 10; i++){\nmap.put(i,i);\n}\nmap.get(6);\nSystem.out.println(map.keySet());'', ''A. [5,6,7,8,9]\nB. [9,8,7,6,5]\nC. [5,7,8,9,6]\nD. [6,5,7,8,9]'', ''C'', ''解析：\nhttp://3ms.huawei.com/hi/newask/question/354692020528222208/?hi3msSite=tech'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1077, ''以下代码输出\nString strTest1 = \"abc\";\nString strTest2 = new String(\"abc\");\nSystem.out.println(strTest1 == strTest2);\nSystem.out.println(strTest1.equals(strTest2));\nSystem.out.println(strTest1 == strTest2.intern());\nSystem.out.println(strTest1 == \"abc\");\nSystem.out.println(strTest2 == \"abc\");'', ''A. true false true true true\nB. false true true true false\nC. true false false true true\nD. false true false true false'', ''B'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1078, ''以下代码调用值发生改变的是'', ''A.\nvoid foo(int value) {\nvalue = 100;\n}\nfoo(num);\nB.\nvoid foo(String text) {\ntext = \"windows\";\n}\nfoo(str);\nC.\nStringBuilder sb = new StringBuilder(\"iphone\");\nvoid foo(StringBuilder builder) {\nbuilder.append(\"4\");\n}\nfoo(sb);\nD.\nStringBuilder sb = new StringBuilder(\"iphone\");\nvoid foo(StringBuilder builder) {\nbuilder = new StringBuilder(\"ipad\");\n}\nfoo(sb);'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1079, ''以下代码输出什么\n@Data\nclass Scratch implements Cloneable {\nString name;\nList<String> objList;\npublic Object clone(){\nObject obj = null;\ntry{\nobj = super.clone();\n}catch(CloneNotSupportedException ex){\nex.printStackTrace();\n}\nreturn obj;\n}\npublic static void main(String[] args) {\nScratch copy = new Scratch();\nList<String> objList = new LinkedList<>();\nobjList.add(\"abc\");\ncopy.setObjList(objList);\ncopy.setName(\"name1\");\nScratch copy2 = (Scratch) copy.clone();\ncopy2.getObjList().add(\"ddd\");\ncopy2.setName(\"name2\");\nSystem.out.println(copy.getName() + \" \" + copy2.getName());\nSystem.out.println(copy.getObjList().size() + \" \" +\ncopy2.getObjList().size());\n}\n}'', ''A. name1 name2\n1 2\nB. name1 name2\n2 2\nC. name2 name2\n2 2\nD. name1 name2\n1 1'', ''B'', ''解析：\n该类实现了Cloneable接口，重写了clone方法，在方法中调用了父类的clone，也就是调用了Object中的clone方法。Object中本地clone()方法，默认是浅拷贝，本代码中，调用clone重新拷贝了一个新对象copy2，浅拷贝是对引用数据类型进行引用传递的拷贝，所以copy1和copy2不相等，但是copy1.objList和copy2.objList指向的其实是一个引用。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1080, ''在执行JDBC查询数据库时，假设物理内存足够用，如果查询结果集ResultSet要返回的记录数很多，比如上百万记录，则下列选项中对ResultSet的fetchsize属性描述正确的是：'', ''A. ResultSet的fetchSize越大，数据库服务端消耗的内存越小，性能也越快\nB. ResultSet的fetchSize越大，数据库服务端消耗的内存越大，性能也越快\nC. ResultSet的fetchSize越大，JDBC client端消耗的内存越大，性能也越快\nD. ResultSet的fetchSize越大，JDBC client端消耗的内存越小，性能也越快'', ''C'', ''解析：\nhttp://3ms.huawei.com/km/blogs/details/8054017'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1081, ''以下说法正确的是'', ''A. 文件路径校验前必须先进行标准化处理，建议使用getAbsolutePath()\nB. 未对程序输入做有效的校验与限制可能会导致zip炸弹攻击、SQL注入、OS命令注入、XML注入以及目录遍历等攻击\nC. 数值运算，建议使用先决条件检查、Math.*Exact()方法、向上类型转换等方式防止溢出\nD. 建议通过System.exit()函数来终止运行的程序和线程'', ''BC'', ''解析：\nA：不正确，AbsolutePath中可能存在软链接，应使用getCanonicalPath()\nB：正确，大部分此类攻击可以通过校验限制防御\nC：正确，参见安全编码规范建议 3.1 进行数值运算，避免整数溢出，这三种方法都是防止溢出的方法。\nD：不正确，参见安全编码规范建议4.1 不要调用System.exit()终止JVM，调用System.exit()会终止Java虚拟机(JVM)，从而终止所有运行中的程序和线程。这样会导致拒绝服务攻击。例如，嵌入在jsp页面中的System.exit()调用会终止网络服务器，导致拒绝服务攻击。程序必须避免无意和恶意的调用System.exit()。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1082, ''当直接将外部输入作为参数传递给java.lang.Runtime.exec()方法的时候易引入下列哪些攻击类型的漏洞'', ''A. SQL注入\nB. XML注入\nC. 命令注入\nD. 参数注入攻击'', ''CD'', ''解析：\nexec()方法为系统命令调用，一般不会有SQL注入和XML注入。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1086, ''关于NullPointException异常，说法正确的是'', ''A. NullPointException是运行时异常，不建议捕获，应该在代码中解决\nB. 捕获NullPointException而不是进行简单的空引用检查，在性能上付出相当大的代价\nC. 捕获NullPointException异常而不对根本原因进行处理是不合适的\nD. 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理'', ''ABCD'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1087, ''下列代码示例中定义的锁对象，能正确保证线程同步的是：\n①private final Boolean lock = Boolean.FALSE;\npublic void doSomething() {\nsynchronized(lock) {\n// ...\n}\n}\n②private int count = 0;\nprivate final Integer lock = count; //Boxed primitive Lock is shared\npublic void doSomething() {\nsynchronized(lock) {\ncount++;\n// ...\n}\n}\n③private int count = 0;\nprivate final Integer lock = new Integer(count);\npublic void doSomething() {\nsynchronized(lock) {\ncount++;\n// ...\n}\n}\n④// This bug was found in jetty-6.1.3 BoundedThreadPool\nprivate final String lock = \"LOCK\";\npublic void doSomething() {\nsynchronized(lock) {\n// ...\n}\n}'', ''A. ①\nB. ④\nC. ③\nD. ②'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1088, ''下面关于排版说法正确的有哪些'', ''A. 避免文件过长，不超过2000行\nB. 一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔\nC. import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组\nD. 对于if、while、for等语句，左大括号放在行首'', ''ABC'', ''解析：参考《华为Java编程规范》\n规则3.4 对于非空和块状结构，左大括号放在行尾\n规则3.1 避免文件过长，不超过2000行（非空非注释行）\n规则3.2 一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔\n建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1089, ''64位虚拟机中，长度不是4字节的类型有哪些？'', ''A. char\nB. int\nC. long\nD. short'', ''ACD'', ''解析：\nchar：一个字节\nshort：两个字节\nint：四个字节\nlong：32位虚拟机，四个字节；64位虚拟机，八个字节'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1090, ''interface中声明的变量默认具有的修饰符是'', ''A. public\nB. public static\nC. public final\nD. public static final'', ''D'', ''解析：\n成员变量的默认修饰符为：public static final'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1091, ''下列关于集合初始化描述错误的是'', ''A. ArrayList的默认长度值16\nB. HashMap的默认长度值16\nC. HashSet的默认长度值16\nD. StringBuﬀer的默认长度值16'', ''A'', ''解析：ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked\n默认Integer.MAX_VALUE)'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1092, ''如果信号量（Semaphore）的初始值是2，经过多次wait和signal操作后，信号量的值变为-2，则当前系统处于临界区的进程数和等待进入临界区的进程数是？'', ''A. 2,2\nB. 2,3\nC. 3,3\nD. 1,2'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1093, ''在使用UDP套接字通信时，通常使用（）类把要发送的信息打包'', ''A. DatagramPacket\nB. DatagramSocket\nC. String\nD. MulticastSocket'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1094, ''以下使用的断言语句中哪些有副作用'', ''A. assert names.isEmpty();\nB. assert names.remove(null);\nC. assert names.add(null);\nD. Boolean nullsRemoved = names.remove(null);\nAssert nullsRemoved'', ''BC'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1095, ''一个栈的入栈序列为ABCDEF，则不可能的出栈序列是'', ''A. DEFCBA\nB. DCEFBA\nC. FEDCBA\nD. FECDBA\nE. ABCDEF\nF. ADCBFE'', ''D'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1096, ''如果入栈序列为1,2,3,4,5，则可能得到的出栈序列为'', ''A. 1,2,5,3,4\nB. 3,1,2,5,4\nC. 3,2,5,4,1\nD. 1,4,2,3,5\nE. 都不可能'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1097, ''以下代码输出\npublic static void main(String[] args) {\ntry {\nSystem.out.println(\"aa:\" + func());\n} catch (Exception e) {\ne.printStackTrace();\n}\n}\npublic static int func() throws Exception {\nfor (int i = 1; i < 2; i++) {\ntry {\nthrow new Exception(\"bb\");\n} catch (Exception ex) {\nthrow ex;\n} finally {\ncontinue;\n}\n}\nreturn 0;\n}'', ''A. aa:0\nB. 抛出异常\nC. 编译错误\nD. 既打印aa:0同时抛出异常'', ''A'', ''解析：\n《华为Java语言通用编程规范-V4.6.pdf》规则7.3\n在finally块中不要使用return、break或continue使finally块非正常结束'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1098, ''以下代码正确的是：'', ''A.\nString[] arr = new String[]{\"1\", \"2\", \"3\", \"4\", \"5\"};\nList<String> list = Arrays.asList(arr);\nlist.remove(\"5\");\nlist.add(\"6\");\nB.\nMap<String, String> map = new HashMap<>();\nmap.put(\"1\", \"a\");\nmap.put(\"2\", \"b\");\nList<String> list = new ArrayList<>();\nlist.addAll(map.values());\nlist.addAll(Collections.singleton(\"c\"));\nC.\nList<String> list = Collections.emptyList();\nlist.add(\"1\");\nD.\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nArrayList<String> subList = (ArrayList<String>) list.subList(0, 0);'', ''B'', ''解析：\nA：Exception in thread \"main\" java.lang.UnsupportedOperationException\nC：Exception in thread \"main\" java.lang.UnsupportedOperationException\nD：Exception in thread \"main\" java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1099, ''将list转换为数组时最佳SIZE\nList<String> list = new ArrayList<>(DEFAULT_CAPACITY);\nlist.add(\"1\");\nlist.add(\"2\");\nString[] array = list.toArray(new String[SIZE]);'', ''A. 0\nB. 1\nC. 2\nD. 3'', ''A'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1100, ''以下声明，建议使用的是'', ''A. 泛型数组：private final T[] someArray;\nB. 协变化的数组：private final Object[] objArray;\nC. 泛型列表：private final List lists;'', ''C'', NULL, ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1101, ''关于序列化不正确的是'', ''A. 序列化对象中的HashMap、HashSet或HashTable等集合不能包含对象自身的引用\nB. 建议除非必须使用的第三方接口要求必须实现Serializable接口，否则请选用其它方式代替\nC. 实现Serializable接口的可序列化类建议使用默认的serialVersionUID\nD. 系统资源的句柄，建议实现Serializable的类，其字段为File或FileDescriptor时，用transient修饰。'', ''C'', ''解析：\n强烈建议所有可序列化类都显式声明 serialVersionUID 值，原因计算默认的 serialVersionUID对类的详细信息具有较高的敏感性，根据编译器实现的不同可能千差万别，这样在反序列化过程中可能会导致意外的InvalidClassException。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''SINGLE_CHOICE'', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1102, ''关于可变参数说法正确的是'', ''A. 可以接受指定类型的1个到多个参数\nB. 不建议使用varargs重写使用一个固定长度数组作为参数的方法\nC. JDK1.5引入Varargs（variable number of arguments）可变数量参数，应该在确实需要操作可变长度的值的序列时使用\nD. 可变参数必须位于最后一项'', ''BCD'', ''解析：\n可变参数可接收零至多个参数，但不建议使用可变参数，且必须位于最后一项。'', ''科目二来着熊绒的博客'', NULL, ''科目2'', ''MULTI_CHOICE'', 1, 1, 0, 0, 0, 0);
