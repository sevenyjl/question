INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1177, '将含敏感数据的对象跨信任域传递前应该', 'A. 先签名再加密后传输\nB. 加密传输\nC. 先加密再签名后传输\nD. 签名传输', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1178, '对于下面的代码片段，假设PasswordManager的实例可以被非信任代码所访问，且changePassword()方法调用属于敏感操作，则下列说法中不正确的是：\npublic class PasswordManager\n{\npublic final Object lock = new Object();\npublic void changePassport() throws FileNotFoundException\n{\nsynchronized(lock)\n{\n// ...\n}\n}\n}', 'A. 可以省去changePasword()方法中的同步块，直接将changePasword()方法声明为synchronized修饰的同步方法\nB. changePassport()方法中应该包含安全管理器检查，以确认调用代码是否具有该操作权限\nC. 将该lock成员变量的可见性声明为private\nD. changePassport()方法不应该抛出FileNotFoundException异常', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1179, '若程序中需要获取操作系统登录用户名，应采取下列哪种方法来获取：', 'A. 提示用户输入\nB. 由环境变量获取:System.getenv(\"USER\")\nC. 由JVM属性获取:System.getProperty(\"user.name\")\nD. 启动程序的时候由程序参数传入', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1181, '下列有关Map的操作错误的是：', 'A.\nMap<Integer, String> cityMap = new HashMap<>() {\n{\nput(1, \"Nanjing\");\nput(2, \"Beijing\");\nput(3, \"Shanghai\");\n}\n}\nB.\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\nSystem.out.println(city.getValue());\n}\nC.\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4, null);\nD.\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1182, '有关泛型，下面说法错误的是：', 'A. extends约束类型上限，如public int add(T n1, T n2); 表示方法参数必须是Number的子类型\nB. List numList = new ArrayList();\nList intList = new ArrayList();\n因为Integer是Number的子类，所以intList可以赋值给numberList\nC. 对于同一个类，可以使用不同的泛型参数类型声明类型和方法\nD. 泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考，当实例化时，使用具体的类型替代，这是实参', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1183, '下面的程序创建了一个文件输出流对象，用来向文件test.txt中输出数据。假设程序当前运行目录下不存在文件test.txt，编译后执行三次结果为\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\npublic class Test {\npublic static void main(String[] args) {\ntry {\nString str = \"ABCDE\";\nbyte[] bs = str.getBytes(StandardCharsets.UTF_8);\nFileOutputStream file = new FileOutputStream(\"test.txt\", true);\nfile.write(bs);\nfile.close();\n} catch (IOException e) {\nSystem.out.println(e.toString());\n}\n}\n}', 'A. ABCABC\nB. Test\nC. ABCDEABCDEABCDE\nD. ABCDE', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1184, 'Java中如何释放掉一个指定占据的内存空间', 'A. 程序员无法明确强制垃圾回收器运行\nB. 调用free()方法\nC. 赋值给该对象的引用为null\nD. 调用System.gc()方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1185, '以下描述错误的是', 'A.\npublic String getProductSummary(int index) {\nreturn products[index];\n}\n//该代码中index未校验，可能相起数组越界访问\nB.\nString userName = \"name\";\nResultSet rs = st.executeQuery(\"select * from user where name = \'\" + userName + \"\'\");\n//该代码可能会产生SQL注入漏洞\nC.\nRuntime.getRuntime().exec(\"cmd.exe /c dir \" + args[0]);\n//该代码可能会引起命令注入\nD.\nString command = System.getProPerty(\"command\");\nRuntime.getRuntime().exec(\"command\");\n//该代码可能会引起OS命令注入', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1186, '关于异常的说法错误的是', 'A. BindException异常泄露时可能造成开放端口列举\nB. 当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤\nC. FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构\nD. 可以在代码最外层捕获NullPointException防止代码出现预期之外的行为', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1187, '下面关于异常处理描述错误的是', 'A. FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常\nB. 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理\nC. 输入校验是一个常用的防止通过异常泄露敏感信息的方式\nD. 必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1188, 'Java IO Buffer状态变量不包括', 'A. capacity：最大容量\nB. flag：读写状态位\nC. position：当前已经读到的字节数\nD. limit：剩下的字节数', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1189, '关于sleep()和wait()，以下描述错误的是', 'A. sleep不释放对象锁，wait放弃对象锁\nB. sleep暂停线程，但监控状态仍然保持，结束后会自动恢复\nC. wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态\nD. sleep是线程类（Thread）的方法，wait是Object类的方法', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1190, 'Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流', 'A. 错误流\nB. 监控流\nC. 输出流\nD. 输入流', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1191, '下列单例实现正确的是', 'A.\npublic final class Helper {\npublic Helper() { }\n}\nfinal class Foo {\nprivate Helper helper = null;\npublic Helper getHelper() {\nif (helper == null) {\nsynchronized (this) {\nif (helper == null) {\nhelper = new Helper();\n}\n}\n}\nreturn helper;\n}\n}\nB.\npublic final class Helper {\nprivate final int n;\npublic Helper(int n) {\nthis.n = n;\n}\n}\nfinal class Foo {\nprivate Helper helper = null;\npublic Helper getHelper() {\nHelper h = helper;\nif (h == null) {\nsynchronized (this) {\nh = helper;\nif (h == null) {\nh = new Helper(42);\nhelper = h;\n}\n}\n}\nreturn h;\n}\n}\nC.\npublic final class Helper {\nprivate final int n;\npublic Helper(int n) {\nthis.n = n;\n}\n}\nfinal class Foo {\nprivate Helper helper = null;\npublic Helper getHelper() {\nif (helper == null) {\nsynchronized (this) {\nif (helper == null) {\nhelper = new Helper(42);\n}\n}\n}\nreturn helper;\n}\n}\nD.\npublic final class Helper {\npublic Helper() {}\n}\nfinal class Foo {\nprivate static class Holder {\nstatic Helper helper = new Helper();\n}\npublic Helper getInstance() {\nreturn Holder.helper;\n}\n}', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1192, '有关线程池关闭，以下说法正确的有', 'A. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，直到线程池中等待的任务全部处理完\nB. 执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出\nC. 执行shutdown方法后，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出\nD. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池试图停止所有正在执行的线程，不再处理池中等待的任务', 'CD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1193, '下列哪些是线程同步的？', 'A. TreeSet\nB. HashTable\nC. Vector\nD. LinkedList', 'BC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1194, '已知如下代码\npublic static void main(String[] args) {\nint nr = 5;\ndo {\nSystem.out.print(nr);\n} while (--nr > 5);\nSystem.out.print(\"finished\");\n}\n执行后的输出包含什么？', 'A. 5\nB. 4\nC. finished\nD. 6', 'AC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1196, '关于数据校验的说法正确的是', 'A. 在对不可信数据进行校验时，禁止使用assert语句\nB. \"白名单\"净化的方式包括删除，编码，替换\nC. \"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新，该校验方式就会很快过时\nD. 尽可能使用接收一直合法数据的白名单策略', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1197, '仅保存口令hash，不加盐的缺陷有', 'A. 攻击者可以使用事先计算好的哈希列表在几秒钟之内破解口令\nB. 加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加\nC. 没有盐值，攻击者可以根据哈希值反向解密出原始口令\nD. 由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1198, '关于异常，下列说法正确的是：', 'A. 如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码\nB. 方法抛出的异常，应该与本身的抽象层次相对应\nC. 对可容错处理的情况使用受检异常，对编程错误使用运行时异常\nD. 一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中记录每个抛出的异常及其条件', 'BCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1199, '如下四种数组声明方式，哪种不正确？', 'A. int[] hello1 = {1, 2, 3, 4};\nB. int[] hello2 = new int[4]{1, 2, 3, 4};\nC. int[] hello3 = new int[]{1, 2, 3, 4};\nD. int[] hello4 = new int[4];', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1200, 'Java语言中，下面哪个语句是创建数组的正确语句？', 'A. float f[][] = new float[6][6];\nB. float []f[] = new float[6][6];\nC. float f[][] = new float[][6];\nD. float[][] f = new float[6][6];\nE. float[][] f = new float[6][];', 'DE', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1201, '哪些数据类型能直接输出？', 'A. int[] test = {1, 2, 3, 4, 5};\nB. List list = new LinkedList<>();\nC. Map<Integer, Integer> map = new HashMap<>();\nD. List list = new ArrayList<>();', 'BCD', '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1202, '与表达式Integer a = 2;等价的类型是哪个？', 'A. int b = Integer.parseInt(\"2\");\nB. Integer b = Integer.valueOf(\"2\");', 'B', '解析：\nInteger.valueOf(value)在-128~127间，则会重用内存中缓存的对象', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1203, '哪些语句在编译时不会出现编译警告', 'A. float f = 1.3;\nB. byte b = 257;\nC. boolean b = null;\nD. int i = 10;', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1204, '有一个模拟赛跑游戏，运动员有跑得快的也有跑得慢的，运动员听到枪声后开始起跑，而最后一个运动员到达终点后，标志着比赛的结束。当前场景下，适合采用哪种线程同步机制?', 'A. CountDownLatch\nB. CyclicBarrier\nC. Semaphore\nD. BlockingQueue', 'A', '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1205, '20个人去银行存款，但是该银行只有两个办公柜台，有空位则上去存钱，没有空位则只能去排队等待，适合采用哪种线程同步机制', 'A. Semaphore信号量\nB. CountDownLatch\nC. CyclicBarrier\nD. BlockingQueue', 'A', '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1206, '下列哪种情况可以终止当前线程的运行？', 'A. 当一个优先级高的线程进入就绪状态时\nB. 当该线程调用sleep()方法时\nC. 当创建一个新线程时\nD. 抛出一个异常时', 'D', '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1207, '以下NIO语句是否有错误？', 'A. 大二进制文件读入\nB. 小二进制文件读入\nC. 小文本按行读入\nD. 小文本按字节数读入\nE. 结尾插入数据采用.APPEND而不是.CREATE', 'E', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1208, '下面字段声明中哪一个在interface主体内是合法的?', 'A. private final static int answer = 42;\nB. public static int answer = 42;\nC. final static answer = 42;\nD. int answer;', 'B', '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1210, '如下描述错误的是：', 'A. StackOverflowError是堆栈内存溢出\nB. OutOfMemoryError：Perm Gen是老年代内存溢出\nC. Java Heap Space溢出时，会导致所有线程暂停工作', 'B', '解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);

INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1211, '107. 按照编程规范，下列哪些信息时禁止输入到日志中的', 'A．事件发生的时间、事件类型\nB．密钥\nC．明文口令\nD．密文口令', 'BCD', '', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (1212, '108. 有关类加载器的双亲委派模型说法错误的是', 'A. 类加载器之间是有层次结构的\nB. 加载不到类，会抛出ClassNotFoundException();\nC. 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\nD. 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载', 'C', '', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (922, '针对DT FUZZ测试，下面的说法正确的是？', 'A. DT FUZZ测试中，如果被测函数代码有修改，但被测函数被调用逻辑没有修改，不需要修改测试用例\n\n \n\nB. 尽量选择模块外层函数为被测目标，编写测试用例，测试过程中，本模块内部函数可以随意打桩\n\n \n\nC. DT FUZZ测试，编写测试用例可以不考虑函数的调用上下文\n\n \n\nD. 结构化的参数DT FUZZ工具都可以构造', 'A', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (923, '当线程调用start后，其所处的状态是 ', 'A. 新建\n\n \n\nB. 阻塞\n\n \n\nC. 运行\n\n \n\nD. 就绪\n', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (924, '下面对Java反序列化的描述正确的是：', 'A. jdk提供的序列化操作，会将Java对象序列化二进制流，可以有效防止信息泄露或恶意篡改\n\n \n\nB. Java的反序列化操作，可以绕过对象构造函数的执行\n\n \n\nC. 对象序列化后，即使包含敏感数据也不会产生风险\n\n \n\nD. Java反序列化时，目标class与预期class不一致时，会导致类型转换错误，所以即使反序列化不可信数据也不会有安全风险', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (925, '下列哪项危害不是，不正确的构造正则可能会导致的安全风险', 'A. CSRF\n\n \n\nB. 敏感信息泄露\n\n \n\nC. ReDos攻击\n\n \n\nD. 正则注入', 'A', 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (926, '下面对敏感数据记录日志，描述正确的是', 'A. 做好日志访问权限控制，日志可以记录敏感信息\n\n \n\nB. 敏感信息记录日志时，直接将信息内容替换等长的*即可\n\n \n\nC. 日志中如果必须记录敏感信息，需要使用长度固定的*替代\n\n \n\nD. 敏感信息加密后可以记录日志', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (927, '常见的xml实体解析导致的安全风险有那几种？', 'A. xPath注入\n\n \n\nB. XXE\n\n \n\nC. 内部实体扩展\n\n \n\nD. xml注入', 'BC', '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (928, '下面对命令注入的防护措施中，无效的是', 'A. 避免使用shell方式执行命令，直接启动具体的进程\n\n \n\nB. 代码避免使用外部输入拼接命令行，代码中对命令进行硬编码\n\n \n\nC. 对于使用外部输入构造的命令行，在执行前进行转码处理\n\n \n\nD. 外部输入进行白名单校验，禁止使用&|>;等特殊字符', 'C', '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (929, '下列生成随机数最安全的方法为', 'A. java.util.Random()\n\n \n\nB. Math.random()\n\n \n\nC. java.util.concurrent.ThreadLocalRandom()\n\n \n\nD. java.Security.SecureRandom()', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (930, '对于不安全反序列化漏洞的防护描述错误的是：', 'A. XMLDecoder是jdk原生类，提供了xml的反序列化操作，所以相对Xstream，更推荐使用XMLDecoder进行xml数据的反序列化操作\n\n \n\nB. 使用jdk原生api进行反序列化操作，涉及不可信数据时，可以重载ObjectInputStream的resolveClass()方法，在该方法中对目标class进行白名单校验\n\n \n\nC. 对不可信的XML数据进行反序列化操作，推荐使用XStream实现，该组件支持白名单检查，新版本也提供了默认安全校验机制\n\n \n\nD. 对不可信的json数据进行反序列化操作，可通过禁止开启type功能进行防护\n\n ', 'A', 'java原生的XMLDecoder类常被用来序列化反序列化XML格式数据，但是这个类也存在严重安全问题，这里解析任意xml文件可以导致反序列化命令执行，oracle官方未提供任何针对此问题的安全措施，所以在反序列化不可信xml数据时，强烈建议不要使用此类。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (931, '以下哪些程序示例是正确的？\n①public class OuterSer implements Serializable {\n    private int rank;\n    class InnerSer implements Serializable {\n        protected String name;\n        // ...\n    }\n}\n\n②public class OuterSer implements Serializable {\n    private int rank;\n    class InnerSer {\n        protected String name;\n        // ...\n    }\n}\n\n③public class OuterSer implements Serializable {\n    private int rank;\n    static class InnerSer implements Serializable {\n        protected String name;\n        // ...\n    }\n}', 'A. ③\n\nB. ②\n\nC. ①\n', 'AB', '规则7.5 禁止序列化非静态的内部类', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (932, '下列哪些方法的返回Buffer对象暴露给不受信任的代码，存在原始数据被恶意修改的风险', 'A. CharBuffer.asReadOnlyBuffer();\n\n \n\nB. CharBuffer.duplicate();\n\n \n\nC. CharBuffer.subSequence();\n\n \n\nD. CharBuffer.wrap();', 'BCD', 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
UPDATE question  SET title='对于不安全反序列化漏洞的防护描述错误的是：',options='A. XMLDecoder是jdk原生类，提供了xml的反序列化操作，所以相对Xstream，更推荐使用XMLDecoder进行xml数据的反序列化操作\n\n \n\nB. 使用jdk原生api进行反序列化操作，涉及不可信数据时，可以重载ObjectInputStream的resolveClass()方法，在该方法中对目标class进行白名单校验\n\n \n\nC. 对不可信的XML数据进行反序列化操作，推荐使用XStream实现，该组件支持白名单检查，新版本也提供了默认安全校验机制\n\n \n\nD. 对不可信的json数据进行反序列化操作，可通过禁止开启type功能进行防护\n\n ',answer='A',parsing='java原生的XMLDecoder类常被用来序列化反序列化XML格式数据，但是这个类也存在严重安全问题，这里解析任意xml文件可以导致反序列化命令执行，oracle官方未提供任何针对此问题的安全措施，所以在反序列化不可信xml数据时，强烈建议不要使用此类。',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0,error_times=0,right_times=0,doubted_times=0  WHERE id=930;
UPDATE `question`.`question` SET `title` = '禁止采用如下哪些算法进行口令加密？\n\n', `options` = 'A. RSA\n\nB. DES\n\nC. SKIPJACK\n\nD.MD5\n\n', `answer` = 'BD', `parsing` = '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', `remark` = NULL, `original_information` = '92.禁止采用如下哪些算法进行口令加密？\n\nA. RSA\n\nB. DES\n\nC. SKIPJACK\n\nD.MD5\n\n答案：BD，迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', `subject` = '科目2', `q_type` = 'MULTI_CHOICE', `hide_answer` = 1, `doubtful` = 0, `likeable` = 0, `error_times` = 1, `right_times` = 0, `doubted_times` = 0 WHERE `id` = 81;
UPDATE `question`.`question` SET `title` = '正则表达式\\[^A-Za-z0-9_\\]与以下哪个表达式等价', `options` = '\n\nA \\t\n\nB \\d\n\nC \\W = [^A-Za-z0-9_]（所以大W，都是去反的含义字母和数字）\n\nD \\v\n\nE \\w = [A-Za-z0-9_]\n\n', `answer` = 'C', `parsing` = NULL, `remark` = NULL, `original_information` = '44、正则表达式\\[^A-Za-z0-9_\\]与以下哪个表达式等价\n\nA \\t\n\nB \\d\n\nC \\W = [^A-Za-z0-9_]（所以大W，都是去反的含义字母和数字）\n\nD \\v\n\nE \\w = [A-Za-z0-9_]\n\n答案：C', `subject` = NULL, `q_type` = 'SINGLE_CHOICE', `hide_answer` = 1, `doubtful` = 0, `likeable` = 0, `error_times` = 0, `right_times` = 0, `doubted_times` = 0 WHERE `id` = 44;
DELETE FROM `question`.`question` WHERE `id` = 461;
DELETE FROM `question`.`question` WHERE `id` = 301;
UPDATE `question`.`question` SET `title` = '某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）', `options` = 'A. 	由于该特性设计文档已经基线，所以不能更新。B. 	根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。C. 	由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。D. 	更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。', `answer` = 'B', `parsing` = NULL, `remark` = '', `original_information` = 'D某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）A. 	由于该特性设计文档已经基线，所以不能更新。B. 	根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。C. 	由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。D. 	更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。', `subject` = NULL, `q_type` = 'SINGLE_CHOICE', `hide_answer` = 1, `doubtful` = 1, `likeable` = 1, `error_times` = 0, `right_times` = 0, `doubted_times` = 0 WHERE `id` = 262;
