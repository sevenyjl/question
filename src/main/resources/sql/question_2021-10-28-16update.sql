INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '在对n个元素进行快速排序的过程中，最坏情况下需要进行多少趟排序？','A. 	nB. 	n-1C. 	n/2D. 	logn','D','D在对n个元素进行快速排序的过程中，最坏情况下需要进行多少趟排序？A. 	nB. 	n-1C. 	n/2D. 	logn','SINGLE_CHOICE',1,1,1 ,805);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下哪一项不属于工程化软件开发所面临的根本性困难？','A. 	软件是庞大的逻辑产品B. 	软件开发工具所提供的开发支持弱C. 	软件的复杂程度高D. 	软件系统的问题空间和解空间之间的巨大鸿沟','B','B以下哪一项不属于工程化软件开发所面临的根本性困难？A. 	软件是庞大的逻辑产品B. 	软件开发工具所提供的开发支持弱C. 	软件的复杂程度高D. 	软件系统的问题空间和解空间之间的巨大鸿沟','SINGLE_CHOICE',1,1,1 ,806);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于开源，以下说法正确的是（）','A. 	产品为实现某原创专利，独立开发的代码，此代码可确认为自研代码。B. 	产品使用了某款开源软件，但该软件对应社区已无人维护，产品由于业务需求必须继续备案使用，此时该软件完全由产品自行维护，因此可认为是自研代码。C. 	产品某开发人员参照某java开源软件的代码，以C#重写实现，此种情况可认为是自研代码。D. 	产品使用了某款开源软件，并对其进行了深度修改，修改量高达95%，剩余5%产品又修改了函数和变量名，FOSSID扫描时并没有被识别未疑似开源软件，此时产品可以将其确认为自研代码。','A','A关于开源，以下说法正确的是（）A. 	产品为实现某原创专利，独立开发的代码，此代码可确认为自研代码。B. 	产品使用了某款开源软件，但该软件对应社区已无人维护，产品由于业务需求必须继续备案使用，此时该软件完全由产品自行维护，因此可认为是自研代码。C. 	产品某开发人员参照某java开源软件的代码，以C#重写实现，此种情况可认为是自研代码。D. 	产品使用了某款开源软件，并对其进行了深度修改，修改量高达95%，剩余5%产品又修改了函数和变量名，FOSSID扫描时并没有被识别未疑似开源软件，此时产品可以将其确认为自研代码。','SINGLE_CHOICE',1,1,1 ,807);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下描述或做法正确的是：（）A. 	产品A软件开发人员在编写代码时，拷贝Apache license 2.0 的XXC++开源软件中的排序算法实现代码，以提升开发升效率B. 	某产品共130K行代码，其中仅10行代码与开源代码相似度较高；该10行代码可以直接确认为自研代码。C. 	产品A使用的开源软件被爆出存在严重漏洞（CVSS>7），产品A的安全SE分析&应用发现该漏洞涉及的代码产品A未调用，可以不需要对产品','A的现网版本打补丁D. 	开源软件的选用，是产品在需求分析&应用和架构设计时决定的；同时产品需基于全量全视角视图管理确保产品及配套的平台、开源及第三方软件版本归一，并满足生命周期要求','A','A以下描述或做法正确的是：（）A. 	产品A软件开发人员在编写代码时，拷贝Apache license 2.0 的XXC++开源软件中的排序算法实现代码，以提升开发升效率B. 	某产品共130K行代码，其中仅10行代码与开源代码相似度较高；该10行代码可以直接确认为自研代码。C. 	产品A使用的开源软件被爆出存在严重漏洞（CVSS>7），产品A的安全SE分析&应用发现该漏洞涉及的代码产品A未调用，可以不需要对产品A的现网版本打补丁D. 	开源软件的选用，是产品在需求分析&应用和架构设计时决定的；同时产品需基于全量全视角视图管理确保产品及配套的平台、开源及第三方软件版本归一，并满足生命周期要求','SINGLE_CHOICE',1,1,1 ,808);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）','A. 	由于该特性设计文档已经基线，所以不能更新。B. 	根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。C. 	由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。D. 	更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。','D','D某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理？（）A. 	由于该特性设计文档已经基线，所以不能更新。B. 	根据实际的特性接口变更规则，通过变更流程更新已基线的特性设计文档。C. 	由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新。D. 	更新特性设计文档，更新后的设计文档归档在小明工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考。','SINGLE_CHOICE',1,1,1 ,809);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '函数搬移是代码重构的一个重要方法，下列重构使用了函数搬移方法的是（）A. 	从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。B. 	将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。C. 	当发现类A某个函数不仅仅适用于当前类，还适用于其它的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。D. 	类','A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及其相关操作。','D','D函数搬移是代码重构的一个重要方法，下列重构使用了函数搬移方法的是（）A. 	从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。B. 	将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。C. 	当发现类A某个函数不仅仅适用于当前类，还适用于其它的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。D. 	类A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及其相关操作。','SINGLE_CHOICE',1,1,1 ,810);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '使用UML对系统进行动态建模，不能使用以下哪种图？（）','A. 	顺序图B. 	类图C. 	状态图D. 	活动图','C','C使用UML对系统进行动态建模，不能使用以下哪种图？（）A. 	顺序图B. 	类图C. 	状态图D. 	活动图','SINGLE_CHOICE',1,1,1 ,811);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '在软件需求工程中，需求管理贯穿整个过程。需求管理最基本的任务是明确需求，使项目团队和用户达成共识，建立（）','A. 	需求跟踪说明B. 	需求变更管理文档C. 	需求分析计划D. 	需求基线','D','D在软件需求工程中，需求管理贯穿整个过程。需求管理最基本的任务是明确需求，使项目团队和用户达成共识，建立（）A. 	需求跟踪说明B. 	需求变更管理文档C. 	需求分析计划D. 	需求基线','SINGLE_CHOICE',1,1,1 ,812);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用以下哪个设计模式最为恰当？（）A. 	适配器模式（ADAPTER）B. 	迭代器模式（ITER','ATOR）C. 	访问者模式（VISITOR）D. 	观察者模式（OBSERVER）','D','D某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用以下哪个设计模式最为恰当？（）A. 	适配器模式（ADAPTER）B. 	迭代器模式（ITERATOR）C. 	访问者模式（VISITOR）D. 	观察者模式（OBSERVER）','SINGLE_CHOICE',1,1,1 ,813);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '从数据组织重构的角度看，下面描述不合理的是（）','A. 	开发初期如果类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。B. 	对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。C. 	对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。','A','A从数据组织重构的角度看，下面描述不合理的是（）A. 	开发初期如果类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。B. 	对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。C. 	对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。','SINGLE_CHOICE',1,1,1 ,814);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '对需求管理，理解不正确的是（）A. 	纯软件需求决策由软件RMT负责B. 	产品软硬件结合需求决策由对应产品SPDT RMT负责C. 	需求冲突时可在CCB会议仲裁D. 	产品R','AT负责各产品系列的软硬结合需求分析','A','A对需求管理，理解不正确的是（）A. 	纯软件需求决策由软件RMT负责B. 	产品软硬件结合需求决策由对应产品SPDT RMT负责C. 	需求冲突时可在CCB会议仲裁D. 	产品RAT负责各产品系列的软硬结合需求分析','SINGLE_CHOICE',1,1,1 ,815);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '违反密钥用途单一规则的有（ ）A. 	同一个预共享密钥，既可以用于认证，又可以用于完整性保护。B. 	一个密钥可以通过算法派生成两个密钥，一个用于计算M','AC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。C. 	分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务。D. 	数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务。','A','A违反密钥用途单一规则的有（ ）A. 	同一个预共享密钥，既可以用于认证，又可以用于完整性保护。B. 	一个密钥可以通过算法派生成两个密钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。C. 	分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务。D. 	数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务。','SINGLE_CHOICE',1,1,1 ,816);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于随机数的描述，错误的是( )','A. 	真正意义上的随机数其结果是不可预测的，安全随机数并非真正意义上的随机数。B. 	现代密码学是基于密钥安全的，随机数的质量决定密钥的质量。C. 	C标准库函数random( )所产生的随机数不属于安全随机数。D. 	安全随机数的要求是不可预测、绝对安全。','A','A关于随机数的描述，错误的是( )A. 	真正意义上的随机数其结果是不可预测的，安全随机数并非真正意义上的随机数。B. 	现代密码学是基于密钥安全的，随机数的质量决定密钥的质量。C. 	C标准库函数random( )所产生的随机数不属于安全随机数。D. 	安全随机数的要求是不可预测、绝对安全。','SINGLE_CHOICE',1,1,1 ,817);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下对文件的操作做法中错误的是（）','A. 	校验文件路径时使用getCanonicalPath()获取文件路径B. 	使用Files.newByteChannel()在文件创建时指定合适的权限C. 	临时文件使用完毕之后、系统终止之前，应该显式地对其进行删除D. 	从ZipInputStream中解压文件时仅调用ZipEntry.getSize()方法判断解压文件大小','D','D以下对文件的操作做法中错误的是（）A. 	校验文件路径时使用getCanonicalPath()获取文件路径B. 	使用Files.newByteChannel()在文件创建时指定合适的权限C. 	临时文件使用完毕之后、系统终止之前，应该显式地对其进行删除D. 	从ZipInputStream中解压文件时仅调用ZipEntry.getSize()方法判断解压文件大小','SINGLE_CHOICE',1,1,1 ,818);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于java中调用外部进程的说法中，错误的是（ ）','A. 	外部程序运行时由java.lang.Process对象描述。这个对象包含一个输入流，输出流，以及一个错误流。B. 	外部进程的输出流是一个OutputStream对象，可以通过Process的静态方法getOutputStream获取。C. 	一个外部进程如果试图从一个空的输入流中读取输入，则会一直阻塞，直到为其提供输入。D. 	一个外部进程的输出可能会耗尽该进程输出流与错误流的缓冲区。当发生这种情况时，Java 程序可能会阻塞外部进程，同时阻碍Java程序与外部程序的继续运行。','B','B关于java中调用外部进程的说法中，错误的是（ ）A. 	外部程序运行时由java.lang.Process对象描述。这个对象包含一个输入流，输出流，以及一个错误流。B. 	外部进程的输出流是一个OutputStream对象，可以通过Process的静态方法getOutputStream获取。C. 	一个外部进程如果试图从一个空的输入流中读取输入，则会一直阻塞，直到为其提供输入。D. 	一个外部进程的输出可能会耗尽该进程输出流与错误流的缓冲区。当发生这种情况时，Java 程序可能会阻塞外部进程，同时阻碍Java程序与外部程序的继续运行。','SINGLE_CHOICE',1,1,1 ,819);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下列哪个不是Class类中定义的反射方法？','A. 	getDeclaredFiledsB. 	getDeclaredNamesC. 	getDeclaredMethodsD. 	getDeclaredConstructors','D','D下列哪个不是Class类中定义的反射方法？A. 	getDeclaredFiledsB. 	getDeclaredNamesC. 	getDeclaredMethodsD. 	getDeclaredConstructors','SINGLE_CHOICE',1,1,1 ,820);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '某测试环境发现部署的java进程(pid=17212)经常Full GC,长期内存占用很高,疑似内存泄漏。现在想要确定是哪些类的实例占内存较多,那么应该用下列选项中的哪个命令？','A. 	jmap -histo 17212B. 	top -Hp 17212C. 	jstack 17212D. 	jstat -gcutil 17212','D','D某测试环境发现部署的java进程(pid=17212)经常Full GC,长期内存占用很高,疑似内存泄漏。现在想要确定是哪些类的实例占内存较多,那么应该用下列选项中的哪个命令？A. 	jmap -histo 17212B. 	top -Hp 17212C. 	jstack 17212D. 	jstat -gcutil 17212','SINGLE_CHOICE',1,1,1 ,821);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下列使用NIO对文件读写进行操作，哪个是错误的：A. 	读小文件的所有字节：byte[] bytes = Files.readAllBytes(file.toPath());B. 	读小文本中所有的行：List<String> lines = Files.readAllLines(file.toPath());C. 	将数据写入文件尾：// file与lines为合法参数Files.write(file.toPath(), lines, StandardCharsets.UTF_8, StandardOpenOption.CRE','ATE);D. 	读取大文本：try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {    String line = null;    while ((line = reader.readLine()) != null) {        // ...    }} catch (IOException x) {    // ...}','C','C下列使用NIO对文件读写进行操作，哪个是错误的：A. 	读小文件的所有字节：byte[] bytes = Files.readAllBytes(file.toPath());B. 	读小文本中所有的行：List<String> lines = Files.readAllLines(file.toPath());C. 	将数据写入文件尾：// file与lines为合法参数Files.write(file.toPath(), lines, StandardCharsets.UTF_8, StandardOpenOption.CREATE);D. 	读取大文本：try (BufferedReader reader = Files.newBufferedReader(file, StandardCharsets.UTF_8)) {    String line = null;    while ((line = reader.readLine()) != null) {        // ...    }} catch (IOException x) {    // ...}','SINGLE_CHOICE',1,1,1 ,822);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下哪个类不是继承自InputStream/OutputStream ？A. 	ObjectInputStreamB. 	BufferedOutputStreamC. 	RandomAccessFileD. 	Byte','ArrayInputStream','C','C如下哪个类不是继承自InputStream/OutputStream ？A. 	ObjectInputStreamB. 	BufferedOutputStreamC. 	RandomAccessFileD. 	ByteArrayInputStream','SINGLE_CHOICE',1,1,1 ,823);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '关于下面代码,下列选项中说法正确的是？final int limit = 5;Map<Integer, String> map = new LinkedHashMap(16, 0.75f, true) {    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() > limit;    }};for (int i = 0; i < 10; i++) {    map.put(i, String.valueOf(i));}String v = map.get(6);map.keySet().forEach(System.out::print);','A. 	代码运行后,控制台打印65789B. 	代码运行后,控制台打印95678C. 	代码运行后,控制台打印56789D. 	代码运行后,控制台打印57896','D','D关于下面代码,下列选项中说法正确的是？final int limit = 5;Map<Integer, String> map = new LinkedHashMap(16, 0.75f, true) {    protected boolean removeEldestEntry(Map.Entry eldest) {        return size() > limit;    }};for (int i = 0; i < 10; i++) {    map.put(i, String.valueOf(i));}String v = map.get(6);map.keySet().forEach(System.out::print);A. 	代码运行后,控制台打印65789B. 	代码运行后,控制台打印95678C. 	代码运行后,控制台打印56789D. 	代码运行后,控制台打印57896','SINGLE_CHOICE',1,1,1 ,824);
