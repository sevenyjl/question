UPDATE `question`.`question` SET `title` = '下列关于Thread类提供的线程控制方法的说法中，错误的是（）\n\n', `options` = 'A currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；\n\nisAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）\n\n', `answer` = 'D', `parsing` = NULL, `remark` = NULL, `original_information` = '9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）\n\nA currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；\n\nisAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）\n\n答案：D', `subject` = NULL, `q_type` = 'SINGLE_CHOICE', `hide_answer` = 1, `doubtful` = 0, `likeable` = 0 WHERE `id` = 9;

UPDATE question  SET title='某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）',options='A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件\n\nB 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密\n\nC 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；\n\nD 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640',answer='D',parsing='D:看来权限是给高了，个人感觉是不是600就可以了',original_information='10、某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件B 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密C 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；D 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640（看来权限是给高了）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=10;
UPDATE question  SET title='下列赋值表达式不会报错的是（）',options='A boolean isStop = “true”;\\n\\nB float fit = 3.1;\\n\\nC int num = 1.0;\\n\\nD char ch = 1;',answer='D',parsing='A:用Boolean.parseBoolean(\"true\")\\nB:float fit = 3.1--->>float fit = 3.1f\\nC:int 只能是整数\\nD：正确',original_information='14、下列赋值表达式不会报错的是（）A boolean isStop = “true”;B float fit = 3.1; // float fit = 3.1f;C int num = 1.0;D char ch = 1;（char可以容纳的数字范围是多少）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=14;
UPDATE `question`.`question` SET `title` = '下列赋值表达式不会报错的是（）\n\n', `options` = 'A boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n', `answer` = 'D', `parsing` = NULL, `remark` = NULL, `original_information` = '14、下列赋值表达式不会报错的是（）\n\nA boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n答案：D', `subject` = NULL, `q_type` = 'SINGLE_CHOICE', `hide_answer` = 1, `doubtful` = 0, `likeable` = 0 WHERE `id` = 14;
UPDATE question  SET likeable=0  WHERE id=1;
UPDATE question  SET doubtful=0  WHERE id=1;
UPDATE question  SET likeable=0  WHERE id=2;
UPDATE question  SET doubtful=0  WHERE id=2;
UPDATE question  SET likeable=0  WHERE id=3;
UPDATE question  SET doubtful=0  WHERE id=3;
UPDATE question  SET likeable=0  WHERE id=4;
UPDATE question  SET doubtful=0  WHERE id=4;
UPDATE question  SET title='下列对于Stream的操作错误的是：',options='A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");\nList<String> colors = stream.collection(Collector.toList());\n\nB IntStream stream IntStream.of(10,20,30,40,50);\n\nC long count = Stream.of().count();\n\nD final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");\nSet<String> colors = stream.toSet();',answer='D',parsing='D 没有stream.toSet()这个方法',original_information='8、 下列对于Stream的操作错误的是：1A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");2List<String> colors = stream.collection(Collector.toList());3B IntStream stream IntStream.of(10,20,30,40,50);4C long count = Stream.of().count();5D final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");6Set<String> colors = Stream.toSet();（根本就没有你的这种用法）答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=8;
UPDATE question  SET likeable=0  WHERE id=8;
UPDATE question  SET doubtful=0  WHERE id=8;
UPDATE question  SET doubtful=0  WHERE id=9;
UPDATE question  SET likeable=0  WHERE id=9;
UPDATE question  SET title='下列关于Thread类提供的线程控制方法的说法中，错误的是（）',options='A currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。',answer='D',parsing='D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了',original_information='9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）A currentThread()方法返回当前线程的引用B 线程A通过调用interrupt()方法来中断其阻塞状态C 线程A中执行线程B的join()方法，则线程A等待直到B执行完成D 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=9;
UPDATE question  SET doubtful=0  WHERE id=10;
UPDATE question  SET likeable=0  WHERE id=10;
UPDATE question  SET title='如下代码片段，S1的结果是哪项()\nString str = \"123\";\nString s2 = str + 456;\n\n',options='A 编译错误\n\nB 123456\n\nC 运行时抛异常\n\nD 579\n\n',answer='B',original_information='15、如下代码片段，S1的结果是哪项()\n\n1\n\nString str = \"123\";\n\n2\n\nString s2 = st1 + 456;\n\nA 编译错误\n\nB 123456\n\nC 运行时抛异常\n\nD 579\n\n答案：B',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=15;
UPDATE question  SET title='在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类',options='\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n',answer='B',original_information='17、在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n（UnkownTypeException，这种错误以前从没有注意过）\n\n答案：B',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=17;
UPDATE question  SET title='集合API中的Set接口的特点是哪些？',options='\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n',answer='D',parsing='顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n',original_information='18、集合API中的Set接口的特点是哪些？\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=18;
UPDATE question  SET title='下列操作有关Map操作错误的是：',options='A\nMap<Integer, String> cityMap = new HashMap<Integer, String>() {\n    {\n        put(1, \"Nanjing\");\n        put(2, \"Beijing\");\n        put(3, \"Shanghai\");\n    }\n};\n\nB\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n    System.out.println(city.getValue());\n}\n\nC\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4,null);\n\nD\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();',answer='D',parsing='D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}',original_information='19、下列操作有关Map操作错误的是：\n\nA\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>() {\n\n2\n\n{\n\n3\n\nput(1, \"Nanjing”);\n\n4\n\nput(2, \"Beijing”);\n\n5\n\nput(3, \"Shanghai”);\n\n6\n\n}\n\n7\n\n}（这里应该会实现装包机制）\n\nB\n\n1\n\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n\n2\n\nSystem.out.println(city.getValue());\n\n3\n\n}\n\nC\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>();\n\n2\n\ncityMap.put(4, null);（我记得有些Map是不允许放入null的）\n\nD\n\n1\n\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);（这里面的map都是不可以修改的，不可以修改的原因是什么了？）\n\n2\n\nunmodifiableMap.clear();（看过了你的方法，真的是无耻）\n\n答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=19;
UPDATE question  SET doubtful=0  WHERE id=20;
