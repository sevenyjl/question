UPDATE `question`.`question` SET `title` = '下列关于Thread类提供的线程控制方法的说法中，错误的是（）\n\n', `options` = 'A currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；\n\nisAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）\n\n', `answer` = 'D', `parsing` = NULL, `remark` = NULL, `original_information` = '9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）\n\nA currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；\n\nisAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）\n\n答案：D', `subject` = NULL, `q_type` = 'SINGLE_CHOICE', `hide_answer` = 1, `doubtful` = 0, `likeable` = 0 WHERE `id` = 9;

UPDATE question  SET title='某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）',options='A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件\n\nB 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密\n\nC 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；\n\nD 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640',answer='D',parsing='D:看来权限是给高了，个人感觉是不是600就可以了',original_information='10、某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件B 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密C 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；D 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640（看来权限是给高了）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=10;
UPDATE question  SET title='下列赋值表达式不会报错的是（）',options='A boolean isStop = “true”;\\n\\nB float fit = 3.1;\\n\\nC int num = 1.0;\\n\\nD char ch = 1;',answer='D',parsing='A:用Boolean.parseBoolean(\"true\")\\nB:float fit = 3.1--->>float fit = 3.1f\\nC:int 只能是整数\\nD：正确',original_information='14、下列赋值表达式不会报错的是（）A boolean isStop = “true”;B float fit = 3.1; // float fit = 3.1f;C int num = 1.0;D char ch = 1;（char可以容纳的数字范围是多少）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=14;
UPDATE `question`.`question` SET `title` = '下列赋值表达式不会报错的是（）\n\n', `options` = 'A boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n', `answer` = 'D', `parsing` = NULL, `remark` = NULL, `original_information` = '14、下列赋值表达式不会报错的是（）\n\nA boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n答案：D', `subject` = NULL, `q_type` = 'SINGLE_CHOICE', `hide_answer` = 1, `doubtful` = 0, `likeable` = 0 WHERE `id` = 14;
UPDATE question  SET likeable=0  WHERE id=1;
UPDATE question  SET doubtful=0  WHERE id=1;
UPDATE question  SET likeable=0  WHERE id=2;
UPDATE question  SET doubtful=0  WHERE id=2;
UPDATE question  SET likeable=0  WHERE id=3;
UPDATE question  SET doubtful=0  WHERE id=3;
UPDATE question  SET likeable=0  WHERE id=4;
UPDATE question  SET doubtful=0  WHERE id=4;
UPDATE question  SET title='下列对于Stream的操作错误的是：',options='A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");\nList<String> colors = stream.collection(Collector.toList());\n\nB IntStream stream IntStream.of(10,20,30,40,50);\n\nC long count = Stream.of().count();\n\nD final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");\nSet<String> colors = stream.toSet();',answer='D',parsing='D 没有stream.toSet()这个方法',original_information='8、 下列对于Stream的操作错误的是：1A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");2List<String> colors = stream.collection(Collector.toList());3B IntStream stream IntStream.of(10,20,30,40,50);4C long count = Stream.of().count();5D final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");6Set<String> colors = Stream.toSet();（根本就没有你的这种用法）答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=8;
UPDATE question  SET likeable=0  WHERE id=8;
UPDATE question  SET doubtful=0  WHERE id=8;
UPDATE question  SET doubtful=0  WHERE id=9;
UPDATE question  SET likeable=0  WHERE id=9;
UPDATE question  SET title='下列关于Thread类提供的线程控制方法的说法中，错误的是（）',options='A currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。',answer='D',parsing='D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了',original_information='9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）A currentThread()方法返回当前线程的引用B 线程A通过调用interrupt()方法来中断其阻塞状态C 线程A中执行线程B的join()方法，则线程A等待直到B执行完成D 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=9;
UPDATE question  SET doubtful=0  WHERE id=10;
UPDATE question  SET likeable=0  WHERE id=10;
UPDATE question  SET title='如下代码片段，S1的结果是哪项()\nString str = \"123\";\nString s2 = str + 456;\n\n',options='A 编译错误\n\nB 123456\n\nC 运行时抛异常\n\nD 579\n\n',answer='B',original_information='15、如下代码片段，S1的结果是哪项()\n\n1\n\nString str = \"123\";\n\n2\n\nString s2 = st1 + 456;\n\nA 编译错误\n\nB 123456\n\nC 运行时抛异常\n\nD 579\n\n答案：B',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=15;
UPDATE question  SET title='在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类',options='\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n',answer='B',original_information='17、在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n（UnkownTypeException，这种错误以前从没有注意过）\n\n答案：B',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=17;
UPDATE question  SET title='集合API中的Set接口的特点是哪些？',options='\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n',answer='D',parsing='顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n',original_information='18、集合API中的Set接口的特点是哪些？\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=18;
UPDATE question  SET title='下列操作有关Map操作错误的是：',options='A\nMap<Integer, String> cityMap = new HashMap<Integer, String>() {\n    {\n        put(1, \"Nanjing\");\n        put(2, \"Beijing\");\n        put(3, \"Shanghai\");\n    }\n};\n\nB\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n    System.out.println(city.getValue());\n}\n\nC\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4,null);\n\nD\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();',answer='D',parsing='D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}',original_information='19、下列操作有关Map操作错误的是：\n\nA\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>() {\n\n2\n\n{\n\n3\n\nput(1, \"Nanjing”);\n\n4\n\nput(2, \"Beijing”);\n\n5\n\nput(3, \"Shanghai”);\n\n6\n\n}\n\n7\n\n}（这里应该会实现装包机制）\n\nB\n\n1\n\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n\n2\n\nSystem.out.println(city.getValue());\n\n3\n\n}\n\nC\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>();\n\n2\n\ncityMap.put(4, null);（我记得有些Map是不允许放入null的）\n\nD\n\n1\n\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);（这里面的map都是不可以修改的，不可以修改的原因是什么了？）\n\n2\n\nunmodifiableMap.clear();（看过了你的方法，真的是无耻）\n\n答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=19;
UPDATE question  SET doubtful=0  WHERE id=20;
UPDATE question  SET title='关于synchronized的叙述错误的是()\n\n',options='A 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景\n\n',answer='D',parsing='A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？',original_information='21、关于synchronized的叙述错误的是()\n\nA 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步（这个真不知道，难道这个锁住的逻辑，还有在很多的层面实现的吗）\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁（发生异常会自动释放）\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景（啥玩意都互斥）\n\n答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=21;
UPDATE question  SET doubtful=0  WHERE id=22;
UPDATE question  SET doubtful=0  WHERE id=22;
UPDATE question  SET doubtful=0  WHERE id=24;
UPDATE question  SET title='有关类加载器的双亲委派模型说法错误的时（）\n\n',options='A 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载\n\n',answer='C',parsing='参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。',original_information='24、 有关类加载器的双亲委派模型说法错误的时（）\n\nA 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；（类加载机制）\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载（优先机制）\n\n答案：C（自定义类加载器有什么用处呢）（双亲委托机制：\n\n简单来说就是加载一个类进内存，先从系统类加载器找，往上从扩展类中找，往上再从根加载器中找）（可以随心所欲的进行安全校验）（实例加载的时候，就会以子类开始了）',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=24;
UPDATE question  SET doubtful=0  WHERE id=23;
UPDATE question  SET doubtful=0  WHERE id=23;
UPDATE question  SET title='对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\n',options='A 使得第idx个参数的值设为val\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n',answer='A',parsing='PreparedStatement的索引是从1开始',original_information='25、对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\nA 使得第idx个参数的值设为val（这个还是死记硬背吧，和我们平常理解的不一样的）\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n答案：A',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=25;
UPDATE question  SET title='有关NIO Selector说法错误的是：\n\n',options='A 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n',answer='C',parsing='A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭',original_information='26、有关NIO Selector说法错误的是：\n\nA 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;（看来机制介绍的还是很清楚的）\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close（buffer里面属性使用都时在NIO的使用，在NIO）（capacity、position、limit）\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n答案：C',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=26;
UPDATE question  SET title='下面锁用的正确的是：\n\n',options='A\nprivate int count=0;\nprivate final Integer lock=new Integer(count);\npublic void doSomething(){\n    Synchronized(lock){\n    Count++;\n    }\n}\n\n B\nprivate final String lock=\"LOCK”;\npublic void doSomething(){\n    synchronized (lock){\n    //..\n    }\n}\n\nC \nBoolean isInitialized=Boolean.FALSE;\npublic void doSomething(){\n    synchronized (isInitialized){\n    //..\n    }\n}\n\n    D\nprivate int count=0;\nprivate final integer lock=count;\npublic void doSomething(){\n    synchronized (lock){\n        lock++;\n    }\n}\n\n',answer='A',parsing='一句话，锁不要公用',original_information='27、下面锁用的正确的是：\n\nA\n\n1\n\nprivate int count = 0;\n\n2\n\nprivate final Integer lock = new Integer(count);\n\n3\n\npublic void doSomething() {\n\n4\n\nSynchronized (lock) {\n\n5\n\nCount++;\n\n6\n\n}\n\nB\n\n1\n\nprivate final String lock = \"LOCK”;\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (lock) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nC\n\n1\n\nBoolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (isInitialized) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nD\n\n1\n\nprivate int count = 0;\n\n2\n\nPrivate final integer lock = count;锁必须不能是公共人可以获取的东西\n\n3\n\npublic void doSomething() {\n\n4\n\nsynchronized (lock) {\n\n5\n\nlock++;\n\n6\n\n}\n\n7\n\n}（因为别的程序还要用）\n\n答案：A',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=27;
UPDATE question  SET title='下面锁用的正确的是：\n\n',options='A\nprivate int count=0;\nprivate final Integer lock=new Integer(count);\npublic void doSomething(){\n    Synchronized(lock){\n    Count++;\n    }\n}\n\n B\nprivate final String lock=\"LOCK”;\npublic void doSomething(){\n    synchronized (lock){\n    //..\n    }\n}\n\nC \nBoolean isInitialized=Boolean.FALSE;\npublic void doSomething(){\n    synchronized (isInitialized){\n    //..\n    }\n}\n\n    D\nprivate int count=0;\nprivate final integer lock=count;\npublic void doSomething(){\n    synchronized (lock){\n        lock++;\n    }\n}\n\n',answer='A',parsing='一句话，锁不要公用，容易阻塞/死锁',original_information='27、下面锁用的正确的是：\n\nA\n\n1\n\nprivate int count = 0;\n\n2\n\nprivate final Integer lock = new Integer(count);\n\n3\n\npublic void doSomething() {\n\n4\n\nSynchronized (lock) {\n\n5\n\nCount++;\n\n6\n\n}\n\nB\n\n1\n\nprivate final String lock = \"LOCK”;\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (lock) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nC\n\n1\n\nBoolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (isInitialized) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nD\n\n1\n\nprivate int count = 0;\n\n2\n\nPrivate final integer lock = count;锁必须不能是公共人可以获取的东西\n\n3\n\npublic void doSomething() {\n\n4\n\nsynchronized (lock) {\n\n5\n\nlock++;\n\n6\n\n}\n\n7\n\n}（因为别的程序还要用）\n\n答案：A',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=27;
