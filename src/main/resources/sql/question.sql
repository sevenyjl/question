/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : question

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 31/10/2021 17:38:33
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for question
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question`  (
                             `id` int(11) NOT NULL AUTO_INCREMENT,
                             `title` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '题目',
                             `options` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '选项',
                             `answer` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '答案',
                             `parsing` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '解析',
                             `remark` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '备注',
                             `original_information` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '原始信息',
                             `subject` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '科目',
                             `q_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '题型',
                             `hide_answer` tinyint(4) NULL DEFAULT 1 COMMENT '0隐藏1显示',
                             `doubtful` tinyint(4) NULL DEFAULT 1 COMMENT '存疑的0存疑1不存疑',
                             `likeable` tinyint(4) NULL DEFAULT 1 COMMENT '收藏 0收藏1不收藏',
                             `error_times` int(11) NULL DEFAULT 0 COMMENT '错误次数',
                             `right_times` int(11) NULL DEFAULT 0 COMMENT '正确次数',
                             `doubted_times` int(11) NULL DEFAULT 0 COMMENT '存疑次数',
                             PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 843 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES (1, '下列说法错误的是（）', 'A 反射可以获取类的构造器B 反射可获以Method,通过invoke进行方法的调用；C 反射可以获取注解（@Target为Runtime）信息；D 反射能够直接get(obj)获取私有的Field成员的值；', 'CD', 'A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法B:通过getMethods能获取方法并使用invoke进行调用C:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置D:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值故选择：CD', NULL, '1、 下列说法错误的是（）A 反射可以获取类的构造器B 反射可获以Method,通过invoke进行方法的调用；C 反射可以获取注解（@Target为Runtime）信息；D 反射能够直接get(obj)获取私有的Field成员的值；答案：CD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (2, '下列程序执行结果说法正确的（）public class Test {    public static void main(String[] args) {        List<String> list = new ArrayList<>();        list.add(\"str1\");        list.add(2, \"str2\");        String str = list.get(1);        System.out.println(str);    }}', 'A 编译时出现异常；B 正确运行，输出str1;C 正确运行，输出str2;D 运行时出现异常', 'D', '运行时list.add(2, \"str2\");报错，因为ArrayList在添加前会调用rangeCheckForAdd方法判断当前索引是否大于了当前数组的size一句话list.add(2, \"str2\")只能替换不能追加', NULL, '2、 下列程序执行结果说法正确的（）1public class Test {23public static void main(String[]args) {4List<String> list = new ArrayList<>();5list.add(\"str1\");6list.add(2,\"str2\");7String str = list.get(1);8System.out.println(str);9}10}A 编译时出现异常；B 正确运行，输出str1;C 正确运行，输出str2;D 运行时出现异常答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (3, '下边这段代码的输出结果为（）int fst = 5;int snd = 2;while (snd < fst--) {    snd++;}System.out.print(snd);', 'A 5B 2C 3D 4', 'D', 'fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34', NULL, '3、 下边这段代码的输出结果为（）1int fst = 5;2int snd = 2;3while(snd < fst--) {4snd++;5}6System.out.print(snd);A 5B 2C 3D 4答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (4, '下列程序的输出结果为（）（一旦匹配，立即顺序执行；包装类型也是可以接受的）int num = 2;switch (num) {    case 1:        System.out.println(\"The input is 1\");    case 2:        System.out.println(\"The input is 2\");    case 3:        System.out.println(\"The input is 3\");    default:        System.out.println(\"Bad input\");}', 'AThe input is 2​The input is 3B The input is 1C The input is 2D The input is 2​The input is 3​Bad input', 'D', 'switch没有break会执行完后面的如果        int num = 2;        switch (num) {            case 2:                System.out.println(\"The input is 2\");            case 1:                System.out.println(\"The input is 1\");            case 3:                System.out.println(\"The input is 3\");            default:                System.out.println(\"Bad input\");        }会输出213 Bad input', NULL, '4、 下列程序的输出结果为（）（一旦匹配，立即顺序执行；包装类型也是可以接受的）1int num=2;2switch(num) {3case 1:4System.out.println(\"The input is 1\");5case 2:6System.out.println(\"The input is 2\");7case 3:8System.out.println(\"The input is 3\");9default :10System.out.println(\"Bad input\");11}A The input is 2​The input is 3B The input is 1C The input is 2D The input is 2​The input is 3​Bad input答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (5, '关于代码格式如下说法错误的是（）\n\n', 'A 一个源文件按顺序包含版本、package、import、顶层、且用空行分隔；\n\nB 对于非空块和块状结构，左大括号放在行尾；\n\nC 空行不是代码，所以代码中多写几个空行没有关系；\n\nD 一个类或接口的声明部分应当按照类变、实例变量，构造器，方法的顺序出现，且用空行分隔；\n\n', 'C', NULL, NULL, '5、 关于代码格式如下说法错误的是（）\n\nA 一个源文件按顺序包含版本、package、import、顶层、且用空行分隔；\n\nB 对于非空块和块状结构，左大括号放在行尾；\n\nC 空行不是代码，所以代码中多写几个空行没有关系；\n\nD 一个类或接口的声明部分应当按照类变、实例变量，构造器，方法的顺序出现，且用空行分隔；\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (6, '哪个异常可能会泄露文件系统结构信息（）\n\n', 'A java.io.FileNotFountException\n\nB java.io.IOException\n\nC java.util.MissResourceException\n\nD java.sql.SQLException\n\n', 'A', NULL, NULL, '6、 哪个异常可能会泄露文件系统结构信息（）\n\nA java.io.FileNotFountException\n\nB java.io.IOException\n\nC java.util.MissResourceException\n\nD java.sql.SQLException\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (7, '有关ORM的说法错误的是（）\n\n', 'A ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；\n\nB ORM依赖于JDBC和DataSource;\n\nC ORM有多种实现，主流的Mybatis与Hibernate;\n\nD ORM、对象关系转换，即数据库的单条数据与Java对应之间的映射；\n\n', 'A', NULL, NULL, '7、 有关ORM的说法错误的是（）\n\nA ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；\n\nB ORM依赖于JDBC和DataSource;\n\nC ORM有多种实现，主流的Mybatis与Hibernate;\n\nD ORM、对象关系转换，即数据库的单条数据与Java对应之间的映射；\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (8, '下列对于Stream的操作错误的是：', 'A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");\nList<String> colors = stream.collection(Collector.toList());\n\nB IntStream stream IntStream.of(10,20,30,40,50);\n\nC long count = Stream.of().count();\n\nD final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");\nSet<String> colors = stream.toSet();', 'D', 'D 没有stream.toSet()这个方法', NULL, '8、 下列对于Stream的操作错误的是：1A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");2List<String> colors = stream.collection(Collector.toList());3B IntStream stream IntStream.of(10,20,30,40,50);4C long count = Stream.of().count();5D final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");6Set<String> colors = Stream.toSet();（根本就没有你的这种用法）答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (9, '下列关于Thread类提供的线程控制方法的说法中，错误的是（）', 'A currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。', 'D', 'D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了', NULL, '9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）A currentThread()方法返回当前线程的引用B 线程A通过调用interrupt()方法来中断其阻塞状态C 线程A中执行线程B的join()方法，则线程A等待直到B执行完成D 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (10, '某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）', 'A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件\n\nB 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密\n\nC 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；\n\nD 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640', 'D', 'D:看来权限是给高了，个人感觉是不是600就可以了', NULL, '10、某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件B 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密C 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；D 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640（看来权限是给高了）答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (11, '若一个实现了Serializable接口的类中包含有敏感信息字段，为了防止该类对象被序序列化时导致敏感信息泄露，可以使用下面哪个关键字（）\n\n', 'A private\n\nB static\n\nC volatile\n\nD transient\n\n', 'D', NULL, NULL, '11、若一个实现了Serializable接口的类中包含有敏感信息字段，为了防止该类对象被序序列化时导致敏感信息泄露，可以使用下面哪个关键字（）\n\nA private\n\nB static\n\nC volatile\n\nD transient\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (12, '下列哪些行为符合安全编码规范\n\n', 'A 某产品在为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志汇中。\n\nB 某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值（生日判定）\n\nC 某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力\n\nD 某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字\n\n', 'D', NULL, NULL, '12、下列哪些行为符合安全编码规范\n\nA 某产品在为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志汇中。\n\nB 某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值（生日判定）\n\nC 某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力\n\nD 某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (13, '的基本类型的int在不同的操作系统平台的字长是\n\n', 'A 32位（只能记住）\n\nB 64位\n\nC 16位\n\nD 在32位系统上是32位，在64位系统上是64位 //long类型在不同的操作系统才有区别\n\n', 'A', NULL, NULL, '13、Java的基本类型的int在不同的操作系统平台的字长是\n\nA 32位（只能记住）\n\nB 64位\n\nC 16位\n\nD 在32位系统上是32位，在64位系统上是64位 //long类型在不同的操作系统才有区别\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (14, '下列赋值表达式不会报错的是（）\n\n', 'A boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n', 'D', NULL, NULL, '14、下列赋值表达式不会报错的是（）\n\nA boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (15, '如下代码片段，S1的结果是哪项()String str = \"123\";String s2 = str + 456;', 'A 编译错误B 123456C 运行时抛异常D 579', 'B', NULL, NULL, '15、如下代码片段，S1的结果是哪项()1String str = \"123\";2String s2 = st1 + 456;A 编译错误B 123456C 运行时抛异常D 579答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 1, 0, 0, 0);
INSERT INTO `question` VALUES (16, '编译并运行如下Java程序，将输出（）\npublic static void main(String[] args) {\n    try {\n        int num1 = 2;\n        int num2 = 0;\n        int result = num1 / num2;\n        System.out.println(result);\n    } catch (ArrayIndexOutOfBoundsException e) {\n        System.out.println(\"1\");\n    } catch (NumberFormatException e) {//（数字格式报错）\n        System.out.println(\"2\");\n    } catch (Exception e) {\n        System.out.println(\"3\");\n    } finally {\n        System.out.println(\"4\");\n    }\n    System.out.println(\"5\");\n}', 'A 345\n\n​B 134\n\n​C 2345\n\n​D 1345\n\n', 'A', NULL, NULL, '16、编译并运行如下Java程序，将输出（）\n\n1\n\npublic static void main(String[] args) {\n\n2\n\ntry {\n\n3\n\nint num1 = 2;\n\n4\n\nint num2 = 0;\n\n5\n\nint result = num1 / num2;\n\n6\n\nSystem.out.println(result);\n\n7\n\n} catch (ArrayIndexOutOfBoundsException e) {\n\n8\n\nSystem.out.println(\"1\");\n\n9\n\n} catch (NumberFormatException e) {（数字格式报错）\n\n10\n\nSystem.out.println(\"2\");\n\n11\n\n} catch (Exception e) {\n\n12\n\nSystem.out.println(\"3\");\n\n13\n\n} finally {\n\n14\n\nSystem.out.println(\"4\");\n\n15\n\n}\n\n16\n\nSystem.out.println(\"5\");\n\n17\n\n}\n\n​ A 345\n\n​B 134\n\n​C 2345\n\n​D 1345\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (17, '在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类', '\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n', 'B', NULL, NULL, '17、在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n（UnkownTypeException，这种错误以前从没有注意过）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (18, '集合API中的Set接口的特点是哪些？', '\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n', 'D', '顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n', NULL, '18、集合API中的Set接口的特点是哪些？\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (19, '下列操作有关Map操作错误的是：', 'A\nMap<Integer, String> cityMap = new HashMap<Integer, String>() {\n    {\n        put(1, \"Nanjing\");\n        put(2, \"Beijing\");\n        put(3, \"Shanghai\");\n    }\n};\n\nB\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n    System.out.println(city.getValue());\n}\n\nC\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4,null);\n\nD\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 'D', 'D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}', NULL, '19、下列操作有关Map操作错误的是：\n\nA\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>() {\n\n2\n\n{\n\n3\n\nput(1, \"Nanjing”);\n\n4\n\nput(2, \"Beijing”);\n\n5\n\nput(3, \"Shanghai”);\n\n6\n\n}\n\n7\n\n}（这里应该会实现装包机制）\n\nB\n\n1\n\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n\n2\n\nSystem.out.println(city.getValue());\n\n3\n\n}\n\nC\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>();\n\n2\n\ncityMap.put(4, null);（我记得有些Map是不允许放入null的）\n\nD\n\n1\n\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);（这里面的map都是不可以修改的，不可以修改的原因是什么了？）\n\n2\n\nunmodifiableMap.clear();（看过了你的方法，真的是无耻）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (20, '有关泛型，下面说法错误的是：\n\n', 'A extends约束类型上限，如public int add (T n1, T n2); 表示方法参数必须是Number的子类型；（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\n\nB List numList = new ArrayList();\n\nList intList = new ArrayList();（赋值是不可能的，不过可以addAll）\n\n因为Integer是Number的子类，所以intList可以赋值给numberList（这题给的也太简洁了吧）\n\nC 对于同一个类，可以使用不同的泛型参数类型声明类型和方法；\n\nD 泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考；当实例化时，使用具体的类型替代，这是实参\n\n', 'B', NULL, NULL, '20、有关泛型，下面说法错误的是：\n\nA extends约束类型上限，如public int add (T n1, T n2); 表示方法参数必须是Number的子类型；（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\n\nB List numList = new ArrayList();\n\nList intList = new ArrayList();（赋值是不可能的，不过可以addAll）\n\n因为Integer是Number的子类，所以intList可以赋值给numberList（这题给的也太简洁了吧）\n\nC 对于同一个类，可以使用不同的泛型参数类型声明类型和方法；\n\nD 泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考；当实例化时，使用具体的类型替代，这是实参\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (21, '关于synchronized的叙述错误的是()\n\n', 'A 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景\n\n', 'D', 'A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？', NULL, '21、关于synchronized的叙述错误的是()\n\nA 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步（这个真不知道，难道这个锁住的逻辑，还有在很多的层面实现的吗）\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁（发生异常会自动释放）\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景（啥玩意都互斥）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (22, '下面的程序创建了一个文件输出流对象，用来向向文件test.txt中输出数据。假设程序当前运行目录下不存在文件test.txt（自动重建），编译后执行结果为（）（编译后的结果怎么控制呢）\nimport java.io.*;\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            String str = \"ABCDE”;\n            byte[] bs = str.getBytes(StandardCharsets.UTF_8);\n            FileOutputStream file = new FileOutputStream(\"test.txt”, true);\n                file.write(bs);\n            file.close();\n        } catch (IOException e) {\n            System.out.println(e.toString());\n        }\n    }\n}//（你这个是什么样子的思考方法）', '\n\nA ABCABC\n\nB Test\n\nC ABCDEABCDEABCDE\n\nD ABCDE\n\n', 'D', NULL, NULL, '22、下面的程序创建了一个文件输出流对象，用来向向文件test.txt中输出数据。假设程序当前运行目录下不存在文件test.txt（自动重建），编译后执行结果为（）（编译后的结果怎么控制呢）\n\n1\n\nimport java.io.*;\n\n2\n\n3\n\npublic class Test {\n\n4\n\npublic static void main(String[] args) {\n\n5\n\ntry {\n\n6\n\nString str = \"ABCDE”;\n\n7\n\nbyte[] bs = str.getBytes(StandardCharsets.UTF_8);\n\n8\n\nFileOutputStream file = new FileOutputStream(\"test.txt”, true);\n\n9\n\nfile.write(bs);\n\n10\n\nfile.close();\n\n11\n\n} catch(IOException e) {\n\n12\n\nSystem.out.println(e.toString());\n\n13\n\n}\n\n14\n\n}\n\n15\n\n}（你这个是什么样子的思考方法）\n\nA ABCABC\n\nB Test\n\nC ABCDEABCDEABCDE\n\nD ABCDE\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (23, '非0整数的匹配，下列正则表达式正确的是\n\n', 'A ^[0-9]*$\n\nB ^(0|[1-9][0-9]*)$\n\nC ^[1-9][0-9]*$\n\nD (0|[1-9][0-9]*)\n\n', 'C', NULL, NULL, '23、非0整数的匹配，下列正则表达式正确的是\n\nA ^[0-9]*$\n\nB ^(0|[1-9][0-9]*)$\n\nC ^[1-9][0-9]*$\n\nD (0|[1-9][0-9]*)\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (24, '有关类加载器的双亲委派模型说法错误的时（）\n\n', 'A 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载\n\n', 'C', '参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。', NULL, '24、 有关类加载器的双亲委派模型说法错误的时（）\n\nA 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；（类加载机制）\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载（优先机制）\n\n答案：C（自定义类加载器有什么用处呢）（双亲委托机制：\n\n简单来说就是加载一个类进内存，先从系统类加载器找，往上从扩展类中找，往上再从根加载器中找）（可以随心所欲的进行安全校验）（实例加载的时候，就会以子类开始了）', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (25, '对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\n', 'A 使得第idx个参数的值设为val\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n', 'A', 'PreparedStatement的索引是从1开始', NULL, '25、对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\nA 使得第idx个参数的值设为val（这个还是死记硬背吧，和我们平常理解的不一样的）\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n答案：A', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (26, '有关NIO Selector说法错误的是：\n\n', 'A 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n', 'C', 'A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭', NULL, '26、有关NIO Selector说法错误的是：\n\nA 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;（看来机制介绍的还是很清楚的）\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close（buffer里面属性使用都时在NIO的使用，在NIO）（capacity、position、limit）\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (27, '下面锁用的正确的是：\n\n', 'A\nprivate int count=0;\nprivate final Integer lock=new Integer(count);\npublic void doSomething(){\n    Synchronized(lock){\n    Count++;\n    }\n}\n\n B\nprivate final String lock=\"LOCK”;\npublic void doSomething(){\n    synchronized (lock){\n    //..\n    }\n}\n\nC \nBoolean isInitialized=Boolean.FALSE;\npublic void doSomething(){\n    synchronized (isInitialized){\n    //..\n    }\n}\n\n    D\nprivate int count=0;\nprivate final integer lock=count;\npublic void doSomething(){\n    synchronized (lock){\n        lock++;\n    }\n}\n\n', 'A', '一句话，锁不要公用，容易阻塞/死锁', NULL, '27、下面锁用的正确的是：\n\nA\n\n1\n\nprivate int count = 0;\n\n2\n\nprivate final Integer lock = new Integer(count);\n\n3\n\npublic void doSomething() {\n\n4\n\nSynchronized (lock) {\n\n5\n\nCount++;\n\n6\n\n}\n\nB\n\n1\n\nprivate final String lock = \"LOCK”;\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (lock) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nC\n\n1\n\nBoolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (isInitialized) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nD\n\n1\n\nprivate int count = 0;\n\n2\n\nPrivate final integer lock = count;锁必须不能是公共人可以获取的东西\n\n3\n\npublic void doSomething() {\n\n4\n\nsynchronized (lock) {\n\n5\n\nlock++;\n\n6\n\n}\n\n7\n\n}（因为别的程序还要用）\n\n答案：A', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (28, '以下命名风格正确的是：\n\n', 'A enum Gender { male, femal}（形容词）\n\nB class Test {\n\n​private boolean isNotFount;\n\n}\n\nC class Test {\n\n​private String userName;\n\n}\n\nD class Test {\n\n​private static final int NUM_FIVE = 5;\n\n}\n\n', 'C', 'A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对', NULL, '28、 以下命名风格正确的是：\n\nA enum Gender { male, femal}（形容词）\n\nB class Test {\n\n​private boolean isNotFount;\n\n}\n\nC class Test {\n\n​private String userName;\n\n}\n\nD class Test {\n\n​private static final int NUM_FIVE = 5;\n\n}\n\n答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (29, '如下代码执条结果是：\npublic class Foo {\n    public static void main(String[] args) {\n        for (float flt = (float) 1000000000; flt < 1000000010; flt++) {\n            System.out.println(flt);\n        }\n    }\n}', 'A 1000000000​\n  1000000001​\n  1000000002​ \n  ….​\n  1000000010​\n\nB 1000000000.0\n\n​C 输出结果不确定', 'C', 'System.out.println(1000000000f == 1000000010f);//true\n应该是float精度问题？？？', NULL, '29、如下代码执条结果是：1public class Foo {2public static void main(String[] args) {3for (float flt = (float)1000000000;flt < 1000000010; flt++) {4System.out.println(flt);5}6}7}​A 1000000000​1000000001​1000000002​ ….​1000000010​B 1000000000.0​ C 输出结果不确定答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (30, '以下代码片断输出的结果是：（Integer.valueOf()如果数值比较小，还是会复用之前的数据的，intern应该是重建一个integer）public class Demo {    public static void main(String[] args) {        Integer fst = 1;        Integer snd = new Integer(1);        System.out.println(fst == snd);        System.out.println(new Integer(1) == snd);        System.out.println(fst == Integer.valueOf(1));        Integer trd = 256;        System.out.println(trd == Integer.valueOf(256));    }}', 'A false,false,true,falseB false,false,true,trueC false,false,false,falseD true,false,false,false', 'A', NULL, NULL, '30、以下代码片断输出的结果是：（Integer.valueOf()如果数值比较小，还是会复用之前的数据的，intern应该是重建一个integer）1Public class Demo {2Public static void main(String[] args) {3Integer fst = 1;4Integer snd = new Integer(1);5System.out.println(fst == snd);6System.out.println(new Integer(1) == snd);7System.out.println(fst == Integer.valueOf(1));8Integer trd = 256;9System.out.println(trd == Integer.valueOf(256));10}11}A false,false,true,falseB false,false,true,trueC false,false,false,falseD true,false,false,false答案：A', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (31, '关于遮掩，说法不正确的是（其他）\n\n', 'A 如果一个类或者一个包被遮掩了，那么不能通过其简单名引用到它，除非是这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字\n\nB 遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式（遮掩，不是变量名遮住了包名吗）\n\nC 一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内；（不正确，但是只要你能控制命名空间也是可以的）\n\nD 如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上（优先使用变量）。\n\n', 'C', NULL, NULL, '31、 关于遮掩，说法不正确的是（其他）\n\nA 如果一个类或者一个包被遮掩了，那么不能通过其简单名引用到它，除非是这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字\n\nB 遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式（遮掩，不是变量名遮住了包名吗）\n\nC 一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内；（不正确，但是只要你能控制命名空间也是可以的）\n\nD 如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上（优先使用变量）。\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (32, '以下描述错误的是：\n\n', 'A 禁止使用主动GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中\n\nB 将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作（内存泄露）\n\nC 进行IO操作时，应该在try-with-resource或者finally里关闭资源\n\nD 可以在循环之外的节点主动GC（这个什么意思呢）\n\n', 'B', NULL, NULL, '32、以下描述错误的是：\n\nA 禁止使用主动GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中\n\nB 将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作（内存泄露）\n\nC 进行IO操作时，应该在try-with-resource或者finally里关闭资源\n\nD 可以在循环之外的节点主动GC（这个什么意思呢）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (33, '根据安全编码规范，以下代码中正确的时（）（不能和操作耦合在一起去思考）', 'Aassert (Patten.matches(\"[0-9A-Za-z@]+\", dir);Process proc = rt.exec(\"cmd.exe /c \" + dir);BArrayList<String> names;//…assert names.remove(null);Cassert index++ != MAX_LENGTH;  这里的自增操作Dboolean isNullsRemoved = names.remove(null);assert isNullsRemoved // 所以每次都会出现这个情况啊', 'D', '没懂A为啥不对', NULL, '33、根据安全编码规范，以下代码中正确的时（）（不能和操作耦合在一起去思考）A1assert (Patten.matches(\"[0-9A-Za-z@]+”, dir);2Process proc = rt.exec(”cmd.exe /c \" + dir);B1ArrayList<String> names;2//…3assert names.remove(null);C1assert index++ != MAX_LENGTH;  这里的自增操作D1boolean isNullsRemoved = names.remove(null);2assert isNullsRemoved // 所以每次都会出现这个情况啊答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (34, '标识出垃圾后，需要回收，有关回收的说法错误是：\n\n', 'A 复制copy后，即把内存区域分成两个等分，from区域与to区域，都从from区分内存，回收即是把from区域还在使用的内存，copy到to内存,….，比较消耗内存；（看来不同的路线，选择机制还是不一样的）\n\nB 压缩compact，重新整理达在使用的内存，一般做法是把还在使用的内存前移，填充回收空间，留下一大片连续的内存；压缩的问题是开销大；（这块需要反复计算才可以解决）\n\nC Java的GC机制会选择其中一种方法进行垃圾回收；（GC的回收过程中多种回收机制一起处理的结果）\n\nD 消除Sweep，直接清除，方法简单，但是会造成内存碎片，给再分配造成不可抑制的麻烦；（这个缺点是很明显的）\n\n', 'C', NULL, NULL, '34、标识出垃圾后，需要回收，有关回收的说法错误是：\n\nA 复制copy后，即把内存区域分成两个等分，from区域与to区域，都从from区分内存，回收即是把from区域还在使用的内存，copy到to内存,….，比较消耗内存；（看来不同的路线，选择机制还是不一样的）\n\nB 压缩compact，重新整理达在使用的内存，一般做法是把还在使用的内存前移，填充回收空间，留下一大片连续的内存；压缩的问题是开销大；（这块需要反复计算才可以解决）\n\nC Java的GC机制会选择其中一种方法进行垃圾回收；（GC的回收过程中多种回收机制一起处理的结果）\n\nD 消除Sweep，直接清除，方法简单，但是会造成内存碎片，给再分配造成不可抑制的麻烦；（这个缺点是很明显的）\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (35, '执行如下语句，最终会运行什么文件？\n\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\");（看来这个是需要懂OS的命令行机制）\n\n', 'A 仅运行test.bat，并将notepad.exe作为test.bat的参数；\n\nB 仅运行notepad.exe\n\nC 仅运行test.bat\n\nD 运行test.bat和notepﾺﾷad.exe（这个是怎么判断的呢？）\n\n', 'D', NULL, NULL, '35、执行如下语句，最终会运行什么文件？\n\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\");（看来这个是需要懂OS的命令行机制）\n\nA 仅运行test.bat，并将notepad.exe作为test.bat的参数；\n\nB 仅运行notepad.exe\n\nC 仅运行test.bat\n\nD 运行test.bat和notepad.exe（这个是怎么判断的呢？）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (36, '中如何释放掉一个指定占据的内存空间，请选择\n\n', 'A 程序员无法明确强制垃圾回收器运行（这句话说的明确的）\n\nB 调用free()方法（我们无法控制释放那个内存空间）\n\nC 赋值给该对象的引用为null\n\nD 调用System.gc()的方法（）（选择后面最近的空闲时间而已）\n\n', 'A', NULL, NULL, '36、Java中如何释放掉一个指定占据的内存空间，请选择\n\nA 程序员无法明确强制垃圾回收器运行（这句话说的明确的）\n\nB 调用free()方法（我们无法控制释放那个内存空间）\n\nC 赋值给该对象的引用为null\n\nD 调用System.gc()的方法（）（选择后面最近的空闲时间而已）\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (37, '类加载表述正确的是()\n\n', 'A URLClassLoader的签名校验依赖jar包里的公钥，因此不能使用URLClassLoader来校验jar的合法性；（里面可能被人修改过，里面是底层的源码）\n\nB 在JVM中将不同的ClassLoader实例加载的同一个类视为相同的类；（看来不同的加载器生成的类也是不同的）\n\nC 开发者不可以自定义类加载器；\n\n', 'A', NULL, NULL, '37、Java类加载表述正确的是()\n\nA URLClassLoader的签名校验依赖jar包里的公钥，因此不能使用URLClassLoader来校验jar的合法性；（里面可能被人修改过，里面是底层的源码）\n\nB 在JVM中将不同的ClassLoader实例加载的同一个类视为相同的类；（看来不同的加载器生成的类也是不同的）\n\nC 开发者不可以自定义类加载器；\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (38, '以下描述错误的是', 'Apublic String getProductSummary(int index) {    return products[index];}//该代码中index未校验，可能相起数组越界访问BString userName = \"name”;ResultSet rs = st.executeQuery(\"select * from user where name = ‘” + userName + \"’”);//该代码可能会产生SQL注入漏洞（是不是里面的双引号起的作用）CRuntime.getRuntime().exec(\"cmd.exe /c dir ” + args[0]);//该代码可能会引起命令注入DString command = System.getProPerty(\"command”);Runtime.getRuntime().exec(\"command”);//该代码可能会引起OS命令注入（这个和环境变量耦合在一起的使用命令）', 'B', 'B 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验', NULL, '38、以下描述错误的是A1public String getProductSummary(int index) {2return products[index];3}4//该代码中index未校验，可能相起数组越界访问B1String userName = \"name”;2ResultSet rs = st.executeQuery(\"select * from user where name = ‘” + userName + \"’”);3//该代码可能会产生SQL注入漏洞（是不是里面的双引号起的作用）C1Runtime.getRuntime().exec(\"cmd.exe /c dir ” + args[0]);2//该代码可能会引起命令注入D1String command = System.getProPerty(\"command”);2Runtime.getRuntime().exec(\"command”);3//该代码可能会引起OS命令注入（这个和环境变量耦合在一起的使用命令）答案：B', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (39, '以下代码可能导致命令注入的的有()', 'AString encodeIP=HWEncoder.encodeForOS(new WindowsCodec(),args[0]);String cmd=\"cmd.exe /c ping \"+encodeIP;Bif(Pattern.matches(\"[0-9A-Za-z@]+”, dir)) {Process proc=rt.exec(cmd.exec/c\" + dir);}CFile dir=new File(args[0]);if(!validate(dir)){（对文件进行了检查）System.out.println(\"An illegal directory”);}DProcessor proc=rt.exec(\"cmd.exe /c dir ” + args[0]);', 'D', '选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入选项B：使用正则校验，过滤特殊字符选项C：对文件的有效性进行校验选项D：无任何校验，可能导致命令注入', NULL, '39、以下代码可能导致命令注入的的有()A1String encodeIP = HWEncoder.encodeForOS(new WindowsCodec(), args[0]);2String cmd = \"cmd.exe /c ping \" + encodeIP;B1if (Pattern.matches(\"[0-9A-Za-z@]+”, dir)) {2Process proc = rt.exec(cmd.exec /c \" + dir);3}C1File dir = new File(args[0]);2if (!validate(dir)) {（对文件进行了检查）3System.out.println(\"An illegal directory”);4}D1Processor proc = rt.exec(\"cmd.exe /c dir ” + args[0]);答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (40, '关于异常的说法错误的是\n\n', 'A BindException异常泄露时可能造成开放端口列举\n\nB 当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤\n\nC FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构；\n\nD 可以在代码最外层捕获NullPointException防止代码出现预期之外的行为\n\n', 'D', NULL, NULL, '40、关于异常的说法错误的是\n\nA BindException异常泄露时可能造成开放端口列举\n\nB 当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤\n\nC FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构；\n\nD 可以在代码最外层捕获NullPointException防止代码出现预期之外的行为\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (41, '下面关于异常处理的描述错误的是\n\n', 'A FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常（这个也是敏感异常）（DOS攻击）\n\nB 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理\n\nC 输入校验是一个常用的防止通过异常泄露敏感信息的方式；\n\nD 必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户\n\n', 'A', NULL, NULL, '41、下面关于异常处理的描述错误的是\n\nA FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常（这个也是敏感异常）（DOS攻击）\n\nB 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理\n\nC 输入校验是一个常用的防止通过异常泄露敏感信息的方式；\n\nD 必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (42, '关于锁的说法错误的是\n\n', 'A 封包过Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例\n\nB 使用new出来的Integer实例作为对象的内置锁可能导致死锁（new出来的好像没有什么问题）\n\nC 在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁；（这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存）\n\nD Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。（都是用的这两个）\n\n', 'B', NULL, NULL, '42、关于锁的说法错误的是\n\nA 封包过Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例\n\nB 使用new出来的Integer实例作为对象的内置锁可能导致死锁（new出来的好像没有什么问题）\n\nC 在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁；（这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存）\n\nD Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。（都是用的这两个）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (43, '状态变量不包括\n\n', 'A capacity：最大容量\n\nB flag：读写状态位\n\nC position：当前已经读到的字节数\n\nD limit：剩下的字节数（写入的时候奏效）\n\n', 'B', NULL, NULL, '43、 Java IO Buffer状态变量不包括\n\nA capacity：最大容量\n\nB flag：读写状态位\n\nC position：当前已经读到的字节数\n\nD limit：剩下的字节数（写入的时候奏效）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (44, '正则表达式\\[^A-Za-z0-9_\\]与以下哪个表达式等价', '\n\nA \\t\n\nB \\d\n\nC \\W = [^A-Za-z0-9_]（所以大W，都是去反的含义字母和数字）\n\nD \\v\n\nE \\w = [A-Za-z0-9_]\n\n', 'C', NULL, NULL, '44、正则表达式\\[^A-Za-z0-9_\\]与以下哪个表达式等价\n\nA \\t\n\nB \\d\n\nC \\W = [^A-Za-z0-9_]（所以大W，都是去反的含义字母和数字）\n\nD \\v\n\nE \\w = [A-Za-z0-9_]\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (45, '关于sleep()和wait()，以下描述错误的一项是\n\n', 'A sleep不释放对象锁，wait放弃对象锁；\n\nB sleep暂停线程，但监控状态仍然保持，结束后会自动恢复;\n\nC wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态；（准备获取对象锁进入运行状态，是没有获取锁，但是已经进入到了运行状态）\n\nD sleep是线程类（Thread）的方法，wait是Object类的方法（是正确的）\n\n', 'C', NULL, NULL, '45、关于sleep()和wait()，以下描述错误的一项是\n\nA sleep不释放对象锁，wait放弃对象锁；\n\nB sleep暂停线程，但监控状态仍然保持，结束后会自动恢复;\n\nC wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态；（准备获取对象锁进入运行状态，是没有获取锁，但是已经进入到了运行状态）\n\nD sleep是线程类（Thread）的方法，wait是Object类的方法（是正确的）\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (46, '关于多线程并发如下说法正确的是\n\n', 'A 对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁（有道理）\n\nB 能用无锁数据结构，就不要用锁\n\nC 能用对象锁，就不要用类锁\n\nD 能锁区块，就不要锁方法体（尽可能的减少影响的方法）\n\n', 'ABCD', NULL, NULL, '46、关于多线程并发如下说法正确的是\n\nA 对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁（有道理）\n\nB 能用无锁数据结构，就不要用锁\n\nC 能用对象锁，就不要用类锁\n\nD 能锁区块，就不要锁方法体（尽可能的减少影响的方法）\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (47, '方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流（流也会被分别清空吗）（一会再次来解决这个）\n\n', 'A 错误流\n\nB 监控流\n\nC 输出流\n\nD 输入流\n\n', 'ACD', NULL, NULL, '47、Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流（流也会被分别清空吗）（一会再次来解决这个）\n\nA 错误流\n\nB 监控流\n\nC 输出流\n\nD 输入流\n\n答案：ACD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (48, '属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是（）', 'A.public class GpsLocation implements Serializable {    private double from;    private double to;    private String id; // non-sensitive field    // other content}（完全裸露在外）B.public class GpsLocation implements Serializable {    private double from;    private double to;    private String id; // non-sensitive field    // other content        private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"id\", String.class)};}（看来它认为from和to是敏感信息，明确了只能序列化的字段）C.public class GpsLocation implements Serializable {    private volatile double from;    private volatile double to;    private String id; // non-sensitive field    // other content}D .public class GpsLocation implements Serializable {    private transient double from;    private transient double to;    private String id; // non-sensitive field    // other content}', 'BD', '防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确', NULL, '48、属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是（）A.1public class GpsLocation implements Serializable{2private double from;3private double to;4private String id; // non-sensitive field5// other content6}（完全裸露在外）B.1public class GpsLocation implements Serializable{2private double from;3private double to;4private String id; // non-sensitive field5// other content6private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"id\", String.class)};7}（看来它认为from和to是敏感信息，明确了只能序列化的字段）C.1public class GpsLocation implements Serializable{2private volatile double from;3private volatile double to;4private String id; // non-sensitive field5// other content6}D.1public class GpsLocation implements Serializable{2private transient double from;3private transient double to;4private String id; // non-sensitive field5// other content6}答案：BD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (49, '下列单例实现正确的是', 'A.package apitest;public final class Helper {    public Helper() {    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {（这是双重锁机制带来的问题导致的）        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper();                }            }        }        return helper;    }}B.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        Helper h = helper;        if (h == null) {            synchronized (this) {                h = helper;（这个是什么含义呢）                if (h == null) {                    h = new Helper(42);                    helper = h;                }            }        }        return h;    }}C.public final class Helper {    private final int n;    public Helper(int n) {        this.n = n;    }}final class Foo {    private Helper helper = null;    public Helper getHelper() {        if (helper == null) {            synchronized (this) {                if (helper == null) {                    helper = new Helper(42);                }            }        }        return helper;    }}D.public final class Helper {    public Helper() {}}final class Foo {    private static class Holder{        static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;    }    public Helper getInstance(){        return Holder.helper;    }}', 'BD', '选项A的private Helper helper = null; 没有加volatile进行修饰，可能线程A和线程B都进入了第一个判断，但是A先获取锁，B被阻塞，A释放后创建了helper对象但是B又能获取锁创建一个新的helper对象违背单例模式原则选项B在获取锁后重新赋值了h的值类似与volatile通知线程修改副本值，所以即使没有加入volatile修饰也是可行的选项C同选项A一样选项D是饿汉式非懒加载，但是线程安全故选择：BD', NULL, '49、下列单例实现正确的是A.1public final class Helper{2public Helper() { }3}4final class Foo{5private Helper helper = null;6public Helper getHelper(){（这是双重锁机制带来的问题导致的）7if(helper ==null){()8synchronized (this){9if(helper ==null){10helper = new Helper();11}12}13}14return helper;15}16}B.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10Helper h =helper;11if (h == null) {12synchronized (this) {13h=helper;（这个是什么含义呢）14if (h == null) {15h = new Helper(42);16helper = h;17}18}19}20return h;21}22}C.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10if (helper == null) {11synchronized (this) {12if (helper == null) {13helper = new Helper(42);14}15}16}17return helper;18}19}D.1public final class Helper {2public Helper() {}3}4final class Foo {5private static class Holder{6static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;7}8public Helper getInstance(){9return Holder.helper;10}11}答案：BD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (50, '有关线程池关闭 说明正确的有\n\n', 'A. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，指导线程池中等待的任务全部处理完\n\nB. 执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出\n\nC. 执行shutdown方法中，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出\n\nD. 执行shutdownNow方法后，不能能再往线程池中添加任务，线程池视图停止所有正在执行的线程，不再处理池中等待的任务\n\n', 'CD', NULL, NULL, '50、有关线程池关闭 说明正确的有\n\nA. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，指导线程池中等待的任务全部处理完\n\nB. 执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出\n\nC. 执行shutdown方法中，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出\n\nD. 执行shutdownNow方法后，不能能再往线程池中添加任务，线程池视图停止所有正在执行的线程，不再处理池中等待的任务\n\n答案：CD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (51, '哪些是同步的？\n\n', 'A. TreeSet\n\nB. HashTable\n\nC. Vector\n\nD. LinkedList\n\n', 'BC', NULL, NULL, '51、哪些是同步的？\n\nA. TreeSet\n\nB. HashTable\n\nC. Vector\n\nD. LinkedList\n\n答案：BC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (52, '已知如下代码public static void main(String[] args) {	int nr = 5;	do{		System.out.print(nr)	}while(--nr>5);	System.out.print(\"finished\");}执行后的输出包含什么？', 'A. 5B. 4C. finishedD. 6', 'AC', NULL, NULL, '52、已知如下代码1public static void main(String[] args) {2int nr = 5;3do{4System.out.print(nr)5}while(--nr>5);6System.out.print(\"finished\");7}执行后的输出包含什么？A. 5B. 4C. finishedD. 6答案：AC', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (53, '正则表达式A*B可以匹配', '\n\nA. ACD\n\nB. AAB\n\nC. A\n\nD. AB\n\n', 'BD', NULL, NULL, '53、正则表达式A*B可以匹配\n\nA. ACD\n\nB. AAB\n\nC. A\n\nD. AB\n\n答案：BD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (54, '关于File的描述，正确的是?\n\n', 'A. File实例 不能用于封装目录只用于封装文件\n\nB. 创建一个File类的实例将导致打开指定文件进行读写（按照它的意思，你不执行读写，是不会生效的）\n\nC. File实例封装了指定文件的信息\n\nD. File类位于jav.io包中（这个只能死记硬背）\n\n', 'CD', NULL, NULL, '54、关于File的描述，正确的是?\n\nA. File实例 不能用于封装目录只用于封装文件\n\nB. 创建一个File类的实例将导致打开指定文件进行读写（按照它的意思，你不执行读写，是不会生效的）\n\nC. File实例封装了指定文件的信息\n\nD. File类位于jav.io包中（这个只能死记硬背）\n\n答案：CD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (55, '关于主动调用gc方法的描述，下列说法正确的是\n\n', 'A. 在频率/周期性的逻辑中更要尽量 避免主动GC的调用\n\nB. 在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险（说的有道理）\n\nC. 调用主动GC方法后，系统立即进行垃圾回收操作（系统也要找机会才行）\n\nD. 如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间\n\n', 'ABD', NULL, NULL, '55、关于主动调用gc方法的描述，下列说法正确的是\n\nA. 在频率/周期性的逻辑中更要尽量 避免主动GC的调用\n\nB. 在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险（说的有道理）\n\nC. 调用主动GC方法后，系统立即进行垃圾回收操作（系统也要找机会才行）\n\nD. 如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间\n\n答案：ABD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (56, '关于数据校验的说法正确的是（）\n\n', 'A. 在对不可信数据进行校验时，禁止使用assert语句（）\n\nB. \"白名单\"方式净化的方式包括删除，编码 ，替换\n\nC. \"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新 ，该校验方式就会很快过时\n\nD. 尽可能使用接收一直合法数据的白名单策略（这个我是记得的）\n\n', 'ABCD', NULL, NULL, '56、关于数据校验的说法正确的是（）\n\nA. 在对不可信数据进行校验时，禁止使用assert语句（）\n\nB. \"白名单\"方式净化的方式包括删除，编码 ，替换\n\nC. \"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新 ，该校验方式就会很快过时\n\nD. 尽可能使用接收一直合法数据的白名单策略（这个我是记得的）\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (57, '语言中，如果编写一个多线程程序，可以使用的方法是\n\n', 'A. 扩展类Thread\n\nB. 实现Runnable接口（这个完全就是基本功）\n\nC. 实现接口Thread\n\nD. 扩展类Runnable\n\n', 'AB', NULL, NULL, '57、Java语言中，如果编写一个多线程程序，可以使用的方法是\n\nA. 扩展类Thread\n\nB. 实现Runnable接口（这个完全就是基本功）\n\nC. 实现接口Thread\n\nD. 扩展类Runnable\n\n答案：AB', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (58, '仅保存口令hash，不加盐的缺陷有\n\n', 'A. 攻击者可以使用实现计算好的哈希列表在几秒钟之内破解口令\n\nB. 加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加\n\nC. 没有盐值，攻击者可以根据哈希值反向解密出原始口令（hash不可逆）\n\nD. 由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候（难道是有什么规律吗）\n\n', 'ABD', NULL, NULL, '58、仅保存口令hash，不加盐的缺陷有\n\nA. 攻击者可以使用实现计算好的哈希列表在几秒钟之内破解口令\n\nB. 加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加\n\nC. 没有盐值，攻击者可以根据哈希值反向解密出原始口令（hash不可逆）\n\nD. 由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候（难道是有什么规律吗）\n\n答案：ABD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (59, '类加载器说法正确的是：\n\n', 'A. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\n\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\n\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定 的路径中的所有类\n\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader\n\n', 'ABC', NULL, NULL, '59、类加载器说法正确的是：\n\nA. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\n\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\n\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定 的路径中的所有类\n\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader\n\n答案：ABC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (60, '关于异常，下列说法正确的是：\n\n', 'A. 如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码\n\nB. 方法抛出的异常，应该与本身的抽象层次相对应\n\nC. 对可容错处理的情况使用受检异常，对编程错误使用运行时异常\n\nD. 一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中年记录每个抛出的异常及其条件\n\n', 'BCD', NULL, NULL, '60、关于异常，下列说法正确的是：\n\nA. 如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码\n\nB. 方法抛出的异常，应该与本身的抽象层次相对应\n\nC. 对可容错处理的情况使用受检异常，对编程错误使用运行时异常\n\nD. 一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中年记录每个抛出的异常及其条件\n\n答案：BCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (61, '栈帧的大小在什么时候确定的？\n\n', 'A. 程序代码编译时\nB. 类加载时\nC. 运行调用时\n', 'A，程序代码编译时确定。', NULL, NULL, '61.栈帧的大小在什么时候确定的？\n\nA. 程序代码编译时\nB. 类加载时\nC. 运行调用时\n答案：A，程序代码编译时确定。', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (62, 'gc主要的回收的内存区域是哪块', 'A. 堆区\r\n\r\nB. 方法区', 'AB', NULL, NULL, 'A. 堆区\r\n\r\nB. 方法区', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (63, '如下四种数组声明方式，哪种不正确？\n\n', 'A int[] hello1 = {1,2,3,4};\nB int[] hello2 = new int[4] {1,2,3,4};\nC int[] hello3 = new int[] {1,2,3,4};\nD int[] hello4 = new int[4];\n\n', 'B', NULL, NULL, '63.如下四种数组声明方式，哪种不正确？\n\nA int[] hello1 = {1,2,3,4};\nB int[] hello2 = new int[4] {1,2,3,4};\nC int[] hello3 = new int[] {1,2,3,4};\nD int[] hello4 = new int[4];\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (64, '哪些数据类型能直接输出？\n\na. int[] test = {1,2,3,4,5}\n\nb. List list = new LinkedList<>();\n\nc. Map<Integer,Integer> map = new HashMap<>();\n\nd. List list = new ', 'ArrayList<>();\n\n', 'a是无法直接输出的System.out.println(Arrays.toString(test))才可以输出;', NULL, NULL, '65.哪些数据类型能直接输出？\n\na. int[] test = {1,2,3,4,5}\n\nb. List list = new LinkedList<>();\n\nc. Map<Integer,Integer> map = new HashMap<>();\n\nd. List list = new ArrayList<>();\n\n答案：a是无法直接输出的System.out.println(Arrays.toString(test))才可以输出;', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (65, '与表达式 Integer a = 2;等价的类型是哪个？\n\n', 'A. int b = Integer.parseInt(“2”);\n\nB. Integer b = Integer.valueOf(“2”);\n\n', 'B', NULL, NULL, '66.与表达式 Integer a = 2;等价的类型是哪个？\n\nA. int b = Integer.parseInt(“2”);\n\nB. Integer b = Integer.valueOf(“2”);\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (66, '精度最高的数据类型？\n\n', 'A. int\nB. long\nC.BigInteger\nD.byte\n', 'C\n\n和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', NULL, NULL, '70.精度最高的数据类型？\n\nA. int\nB. long\nC.BigInteger\nD.byte\n答案：C\n\n和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (67, '创建了几个对象？\n\n', 'A. 4个\n\nB. 1个\n\nC. 2个\n\nD.3个\n\n', 'B', NULL, NULL, '71.String str = “a” + “b” + “c” + “d”;创建了几个对象？\n\nA. 4个\n\nB. 1个\n\nC. 2个\n\nD.3个\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (68, '下列代码示例中，加锁范围可能为全局而非当前类示例内的有（）？\n\n', 'A. private final String lock = new String(“LOCK”).intern();\n\nB. private final String lock = “lock”\n\nC. private final String lock = new String(“LOCK”);\n\nD. private final Boolean = Boolean.TRUE;\n\npublic void doSomthing() {\n\nsynchronized(lock) {\n\n}\n\n}\n\n', 'ABD', NULL, NULL, '74.下列代码示例中，加锁范围可能为全局而非当前类示例内的有（）？\n\nA. private final String lock = new String(“LOCK”).intern();\n\nB. private final String lock = “lock”\n\nC. private final String lock = new String(“LOCK”);\n\nD. private final Boolean = Boolean.TRUE;\n\npublic void doSomthing() {\n\nsynchronized(lock) {\n\n}\n\n}\n\n答案：ABD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (69, '以下异常列表哪些属于敏感异常（）？\n\n', 'A. java.io.FileNotFoundException\n\nB. java.net.BindException\n\nC. java.util.ConcurrentModificationException\n\nD. java.sql.SQLException\n\nE. java.lang.NullPointerException\n\nF. java.lang.IllegalArgumentException\n\n', 'ABCD', '', NULL, '77.以下异常列表哪些属于敏感异常（）？\n\nA. java.io.FileNotFoundException\n\nB. java.net.BindException\n\nC. java.util.ConcurrentModificationException\n\nD. java.sql.SQLException\n\nE. java.lang.NullPointerException\n\nF. java.lang.IllegalArgumentException\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (70, '下列哪个数据结构不是继承自集合Collection类？\n\n', 'A. List B. Set C. Queue D. Map\n\n', 'D', NULL, NULL, '78.下列哪个数据结构不是继承自集合Collection类？\n\nA. List B. Set C. Queue D. Map\n\n答案： D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (71, '不修改Map说的是什么，如下语句是否可以正确执行？ \nMap<Integer,String> test = new HashMap<>();\ntest.put(1,“hello”);\ntest.put(2,“unmodifiable”);\nMap<Integer,String> umap = Collections.unmodifiableMap(test);\numap.clear();\n', 'A 正确\nB 错误\n', 'B', NULL, NULL, '79.不修改Map说的是什么，如下语句是否可以正确执行？ \nMap<Integer,String> test = new HashMap<>();\ntest.put(1,“hello”);\ntest.put(2,“unmodifiable”);\nMap<Integer,String> umap = Collections.unmodifiableMap(test);\numap.clear();\nA 正确\nB 错误\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (72, '单选）下列哪种情况可以终止当前线程的运行？\n\n', 'A. 当一个优先级高的线程进入就绪状态时\nB. 当该线程调用sleep()方法时\nC. 当创建一个新线程时\nD. 抛出一个异常时\n\n', 'D', NULL, NULL, '82.（单选）下列哪种情况可以终止当前线程的运行？\n\nA. 当一个优先级高的线程进入就绪状态时\nB. 当该线程调用sleep()方法时\nC. 当创建一个新线程时\nD. 抛出一个异常时\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (73, '哪个类写操作是线程安全的？\n\n', 'A.FileWriter\n\nB.RandomAccessFile\n\nC.FileOutputStream\n\nD.FileChannel\n\n', 'D', 'http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png', NULL, '83.哪个类写操作是线程安全的？\n\nA.FileWriter\n\nB.RandomAccessFile\n\nC.FileOutputStream\n\nD.FileChannel\n\n答案： D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (74, '以下NIO语句是否有错误？\n\n', 'A.大二进制文件读入\nB. 小二进制文件读入\nC. 小文本按行读入\nD. 小文本按字节数读入\nE. 结尾插入数据采用.APPEND而不是 .CREATE\n\n', 'E', NULL, NULL, '84.以下NIO语句是否有错误？\n\nA.大二进制文件读入\nB. 小二进制文件读入\nC. 小文本按行读入\nD. 小文本按字节数读入\nE. 结尾插入数据采用.APPEND而不是 .CREATE\n\n答案：E', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (75, '关于DataSource的说法错误的是（）\n\n', 'A． DataSource是用于获取数据库链接的接口。\n\nB． DataSource对象的属性不可以修改。\n\nC． DataSource主要有三种类型实现：基本实现、连接池实现、分布式事务实现。\n\nD． 通过DataSource对象访问的驱动程序本身不会向DriverManager注册。\n', 'B', NULL, NULL, '85.关于DataSource的说法错误的是（）\n\nA． DataSource是用于获取数据库链接的接口。\n\nB． DataSource对象的属性不可以修改。\n\nC． DataSource主要有三种类型实现：基本实现、连接池实现、分布式事务实现。\n\nD． 通过DataSource对象访问的驱动程序本身不会向DriverManager注册。\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (76, '单选）如下操作属于中间结果的是（）\n\n', 'A. reduce() -终端操作\n\nB. map() - 中间操作\n\nC. forEach() -终端操作\n\nD. stream() -创建初始stream，还未启动中间操作和最终终止操作\n\n', 'B', NULL, NULL, '86.（单选）如下操作属于中间结果的是（）\n\nA. reduce() -终端操作\n\nB. map() - 中间操作\n\nC. forEach() -终端操作\n\nD. stream() -创建初始stream，还未启动中间操作和最终终止操作\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (77, '关于Optional说法正确的是？\n\n', 'A. Optional可以被赋值为null\n\nB. Optional.of()可以用null做参数，返回Optional.empty()\n\nC. Optional.ofNullable(obj),obj不为null时直接调用Optional.of(obj)\n\nD. Optional.of()可以放置集合或对象。\n\n', 'CD', NULL, NULL, '87.关于Optional说法正确的是？\n\nA. Optional可以被赋值为null\n\nB. Optional.of()可以用null做参数，返回Optional.empty()\n\nC. Optional.ofNullable(obj),obj不为null时直接调用Optional.of(obj)\n\nD. Optional.of()可以放置集合或对象。\n\n答案：CD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (78, '单选）Java8 中stream流的概念和使用问题。如下选项，哪个是对的（）\n\n', 'A．stream 流的数据ﾷ源只能是数组、容器、文件\n\nB． stream 流跟迭代器一样，使用完再次使用时需要重新生成\n\nC. stream的map是中间结果???\n\nD. ???\n\n', 'B', NULL, NULL, '88.（单选）Java8 中stream流的概念和使用问题。如下选项，哪个是对的（）\n\nA．stream 流的数据源只能是数组、容器、文件\n\nB． stream 流跟迭代器一样，使用完再次使用时需要重新生成\n\nC. stream的map是中间结果???\n\nD. ???\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (79, '变量命名符合规范的有哪些？\n\n', 'A. private boolean isNotFound;\n\nB. enum {male,female}\n\nC. private String userName;\n\nD. private static final int NUM_FIVE = 5;\n\n', 'C', NULL, NULL, '89.变量命名符合规范的有哪些？\n\nA. private boolean isNotFound;\n\nB. enum {male,female}\n\nC. private String userName;\n\nD. private static final int NUM_FIVE = 5;\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (80, '下面字段声明中哪一个在interface主体内是合法的? （）\n\n', 'A.private final static int answer = 42;\n\nB.public static int answer = 42;\n\nC.final static answer = 42;\n\nD.int answer;\n\n', 'B', NULL, NULL, '91.下面字段声明中哪一个在interface主体内是合法的? （）\n\nA.private final static int answer = 42;\n\nB.public static int answer = 42;\n\nC.final static answer = 42;\n\nD.int answer;\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (81, '禁止采用如下哪些算法进行口令加密？\n\n', 'A. RSA\n\nB. DES\n\nC. SKIPJACK\n\nD.MD5\n\n', 'BD', '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', NULL, '92.禁止采用如下哪些算法进行口令加密？\n\nA. RSA\n\nB. DES\n\nC. SKIPJACK\n\nD.MD5\n\n答案：BD，迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 1, 0, 0);
INSERT INTO `question` VALUES (82, '常见敏感异常：(考了原题)\n\n', 'A java.io.FileNotFoundException 泄露文件系统结构和文件名列举\n\nB java.util.jar.JarException 泄露文件系统结构\n\nC java.util.MissingResourceException 资源列举\n\nD java.security.acl.NotOwnerException 所有人列举\n\nE java.util.ConcurrentModificationException 可能提供线程不安全的代码信息\n\nF javax.naming.InsufficientResourcesException 服务器资源不足（可能有利于DoS攻击）\n\nG java.net.BindException 当不信任客户端能够选择服务器端口时造成开放端口列举\n\nH java.lang.OutOfMemoryError DoS\n\nI java.lang.StackOverflowError DoS\n\nO java.sql.SQLException 数据库结构，用户名列举\n', 'ABCDEFGHIO', NULL, NULL, '94.常见敏感异常：(考了原题)\n\nA java.io.FileNotFoundException 泄露文件系统结构和文件名列举\n\nB java.util.jar.JarException 泄露文件系统结构\n\nC java.util.MissingResourceException 资源列举\n\nD java.security.acl.NotOwnerException 所有人列举\n\nE java.util.ConcurrentModificationException 可能提供线程不安全的代码信息\n\nF javax.naming.InsufficientResourcesException 服务器资源不足（可能有利于DoS攻击）\n\nG java.net.BindException 当不信任客户端能够选择服务器端口时造成开放端口列举\n\nH java.lang.OutOfMemoryError DoS\n\nI java.lang.StackOverflowError DoS\n\nO java.sql.SQLException 数据库结构，用户名列举\n答案：ABCDEFGHIO', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (83, '不能被哪些修饰符修饰？\n\n', 'A: private\n\nB: public\n\nC: final\n\nD: abstract\n\n', 'AC', NULL, NULL, '95.Interface不能被哪些修饰符修饰？\n\nA: private\n\nB: public\n\nC: final\n\nD: abstract\n\n答案：AC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (84, '正则匹配\"^[a-zA-Z0-9_]+@[(a-zA-Z)+.]+com$\"，哪些是匹配的？ \n\n', 'A) abc@host.com\n\nB) abc_@host.com\n\nC) abc@host.org.com\n\nD) abc_@host+com\n\n', 'ABCD', NULL, NULL, '96.正则匹配\"^[a-zA-Z0-9_]+@[(a-zA-Z)+.]+com$\"，哪些是匹配的？ \n\nA) abc@host.com\n\nB) abc_@host.com\n\nC) abc@host.org.com\n\nD) abc_@host+com\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (85, '如下描述错误的是：\n\n', 'A) StackOverflowError 是堆栈内存溢出\n\nB) OutOfMemoryError：Perm Gen 是老年代内存溢出\n\nC) Java Heap Space溢出时，会导致所有线程暂停工作\n\n', 'B', NULL, NULL, '97.如下描述错误的是：\n\nA) StackOverflowError 是堆栈内存溢出\n\nB) OutOfMemoryError：Perm Gen 是老年代内存溢出\n\nC) Java Heap Space溢出时，会导致所有线程暂停工作\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (86, '76.能够产生DoS攻击的敏感异常有哪些（）？', 'A. Java.lang.OutOfMemoryError\r\n\r\nB. Java.lang.StackOverflowError\r\n\r\nC. javax.naming.InsufficientResourcesException\r\n\r\nD. java.util.jar.JarException', 'ABC', NULL, NULL, '76.能够产生DoS攻击的敏感异常有哪些（）？\r\n\r\nA. Java.lang.OutOfMemoryError\r\n\r\nB. Java.lang.StackOverflowError\r\n\r\nC. javax.naming.InsufficientResourcesException\r\n\r\nD. java.util.jar.JarException\r\n\r\n答案: ABC', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (87, '关于RandomAccessfile的说法错误的是？', 'A 内部基于指针形式可以随机读写文件\r\nB 可以通过RandomAccessFile的FileChannel间进行mmap操作\r\nC RandomAccessFile继承InputStream和OutputStream\r\nD RandomAccessFile只能对文件进行操作\r\nE 支持r,rw,rws,rwd四种模式', 'C', NULL, NULL, '关于RandomAccessfile的说法错误的是？ \r\nA 内部基于指针形式可以随机读写文件\r\nB 可以通过RandomAccessFile的FileChannel间进行mmap操作\r\nC RandomAccessFile继承InputStream和OutputStream\r\nD RandomAccessFile只能对文件进行操作\r\nE 支持r,rw,rws,rwd四种模式\r\n\r\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (88, '哪个类写操作是线程安全的？', 'A. FileWriter\nB. RandomAccessFile\nC. FileOutputStream\nD. FileChannel', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (89, '以下代码的执行结果\nchar alpha = \'A\';\nint foo = 65;\nboolean trueExp = true;\nSystem.out.println(trueExp ? alpha : 0);\nSystem.out.println(trueExp ? alpha : foo);', 'A、A A\nB、65 65\nC、A 65\nD、65 A', 'C', '参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (90, '下面代码执行结果是？ \nTreeSet<Person> personSet = new TreeSet<>((o1, o2) -> o1.age - o2.age);\npersonSet.add(new Person(\"zhao\", 2));\npersonSet.add(new Person(\"qian\", 4));\npersonSet.add(new Person(\"sun\", 1));\npersonSet.add(new Person(\"li\", 4));\nSystem.out.println(personSet);', 'A sun zhao li qian\nB sun zhao qian li\nC sun zhao qian\nD sun zhao li', 'C', '在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (91, '属于经过验证、安全的、公开的加密算法的是', 'A、AES的ECB模式\nB、RSA\nC、DSA/ECDSA\nD、加入盐值的SHA256\nE、DES', 'BCD', '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (92, '输入校验不可以防止以下哪种漏洞？', 'A. CSRF\nB. SQL注入\nC. XSS\nD. XML注入', 'AC', '有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (93, '以下关于异常说法正确的是', 'A、Throwable是所有Error或Exception的超类\nB、只有是Exception或Exception子类，才能被catch\nC、Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError\nD、编译器会强制要求使用者捕获RuntimeException或申明抛出', 'AC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 1, 0, 0);
INSERT INTO `question` VALUES (94, '下面代码运行结果是？\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"aa:\" + func());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private static int func() throws Exception {\n        for (int i = 0; i < 1; i++) {\n            try {\n                throw new Exception(\"bb\");\n            } catch (Exception e) {\n                throw e;\n            } finally {\n                continue;\n            }\n        }\n        return 0;\n    }', 'A、aa:0\nB、抛出异常\nC、编译错误\nD、既打印aa:0 同时抛出异常', 'A', '这里finally的continue使得catch中的throw e无效了', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 3, 0);
INSERT INTO `question` VALUES (95, '关于下面代码中shutdown方法说法正确的是\npublic static void main(String[] args) throws Exception {\n    ExecutorService executorService = Executors.newFixedThreadPool(10);\n    for (int i = 0; i < 100; i++) {\n        executorService.submit(new Task());\n    }\n    executorService.shutdown();\n    static class Task extends Thread {\n        @Override\n        public void run() {\n        }\n    }\n}', 'A， 线程池不再接收新的任务，队列中等待任务不会执行\nB， 线程池终止正在执行的线程\nC， 线程池终止正在执行的线程，和B差不多\nD， 线程池不再接收新的任务，队列中等待的任务会执行', 'D', 'shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 3, 0);
INSERT INTO `question` VALUES (96, '以下哪些在接收到Thread.interrupt()会抛出InterruptedException异常', 'A、Thread.sleep()\nB、java.net.Socket的阻塞方法\nC、java.nio.channels.SocketChannel的阻塞方法\nD、Thread.wait()', 'ACD', '在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (97, '以下代码中，可以被gc回收的对象有\nclass A {\n \n}\n \npublic class Test {\n    private static A staticA = new A();\n    public static final String CONSTANT = \"i am a string\";\n    public static void main(String[] args) {\n        A innerA = new A();\n    }\n}', 'A、staticA\nB、CONSTANT\nC、“i am a string”\nD、innerA', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (98, '栈帧的内部结构', 'A.动态链接\nB.局部变量表\nC.操作数栈\nD.方法返回地址', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (99, '默认jvm参数运行时，会做哪些优化？', 'A. JITTest.doubleIndex被内联\nB. JITTest.doubleIndex会被编译成机器码执行\nC. JITTest.sum会被编译成机器码执行\nD. 拆箱和装箱', 'ABC', '默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 1, 0, 0);
INSERT INTO `question` VALUES (100, '下列有关Java反射的说法 错误 的是：', 'A 反射可以获取Method，通过invoke进行方法的调用；\nB 反射不可以直接通过getField获取私有成员的值；\nC 反射可以获取注解（@Target为Runtime）信息；\nD 反射可以获取类的构造器；', 'C', 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (101, '下面代码执行结果？\npublic class Object1 {\n    private String name=\"java\";\n    public static void main(String[] args)\n        throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        Object1 object1 = Object1.class.getDeclaredConstructor().newInstance();\n        for (Field declaredField : Object1.class.getDeclaredFields()) {\n            System.out.println(declaredField.get(object1));\n        }\n\n        Object2 object2 = Object2.class.getDeclaredConstructor().newInstance();\n        for (Field declaredField : Object2.class.getDeclaredFields()) {\n            System.out.println(declaredField.get(object2));\n        }\n    }\n}\nclass Object2{\n    private String name=\"java\";\n}', 'A、抛出异常\nB、java\nC、java 抛出异常\nD、java java', 'C', '这个暂时记住先。。。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (102, '以下代码输出：\nclass Parent {\n    public int a = 100;\n    private int b = 200;\n    protected int c =300;\n    public int f() {\n        return 10;\n    }\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException {\n        Field[] fields = Parent.class.getDeclaredFields();\n        System.out.println(fields.length);\n \n        Field[] fields1 = Parent.class.getFields();\n        System.out.println(fields1.length);\n    }\n}', 'A、1 3\nB、3 1\nC、1 1\nD、3 3', 'B', 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (103, '关于Optional说法正确的是？', 'A. Optional可以被赋值为null\nB. Optional.of()可以用null做参数，返回Optional.empty()\nC. Optional.ofNullable(obj)，obj不为null时直接调用Optional.of(obj)\nD. Optiona.of()可以放置集合或对象。', 'CD', 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (104, '父类的哪个不能被子类隐藏 ', 'A. 私有方法\nB. 属性\nC. 内部类\nD. 静态方法', 'A', '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (105, '以下代码输出什么\nString strTxt = \"123\\\\d\";\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'A 123456 123456 123456\nB 123456 123\\\\d 123456\nC 123\\\\d 123456 123\\\\d\nD 123\\d  123456 123\\d\nE 456456456\\d 123456 123456', 'E', '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (106, '关于函数重写和重载，说法正确的是', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'ACD', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (107, '根据通用规范，方法注释中不应出现如下', 'A、线程安全\nB、修改日期\nC、性能约束\nD、api特性、原理', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (108, '下面说法不正确的是：', '\nA、避免文件过长，不超过2000行（非空非注释行）\nB、一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔\nC、import包应当按照先华为公司，安卓、其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组\nD、一个类或接口的声明部分应当按照类变量、实例变量、构造器、方法的顺序出现，且用空行分隔', 'C', '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (109, '以下说法不正确的是？', 'A、Integer i1 = 10; Integer i2 = 10; i1和i2指向同一个对象\n\nB、整数型包装类型应使用equals做相等的比较\n\nC、基本类型优于包装类型\n\nD、浮点型包装类型建议使用equals或flt.compareTo(another)==0做相等的比较', 'D', '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (110, '以下说法正确的是', 'A、class Swan {\n    public static void fly() {\n        System.out.println(\"swan can fly ...\");\n    }\n}\nclass UglyDuck extends Swan {\n    public static void fly() {\n        System.out.println(\"ugly duck can\'t fly ...\");\n    }\n}\npublic class TestFly {\n    public static void main(String[] args) {\n        Swan swan = new Swan();\n        Swan uglyDuck = new UglyDuck();\n        swan.fly();\n        uglyDuck.fly();\n    }\n}\n输出：\nswan can fly …\nUglyDuck can fly …\n\nB、class WhoKnows {\n    static String sentence = \"I don\'t know.\";\n    public static void main(String[] args) {\n        String sentence = \"I know!\";\n        System.out.println(sentence);\n    }\n}\n输出\"I know!\"\n\nC、public class Obscure {\n    static String System;\n    public static void main(String[] args) {\n        System.out.println(\"hello, obscure world!\");\n    }\n}\n代码输出\"hello, obscure world!\"\n', 'B', 'A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (111, '以下代码正确的是：', 'A   String[] arr = new String[]{\"1\",\"2\",\"3\",\"4\",\"5\"};\n\nList<String> list =Arrays.asList(arr);\n\nlist.remove(\"5\");\n\nlist.add(\"6\");\n\nB   Map<String,String> map = new HashMap<>();\n\nmap.put(\"1\",\"a\");\n\nmap.put(\"2\",\"b\");\n\nList<String> list = new ArrayList<>();\n\nlist.addAll(map.values());\n\nlist.addAll(Collections.singleton(\"c\"));\n\nC   List<String> list = Collections.emptyList();\n\nlist.add(\"1\");\n\nD   List<String> list = new ArrayList<>();\n\nlist.add(\"1\");\n\nlist.add(\"2\");\n\nArrayList<String> subList = (ArrayList<String>) list.subList(0,0);', 'B', 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (112, '将list转换为数组时最佳SIZE\nList<String> list = new ArrayList<>(DEFAULT_CAPACITY);\n\nlist.add(\"1\");\n\nlist.add(\"2\");\n\nString[] array = list.toArray(new String[SIZE]);', 'A、0  \nB、1  \nC、2 \nD、3', 'A', '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (113, '以下说法正确的是', 'A、建议使用String存储敏感数据，使用结束后立即赋为空\n\nB、使用java.net.Socket类在不安全的传输通道中传输敏感数据\n\nC、调用SecurityManager执行的安全检查，进行安全检查的方法必须声明为private或final\n\nD、编写自定义类加载器时，需要复写getPermissions()方法时，可以忽略了基类的getPermissions()', 'C', 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (114, '以下代码输出什么\nMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>(16,0.75f,true){\n@Override\nprotected boolean removeEldestEntry(Map.Entry eldest){\n        return size()\n> 5;\n}\n\n};\n\nfor(int i = 0; i < 10; i++){\nmap.put(i,i);\n\n}\n\nmap.get(6);\n\nSystem.out.println(map.keySet());', 'A、[5,6,7,8,9]\n\nB、[9,8,7,6,5]\n\nC、[5,7,8,9,6]\n\nD、[6,5,7,8,9] ', 'C', '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (115, '以下代码返回值为\nclass Point {\n    private int x;\n\n    public static void main(String[] args) {\n        System.out.println(test1().x);\n        System.out.println(test2());\n        System.out.println(test3());\n    }\n    public static Point test1() {\n        Point p = new Point();\n        try {\n            p.x = 20;\n            return p;\n        } finally {\n            p.x = 30;\n        }\n    }\n    public static int test2() {\n        int a = 100;\n        try {\n            a = 200;\n            return a;\n        } finally {\n            a = 300;\n        }\n    }\n    public static int test3() {\n        int a = 100;\n        try {\n            a = 200;\n            return a;\n        } finally {\n            a = 300;\n            return a;\n        }\n    }\n}', 'A、30 200 200\n\nB、20 200 300\n\nC、30 200 300\n\nD、20 300 200', 'C', '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (116, '可能触发fullgc的条件', 'A、MaxDirectMemeorySize写满\n\nB、永生代（Perm）或Metaspace被写满\n\nC、年老代（tenured）被写满\n\nD、显示调用System.gc', 'ABCD', '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (117, '属于java并发库的线程同步类', 'A、Exchanger \nB、Semaphore \nC、CountDownLatch  \nD、CyclicBarrier  \nE、Phaser', 'ABCDE', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (118, '关于溢出描述正确的是', 'A、java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。\n\nB、java.lang.StackOverflowError: 线程栈空间不足\n\nC、java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (119, '以下说法不正确的是', 'A、当关闭断言时，会导致程序的运行结果不一致\n\nprivate ArrayList<String> names;\n\nvoid process(int index) {\n\nassert names.remove(null);\n\n// ...\n\n}\nB、建议子类通过重载扩大方法的可访问性，这样可以拥有更大的访问权限\nC、对于实现了java.lang.Cloneable接口的类，应该将方法clone()的可访问性从protected增加为public\nD、如果忽略方法的返回值或对函数调用失败情况未正确处理，可能会导致安全风险。', 'B', 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (120, '以下说法不正确的是', 'A、使用不可信数据构造格式化字符串时，当转换参数与对应的格式符不匹配时，标准类库会抛出异常，不会造成系统信息泄露或拒绝服务\n\nB、用户可以通过输入一个回车符或一个换行符（CRLF）来将一条合法日志拆分成两条日志，使得日志内容可能令人误解\n\nC、尽可能使用“黑名单”策略来接收跨信任边界的数据，而不是使用白名单，白名单校验方式较弱\n\nD、对不可信数据校验建议使用断言的方式校验', 'ACD', 'A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (121, '以下说法正确的是', 'A、将含敏感数据的对象跨信任域传递前需要先加密后签名\n\nB、默认情况下，自动签名认证机制使用JAR文件中包含的公钥来验证签名，这就可以保证公钥和签名未被恶意篡改\n\nC、一些常用的JSON框架都具有type功能，它可以很方便的将java的对象类型和json数据格式之间进行转换，建议默认开启JSON框架的type功能\n\nD、非静态的内部类序列化时会隐式的对外部类实例的非transient对象进行序列化', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (122, 'java中用来对字符串做归一化的方法是', 'A、java.lang.String.intern()\n\nB、java.lang.String.trim()\n\nC、java.text.Format.format()\n\nD、java.text.Normalizer.normalize()', 'D', '在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (123, '以下说法不正确的是', 'A、临时文件由于会定期被清理掉，所以不用显示的清理临时文件\n\nB、java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改\n\nC、运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空\n\nD、Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值', 'ABD', 'A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (124, '以下代码正确的是', 'A、short s = 1;s = s + 1;\n\nB、\n\nint big = 1999999999;\n\nfloat one=1.0f;\n\nSystem.out.println(big * one);\n\n \n\nC、\n\nint ni = 6789;\n\ndouble d1 = ni / 30;\n\n \n\nD、\n\nlong nl = 4664382371590123456L;\n\ndouble d2 = (double) nl * 2;', 'D', 'A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (125, '关于可变参数说法正确的是', 'A、可以接受指定类型的1个到多个参数\n\nB、不建议使用varargs重写使用一个固定长度数组作为参数的方法\n\nC、JDK1.5引入Varargs（variable number of arguments）可变数量参数，应该在确实需要操作可变长度的值的序列时使用\n\nD、可变参数必须位于最后一项', 'BCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (126, '关于方法说法正确的是', 'A、方法的参数个数不应超过5个\n\nB、构造方法如果参数较多，尽量重用\n\nC、方法的入参建议当做工作变量/临时变量\n\nD、避免方法过长，不超过50行（非空非注释）；避免方法的代码块嵌套过深，不要超过4层', 'ABD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (127, '以下说法正确的是', 'A、Java 8使用Optional代替null作为返回值或者可能的缺失值;禁止对optional对象赋值为null\n\nB、禁止对optional对象赋值/返回为null，或与null比较\n\nC、不应该返回Optional<Integer> , Optional<Long> , Optional<Double> ,而用OptionalInt,OptionalLong,OptionalDouble\n\nD、枚举常量的序号生成建议依赖ordinal()方法', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (128, '以下说法正确的是', 'A、不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符\n\nB、编码时尽量依赖平台默认的字符编码方式\n\nC、String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换\n\nD、使用java.nio.charset中的类编码解码字符集', 'AD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (129, '关于接口说法正确的是', 'A、接口中可包含静态方法和default方法\n\nB、接口中属性默认public static final修饰词\n\nC、方法已缺省具有public abstract修饰词', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (130, '目录遍历攻击可以直接带来哪些危害？', 'A、攻击者可以访问受限目录和文件\n\nB、攻击者可以篡改系统的任意文件\n\nC、攻击可可以恶意删除系统中的文件\n\nD、攻击者可以窃取内存中数据', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (131, '预防ReDos攻击，比较有效的防护手段有', 'A、进行正则匹配前，先对匹配的文本的长度进行校验\n\nB、在编写正则时，尽量不要使用过于复杂的正则，越复杂越容易有缺陷\n\nC、在编写正则时，尽量减少分组的使用\n\nD、避免动态构建正则，当使用不可信数据构造正则时，要使用黑名单进行严格校验', 'ABC', '避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 1, 0, 0);
INSERT INTO `question` VALUES (132, '防止未加密的敏感数据被序列的方法有', 'A、使用transient定义敏感数据\n\nB、使用serialPersistentFields定义非敏感数据\n\nC、重新定义Serializable接口的writeObject()、writeReplace()、writeExternal()这些函数，不将包含敏感信息的字段写到序列化字节流中。\n\nD、在在序列化与反序列化涉及的writeObject()和readObject()方法中使用安全管理器', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (133, '以下说法正确的是', 'A、文件路径校验前必须先进行标准化处理，建议使用getAbsolutePath()\n\nB、未对程序输入做有效的校验与限制可能会导致zip炸弹攻击、SQL注入、OS命令注入、XML注入以及目录遍历等攻击\n\nC、数值运算，建议使用先决条件检查、Math.*Exact()方法、向上类型转换等方式防止溢出\n\nD、建议通过System.exit()函数来终止运行的程序和线程', 'BC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (134, '属于不可信数据列表的有', 'A、命令行\n\nB、用户输入\n\nC、环境变量\n\nD、网络数据', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (135, '在执行JDBC查询数据库时，假设物理内存足够用，如果查询结果集ResultSet要返回的记录数很多，比如上百万记录，则下列选项中对ResultSet的fetchsize属性描述正确的是', 'A、ResultSet的fetchSize越大，数据库服务端消耗的内存越小，性能也越快\n\nB、ResultSet的fetchSize越大，数据库服务端消耗的内存越大，性能也越快\n\nC、ResultSet的fetchSize越大，JDBC client端消耗的内存越大，性能也越快\n\nD、ResultSet的fetchSize越大，JDBC client端消耗的内存越小，性能也越快', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (136, '以下代码输出\nclass Parent {\n    public int a = 100;\n    private int b = 200;\n    protected int c = 300;\n    public int f() {\n        return 10;\n    }\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException {\n        Field[] fields = Parent.class.getDeclaredFields();\n        System.out.println(fields.length);\n        Field[] fields1 = Parent.class.getFields();\n        System.out.println(fields1.length);\n    }\n}', 'A、1 3\n\nB、3 1\n\nC、1 1\n\nD、3 3', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (137, '下面哪个不是Class类中定义的反射方法', 'A、getDeclaredFields\n\nB、getDeclaredNames\n\nC、getDeclaredMethods\n\nD、getDeclaredConstructors', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (138, '1、下面那些可以编译成功', 'A、float f = 10f\n\nB、char c = 10.0\n\nC、byte b = 10b\n\nD、double d = 10\n\nE、float f = 10.0\n\nF、double d = 10.0', 'ADF', '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (139, '关于集合，以下说法正确的是', 'A、HashMap使用的是数组+链表（或红黑树）的方式，查找key时，先判断key的equals是否相等，相等时再判断 hashCode是否一致\n\nB、HashMap和HashSet的默认值大小为16，HashTable的默认值大小为11\n\nC、LinkedHashMap保持插入的顺序，TreeMap保持key的自然顺序\n\nD、Collection的直接子类包含Set、List、Map和Queue', 'BC', 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (140, 'switch支持的类型', 'A、byte \nB、long \nC、char  \nD、String', 'ACD', '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (141, '关于函数重写和重载，说法正确的是', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\n\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\n\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\n\nD、声明为final或static的方法不能被重写', 'ACD', 'B 返回值同不同 都不满足', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (142, '以下关于异常说法正确的是', 'A、Throwable是所有Error或Exception的超累\n\nB、只有是Exception或Exception子类，才能被catch\n\nC、Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError\n\nD、编译器会强制要求使用者捕获RuntimeException或申明抛出', 'ACD', 'B 纯属狗屁了，你把Throwable不放在眼里', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (143, '有关多线程中异常处理的说法正确的是', 'A、Java多线程程序中，线程不允许抛出未捕获的Checked Exception\n\nB、Java多线程程序中，线程允许抛出未捕获的Checked Exception\n\nC、Java多线程程序中，建议使用Thread对象的setUncaughtExceptionHandler方法注册Runtime异常的处理者\n\nD、Java多线程中，主线程可通过try catch捕获子线程异常', 'AC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (144, 'Java反射机制的作用包括', 'A、在运行时判断任意一个对象所属的类。\n\nB、在运行时构造任意一个类的对象。\n\nC、在运行时判断任意一个类所具有的成员变量和方法。\n\nD、在运行时调用任意一个对象的方法。', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (145, 'SocketChannel可以向Selector注册哪些事件', 'A、SelectionKey.OP_ACCEPT\n\nB、SelectionKey.OP_CONNECT\n\nC、SelectionKey.OP_WRITE\n\nD、SelectionKey.OP_READ', 'ABCD', '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (146, '如下类型，哪些是值不可变类型', 'A、char\n\nB、Integer\n\nC、String\n\nD、short', 'BC', '貌似包装类都是final class可能看看源码加深记忆', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (147, '在64位虚拟机，如下数据类型中，长度不是4字节的类型有哪些', 'A、char\n\nB、int\n\nC、long\n\nD、short', 'ACD', 'https://blog.csdn.net/u012611878/article/details/52455576', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (148, '以下代码执行两遍，文件text.txt中的内容为\n\nFileOutputStream outputStream = new FileOutputStream(\"test.txt\",true);\noutputStream.write(\"ABCDE\".getBytes(StandardCharsets.UTF_8));\noutputStream.close();', 'A、ABCDE\n\nB、ABCDEABCDE\n\nC、什么都没有\n\nD、EDCBAEDCBA', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (149, '以下代码输出什么\n\nList arrayList = new ArrayList();\narrayList.add(\"aaaa\");\narrayList.add(100);\nSystem.out.println((String)arrayList.get(1));', 'A、100 \nB、编译错误 \nC、运行异常 \nD、aaaa', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (150, '以下代码输出什么\nString str = \"abc@x.y+com\";\nString str1 = \"ab_c@x.y.com\";\nString regex = \"^[a-zA-Z0-9.-_]+@([a-zA-Z0-9]+.)+com$\";\nSystem.out.println(str.matches(regex));\nSystem.out.println(str1.matches(regex));', 'A、true true  \nB、true false \nC、false true \nD、false false', 'A', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (151, '不属于NIO Buffer中的属性变量', 'A、capacity \nB、flag \nC、position \nD、limit', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (152, '关于IO/NIO说法不正确的是', 'A、IO是面向流的，NIO是面向缓存的\n\nB、IO是阻塞IO，NIO支持非阻塞IO\n\nC、IO值能顺序读取数据，NIO可以通过缓存区前后移动获取数据\n\nD、IO允许一个线程监听多个输入通道', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (153, '不属于NIO组件的是', 'A、Buffer \nB、Channel\nC、Selectors \nD、Reader', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (154, '下面说法正确的', 'A、volatile保证操作的修改可见性和原子性\n\nB、volatile和synchronized则可以使用在变量、方法、和类级别的\n\nC、synchronized和ReentrantLock都是可重入锁\n\nD、synchronized适合一写多读场景', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (155, '以下代码输出什么\n\nComparator<Integer> df = new Comparator<Integer>() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return o1 > o2 ? 1 : (o1 == o2) ? 0 : -1;\n    }\n};\nSystem.out.println(df.compare(new Integer(1),new Integer(1)));', 'A、0 \nB、1 \nC、-1 \nD、运行时异常', 'C', 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (156, '不属于启动安全管理器的是？', 'A、启动程序的时候通过附加参数启动安全管理器：-Djava.security.manager\n\nB、若要同时指定配置文件 -Djava.security.manager -Djava.security.policy=\"E:/java.policy\"\n\nC、编码方式启动 System.setSecurityManager(new SecurityManager());\n\nD、编码方式启动 System.setProperty(“java.security.manager”, xxx);', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (157, '正确的执行System.exit()的方式', 'A、OOM时，主动执行System.exit()\n\nB、进程发生不可预知的异常时，主动执行System.exit()\n\nC、命令行执行System.exit()\n\nD、服务出现不可恢复的异常时，主动执行System.exit()', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 0, 0);
INSERT INTO `question` VALUES (158, '以下说法正确的是', 'A、调用Thread.interrupt() 用于请求另外一个线程中止执行，而不是直接中止\n\nB、推荐使用Thread.current().isInterrupted()，而不是Thread.interrupted()检查自己是否被interrupt\n\nC、检测到当前线程被interrupt后，应抛出InterruptedException，并在finally或try-with-resource中清理执行状态\n\nD、调用线程的interrupt方法，只有当线程走到了sleep, wait, join等阻塞这些方法的时候，才会抛出InterruptedException。', 'ACD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 1);
INSERT INTO `question` VALUES (159, '以下哪些在接收到Thread.interrupt()会抛出InterruptedException异常', 'A、Thread.sleep()\n\nB、java.net.Socket的阻塞方法\n\nC、java.nio.channels.SocketChannel的阻塞方法\n\nD、Thread.wait()\n', 'ACD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (160, '下面哪些是线程安全的（）', 'A、LinkedList\nB、Vector\nC、Hashtable\nD、TreeMap\nE、TreeSet\nF、ConcurrentHashMap\nG、Stack', 'BCFG', 'Stack<E> extend Vector<E> 故线程安全', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (161, '关于溢出描述正确的是', 'A、java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。\n\nB、java.lang.StackOverflowError: 线程栈空间不足\n\nC、java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (162, '属于java并发库的线程同步类', 'A、Exchanger \nB、Semaphore \nC、CountDownLatch  \nD、CyclicBarrier  \nE、Phaser', 'ABCDE', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (163, '下面说法正确的', 'A、FileChannel 从文件读取数据，或将数据写入文件，无法设置为非阻塞模式\n\nB、DatagramChannel 使用TCP协议通过网络来读写数据\n\nC、SocketChannel 使用UDP协议通过网络来读写数据\n\nD、ServerSocketChannel 可以监听新进来的TCP连接', 'AD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (164, '针对DT FUZZ测试，下面的说法正确的是？', 'A. DT FUZZ测试中，如果被测函数代码有修改，但被测函数被调用逻辑没有修改，不需要修改测试用例\n\n \n\nB. 尽量选择模块外层函数为被测目标，编写测试用例，测试过程中，本模块内部函数可以随意打桩\n\n \n\nC. DT FUZZ测试，编写测试用例可以不考虑函数的调用上下文\n\n \n\nD. 结构化的参数DT FUZZ工具都可以构造', 'A', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (165, '当线程调用start后，其所处的状态是 ', 'A. 新建\n\n \n\nB. 阻塞\n\n \n\nC. 运行\n\n \n\nD. 就绪\n', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (166, '下面对Java反序列化的描述正确的是：', 'A. jdk提供的序列化操作，会将Java对象序列化二进制流，可以有效防止信息泄露或恶意篡改\n\n \n\nB. Java的反序列化操作，可以绕过对象构造函数的执行\n\n \n\nC. 对象序列化后，即使包含敏感数据也不会产生风险\n\n \n\nD. Java反序列化时，目标class与预期class不一致时，会导致类型转换错误，所以即使反序列化不可信数据也不会有安全风险', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (167, '下列哪项危害不是，不正确的构造正则可能会导致的安全风险', 'A. CSRF\n\n \n\nB. 敏感信息泄露\n\n \n\nC. ReDos攻击\n\n \n\nD. 正则注入', 'A', 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (168, '下面对敏感数据记录日志，描述正确的是', 'A. 做好日志访问权限控制，日志可以记录敏感信息\n\n \n\nB. 敏感信息记录日志时，直接将信息内容替换等长的*即可\n\n \n\nC. 日志中如果必须记录敏感信息，需要使用长度固定的*替代\n\n \n\nD. 敏感信息加密后可以记录日志', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (169, '常见的xml实体解析导致的安全风险有那几种？', 'A. xPath注入\n\n \n\nB. XXE\n\n \n\nC. 内部实体扩展\n\n \n\nD. xml注入', 'BC', '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (170, '下面对命令注入的防护措施中，无效的是', 'A. 避免使用shell方式执行命令，直接启动具体的进程\n\n \n\nB. 代码避免使用外部输入拼接命令行，代码中对命令进行硬编码\n\n \n\nC. 对于使用外部输入构造的命令行，在执行前进行转码处理\n\n \n\nD. 外部输入进行白名单校验，禁止使用&|>;等特殊字符', 'C', '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (171, '下列生成随机数最安全的方法为', 'A. java.util.Random()\n\n \n\nB. Math.random()\n\n \n\nC. java.util.concurrent.ThreadLocalRandom()\n\n \n\nD. java.Security.SecureRandom()', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (172, '对于不安全反序列化漏洞的防护描述错误的是：', 'A. XMLDecoder是jdk原生类，提供了xml的反序列化操作，所以相对Xstream，更推荐使用XMLDecoder进行xml数据的反序列化操作\n\n \n\nB. 使用jdk原生api进行反序列化操作，涉及不可信数据时，可以重载ObjectInputStream的resolveClass()方法，在该方法中对目标class进行白名单校验\n\n \n\nC. 对不可信的XML数据进行反序列化操作，推荐使用XStream实现，该组件支持白名单检查，新版本也提供了默认安全校验机制\n\n \n\nD. 对不可信的json数据进行反序列化操作，可通过禁止开启type功能进行防护\n\n ', 'A', 'java原生的XMLDecoder类常被用来序列化反序列化XML格式数据，但是这个类也存在严重安全问题，这里解析任意xml文件可以导致反序列化命令执行，oracle官方未提供任何针对此问题的安全措施，所以在反序列化不可信xml数据时，强烈建议不要使用此类。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 0, 0);
INSERT INTO `question` VALUES (173, '以下哪些程序示例是正确的？\n①public class OuterSer implements Serializable {\n    private int rank;\n    class InnerSer implements Serializable {\n        protected String name;\n        // ...\n    }\n}\n\n②public class OuterSer implements Serializable {\n    private int rank;\n    class InnerSer {\n        protected String name;\n        // ...\n    }\n}\n\n③public class OuterSer implements Serializable {\n    private int rank;\n    static class InnerSer implements Serializable {\n        protected String name;\n        // ...\n    }\n}', 'A. ③\n\nB. ②\n\nC. ①\n', 'AB', '规则7.5 禁止序列化非静态的内部类', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (174, '下列哪些方法的返回Buffer对象暴露给不受信任的代码，存在原始数据被恶意修改的风险', 'A. CharBuffer.asReadOnlyBuffer();\n\n \n\nB. CharBuffer.duplicate();\n\n \n\nC. CharBuffer.subSequence();\n\n \n\nD. CharBuffer.wrap();', 'BCD', 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (175, '下面对线程同步描述错误的是', 'A. Java中一般会使用同步方法或同步代码块实现线程同步操作\nB. 对于单例模式的java类，即使该类对象可暴露给不可信代码，使用同步方法可以正确进行线程同步\nC. 使用private final的锁对象更安全\nD. 同步方法与基于this引用的同步代码块使用的是相同的锁', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (176, '在一般情形下，仅仅忽略对回车换行的过滤(\\x0d, \\x0a)有可能会导致如下哪种安全问题：', 'A. 反序列化漏洞\nB. 日志注入\nC. json注入共计\nD. 缓冲区溢出', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (177, '下面的代码实现中，对xml内部实体扩展没有防护作用的是：\n①DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\nDocumentBuilder db = dbf.newDocumentBuilder();\ndb.parse(inStream);\n②DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://oracle.com/xml/jaxp/properties/entityExpansionLimit\", \"200\");\nDocumentBuilder db = dbf.newDocumentBuilder();\ndb.parse(inStream);\n③System.setProperties(\"entityExpansionLimit\", \"200\");\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\ndb.parse(inStream);\n④SAXParserFactory factory = SAXParserFactory.newInstance();\nfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\nfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(inStream, defaultHandler);', 'A. ③\nB. ④\nC. ①\nD. ②', 'B', '解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (178, '下面对java中创建的具有输出流或错误流的进程的处理，正确的是？', 'A.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nerrorGobbler.start();\nint exitVal = proc.waitFor();\nB.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nStreamGobbler outputGobbler = new StreamGobbler(proc.getInputStream(), System.out);\nerrorGobbler.start();\noutputGobbler.start();\nint exitVal = proc.waitFor();\nC.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nint exitVal = proc.exitValue();\nD.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nint exitVal = proc.waitFor();', 'B', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (179, '就以下程序说法正确的是：\npublic class Sys extends Thread {\nboolean stop = false;\npublic static void main(String[] args) throws interruptedException {\nSys thread = new Sys();\nthread.start();\nThread.sleep(3000)\nthread.interrupt();\nThread.sleep(3000)\nSystem.out.println(\"Stopping application...\");\n}\npublic void run() {\nwhile(!stop) {\nSystem.out.println(\"Thread is running...\");\n}\nSystem.out.println(\"Thread exiting under request...\");\n}\n}', 'A. 调用interrupt()后线程停止\nB. interrupt()可以实现在线程受到阻塞时抛出一个中断信号\nC. 中断线程推荐使用stop()函数\nD. 线程会一直运行', 'D', '解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (180, '下列对sql注入防护措施中的转码描述正确的是', 'A. 转码是优选的sql注入防护措施\nB. 转码仅对拼接sql语句中，单引号或双引号限制的字段生效\nC. 在拼接sql语句前进行转码，可以彻底解决sql注入问题\nD. 转码对表名、字段等不适用于参数化查询的场景是优选的方案', 'B', '解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (181, '下列哪个场景可以使用java.util.Ramdom类产生的随机数', 'A. 随机选取路由\nB. 挑战算法中的随机数生成\nC. 验证码的随机数生成\nD. Web应用会话标识符', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (182, '下面代码中存在XML实体注入的是：', 'A. SAXParserFactory factory = SAXParserFactory.newInstance();\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(inStream, defaultHandler);\nB. public static String DDD = \"http://apache.org/xml/features/disallow-doctype-decl\";\npublic static String EGE = \"http://xml.org/sax/features/external-general-entities\";\npublic static String EPE = \"http://xml.org/sax/features/external-parameter-entities\";\npublic static String LED = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\nSAXReader reader = new SAXReader();\nreader.setFeature(LED, false);\nreader.setFeature(EGE, false);\nreader.setFeature(EPE, false);\nC. XMLReader reader = saxParser.getXMLReader();\nreader.serEntityResolve(new CustomerResolver());\nreader.setErrorHandler(defaultHandler);\nD. DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false)', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (183, '下面加密算法中，哪类属于不安全的加密算法', 'A. AES-GCM\nB. AES-ECB\nC. DES\nD. MD5', 'BCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 1);
INSERT INTO `question` VALUES (184, '下列操作中可导致任意代码执行的操作有哪些？', 'A. 使用不安全的XSLT转换XML文件\nB. 对不可信数据进行反序列化操作\nC. 使用不可信数据拼接sql语句\nD. 使用不可信数据拼接命令行', 'ABD', '解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 0, 0);
INSERT INTO `question` VALUES (185, '以下异常列表哪些属于敏感异常？', 'A. java.io.FileNotFoundException\nB. java.net.BindException\nC. java.util.ConcurrentModificationException\nD. java.sql.SQLException\nE. java.lang.NullPointerException\nF. java.lang.IllegalArgumentException', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (186, '以下哪种攻击方式是针对XML数据应用', 'A. 外部实体注入(XXE)\nB. 内部实体扩展\nC. LDAP注入\nD. XPath注入', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (187, '在Java环境中，允许处于不同受信域的组件进行数据通信，从而出现跨受信边界的数据传输。以下哪种方式可以在一定程度上解决反序列化中的信息泄漏问题：', 'A. 将属性声明为final\nB. 将敏感数据声明为transient\nC. 将属性声明为private\nD. 特殊情况下正确加密了的数据可以被序列化', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (188, '下列描述中，可能会产生死锁的是', 'A. 同步方法或使用对象内置锁的同步代码块中，直接抛出异常\nB. 异常条件下没有正确释放锁\nC. 两个或多个线程以不同的顺序请求和释放锁\nd. 在产生阻塞的操作中持有锁', 'BCD', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (189, '请阅读下面的代码，分析代码中存在哪些安全风险：\nString password;\npassword = \"\";\nProperties properties = new Properties();\nFileInputSteam streamFileInput = null;\ntry {\nstreamFileInput = new FileInputSteam(\"../common/config.properties\");\nproperties.load(streamFileInput);\npassword = properties.getProperty(\"passport\");\nstreamFileInput.close();\n} catch (IOException exceptIO) {\nIO.logger.log(Level.WARNING, \"Error with stream reading\");\n}\nConnection dBConnection = null;\ntry {\ndBConnection = DriverManager.getConnection(\"192.168.105.23\", \"sa\", password);\n} catch (SQLException exceptSql) {\nIO.logger.log(Level.WARNING, \"Error with database connection\");\n}', 'A. 资源未正确释放\nB. 敏感异常导致信息泄漏\nC. sql注入\nD. 配置文件中明文保存密码', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (190, '栈帧存储了哪些信息？', 'A. 方法的局部变量表\nB. 操作数栈\nC. 动态连接\nD. 方法返回地址', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (191, 'gc主要回收的内存区域是哪块', 'A. 堆区\nB. 方法区', 'AB', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (192, '以下类型精度最高的是？', 'A. int\nB. long\nC. BigInteger\nD. byte', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (193, '下面语句运行结果为\nswitch (5) {\ndefault:\nSystem.out.println(5);\ncase 0:\nSystem.out.println(0);\ncase 1:\nSystem.out.println(1);\nbreak;\ncase 2:\nSystem.out.println(2);\nbreak;\n}', 'A. 501\nB. 1\nC. 0\nD. 5', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (194, '正则表达式，[^a-zA-Z0-9_]等价于', 'A. \\W   B. \\w   C. \\t   D.\\v', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (195, '如下操作属于中间结果的是', 'A. reduce()\nB. map()\nC. forEach()\nD. stream()', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (196, '以下代码执行结果为\nint count = 0;\nfor (int i = 0; i < 100; i++) {\ncount=count++;\n}\nSystem.out.println(count);', 'A. 0\nB. 100\nC. 1\nD. 99', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (197, '关于RandomAccessfile的说法错误的是？', 'A. 内部基于指针形式可以随机读写文件\nB. 可以通过RandomAccessFile的FileChannel间进行mmap操作\nC. RandomAccessFile继承InputStream和OutputStream\nD. RandomAccessFile只能对文件进行操作\nE. 支持r,rw,rws,rwd四种模式', 'C', '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (198, '如下代码执行三次的结果\nFileOutputStream outputStream = new FileOutputStream(\"test.txt\", true);\noutputStream.write(\"ABCDE\".getBytes(StandardCharsets.UTF_8));\noutputStream.close();', 'A. ABCDE\nB. ABCDEABCDEACBDE\nC. 编译报错\nD. ABCDE\nABCDE\nABCDE', 'B', '解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (199, '为从文本文件中进行读取内容，应该使用哪个处理流文件', 'A. BufferedReader\nB. BufferedWriter\nC. BufferedInputStream\nD. BufferedOutputStream', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (200, '下面说法正确的是', 'A. FileChannel从文件读取数据，或将数据写入文件，无法设置为非阻塞模式\nB. DatagramChannel使用TCP协议通过网络来读写数据\nC. SocketChannel使用UDP协议通过网络来读写数据\nD. ServerSocketChannel可以监听新进来的TCP连接', 'AD', '解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (201, '安全编程规范中，下面说法正确的有', 'A. 创建文件时指定合理的访问权限\nB. 对所有外部输入进行校验\nC. 记录日志时可以抛异常\nD. 禁止不受信任的代码直接终止JVM', 'ABD', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 1);
INSERT INTO `question` VALUES (202, '以下说法正确的是', 'A. 临时文件由于会定期被清理掉，所以不用显示的清理临时文件\nB. java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改\nC. 运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空\nD. Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值', 'C', '解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (203, '关于Java NIO网络编程说法错误的是？', 'A. NIO中的ServerSocketChannel可以同时监听TCP链接，每一个新来的链接都会创建一个SocketChannel\nB. Java NIO中的一个选择器只能注册一个通道\nC. NIO各种流是非阻塞的，如果没有数据可用也不会阻塞线程\nD. Java普通IO是面向流的，NIO是面向缓冲区的', 'B', '解析：\n一个选择器最多可以同时被63个通道一起注册使用。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (204, '关于Linux的IO模型，说法错误的是', 'A. Linux的IO模型分为五种，阻塞IO，非阻塞IO，多路复用IO，信号驱动，异步IO\nB. 大部分高性能的IO中间件，如nignx，都是使用多路复用IO\nC. 多路复用IO没有一个线程需要被阻塞\nD. 多路复用IO依赖操作系统的能力，具体而言就是select/poll/epoll', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (205, 'Socket哪些操作可能会进入阻塞状态', 'A. server socket的accpet()监听客户端连接\nB. 执行socket的输出流写数据\nC. 执行socket的输入流读取数据\nD. Socket的getOutputStream()，getInputStream()', 'ABC', '解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (206, '如果一个对象存入Hash集合后hashcode随即发生变化，会导致什么结果？', 'A. 内存泄漏\nB. 无任何问题\nC. 内存溢出\nD. 抛出异常', 'A', '解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (207, '下列运算不会溢出的是', 'A. Math.abs\nB. num++\nC. num%num1\nD. num/num1', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (208, '下面哪些可以编译成功？', 'A. float f = 10f;\nB. char c = 10.0;\nC. byte b = 10b;\nD. double d = 10;\nE. float f = 10.0;\nF. double d = 10.0;', 'ADF', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (209, '下面哪个是对的？', 'A. float f1 = 3.123\nB. char c1 = 1;\nC. int x = 1.0', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (210, '求平方根方法public static double sqrt(double a) 可以传递的参数类型有哪些？', 'A. \'\\n\'\nB. \"a\"\nC. \'\\u0012\'\nD. \'\\u12\'', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (211, '以下代码的执行结果\nchar alpha = \'A\';\nint foo = 65;\nboolean trueExp = true;\nSystem.out.println(trueExp ? alpha : 0);\nSystem.out.println(trueExp ? alpha : foo);', 'A. A A\nB. 65 65\nC. A 65\nD. 65 A', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (212, '下列说法错误的是', 'A. ConcurrentHashMap不允许有null的key、value\nB. TreeMap可以有null的key、value\nC. ConcurrentHashMap是线程安全的\nD. HashMap线程不安全，但效率高', 'B', '解析：\nTreeMap键可以为\'null\'，值不允许', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (213, '下面描述正确的是', 'A. 多线程环境下使用CourrentHashMap和Collections. synchronizedMap实现同步效率差别不大\nB. Collections. synchronizedMap不是线程安全的\nC. 多线程环境下使用HashTable和Collections. synchronizedMap实现同步效率差别不大\nD. ConcurrentHashMap的锁粒度较大', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (214, '以下对Java集合说法正确的是', 'A. 往一个ArrayList或者Vector里插入一个元素时，如果内部数组空间不够，ArrayList或Vector会扩展它的大小。Vector在默认情况下增长一倍的大小，而ArrayList增加50%的大小\nB. ArrayList、Vector、HashMap、StringBuilder和StringBuffer都是线程不安全的\nC. Vector类实现了一个动态数组，默认不传参数时，构造容量为16的大小，也可以传参指定容量大小；ArrayList就是动态的数组，默认不传参数时，构造容量为10的大小，也可以传参指定容量大小\nD. ConcurrentHashMap、HashMap、HashSet都不支持key为null，且遍历使用的都是Iterator迭代器，其中只有HashTable是线程安全的', 'A', '解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (215, '针对Map选型，描述正确的是：', 'A. HashMap键、值均可以为null值\nB. HashMap中的数据是无序的\nC. TreeMap中的键是自动排序的，不允许为null值\nD. LinkedHashMap插入元素是有序的', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (216, 'PreparedStatement.setInt(int parameterIndex, int x)参数的含义', 'A. 把第parameterIndex-1的参数值设置为x\nB. 把第parameterIndex的参数值设置为x\nC. 把第x-1的参数值设置为parameterIndex\nD. 把第x的参数值设置为parameterIndex', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (217, '有关数据库drop delete truncate的区别，说法正确的是', 'A. 保留表而删除所有数据的时候建议使用truncate\nB. 删除部分数据行时，可以使用delete，并且带上where子句\nC. drop delete truncate只删除表的数据，不会删除表的结构\nD. truncate drop是dll，操作立即生效，原始数据不放到rollback segment中，不能回滚', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (218, '关于DataSource的说法错误的是', 'A. DataSource是用于获取数据库链接的接口\nB. DataSource对象的属性不可以修改\nC. DataSource主要有三种类型实现：基本实现、连接池实现、分布式事务实现\nD. 通过DataSource对象访问的驱动程序本身不会向DriverManager注册', 'B', '解析：\nDataSource对象的属性在必要时可以修改。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (219, '属于不可信数据列表的有：', 'A. 命令行\nB. 用户输入\nC. 环境变量\nD. 网络数据', 'ABCD', '解析：\n不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (220, '根据华为Java编程规范，这段代码违反了哪个条目？\npublic static List<String> decorate(String[] personDescs) {\nif (personDescs == null || personDescs.length == 0) {\nreturn null;\n}\nList<String> personNames = new ArrayList<>(personDescs.length);\nfor (String personDesc : personDescs) {\nString personName = getPersonName(personDesc);\nif (personName != null && personName.length() != 0) {\npersonNames.add(personName);\n}\n}\nreturn personNames;\n}\npublic static void main (String[] args) {\n// Do something here.\nList<String> personNames = decorate(personDescs);\nif (personNames == null) {\nreturn;\n}\nfor (String personName : personNames) {\n// Do something here.\n}\n}', 'A. 使用类名调用静态方法，而不要使用实例或表达式来调用\nB. 方法的代码块不要嵌套过深，不能超过4层\nC. 当返回类型为数组或者容器时，应返回长度为0的数组或者容器\nD. personName变量需要判断是否为null', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (221, '根据华为Java编程规范，下列选项中变量声明错误的有哪些？', 'A. int a,b;\nB. int replacementLen = replacement.length();\nString string = sequence.toString();\nint pos = indexIn(string);\nif (replacementLen == 0) {\nreturn removeFrom(sequence);\n}\nif (replacementLen == 1) {\nreturn replaceFrom(sequence, replacement.charAt(0));\n}\nif (pos == -1) {\nreturn string;\n}\nC. String args[];\nD. public boolean matchs (char c) {\nswitch (c) {\ncase \'\\t\':\ncase \'\\n\':\ncase \'\\u205f\':\ncase \'\\u3000\':\nreturn true;\ncase \'\\u2007\':\nreturn false;\ndefault:\nreturn false;\n}\n}', 'ABCD', '解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (222, '在使用java中的套接字（socket）时，下列代码实现中，哪些选项可能会导致主线程长时间阻塞？', 'A.\nSocket s = new Socket(\"10.116.123.112\", 6526);\nInputStream stream = s.getInputStream();\n// use thread read data\nB.\nSocket s = new Socket(\"10.116.123.112\", 6526);\ns.setSoTimeout(2000)\nInputStream stream = s.getInputStream();\n// use thread read data\nC.\nSocket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526), 1000);\nInputStream stream = s.getInputStream();\n// use thread read data\nD.\nSocket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526));\nInputStream stream = s.getInputStream();\n// use thread read data', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (223, '若一个实现了Serializable的类的构造器方法、内部状态获取与修改方法中都涉及安全管理器检查，那么这些安全管理器检查操作也需要应用到这个类的下列哪些方法中', 'A. equals()\nB. writeObject()\nC. readObject()\nD. hashCode()', 'BC', '解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (224, 'java的安全管理器SecurityManager的policy文件配置如下：\ngrant {\n......\npermission java.util.PropertyPermission \"java.version\", \"read\";\n......\n};\npublic static void main(String... args) {\nSystem.setSecurityManager(new SecurityManager());\nSystem.setProperty(\"java.version\", \"1.7.0_45\");\nString javaNewVersion = System.getProperty(\"java.version\");\nSystem.err.println(javaNewVersion)\n}\n注：sdk的版本是1.8.0_45\n程序输出的结果为：', 'A. 1.8.0_45\nB. 不确定\nC. java.security.AccessControlException.access denied\nD. 1.7.0_45', 'C', '解析：\npolicy文件里面java.version的权限是read，程序去write权限不足', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (225, '关于序列化说法不正确的是', 'A. 序列化只能保存对象的非静态成员交量，不能保存任何的成员方法和静态的成员变量\nB. transient关键字的作用是：阻止实例中那些用此关键字声明的变量持久化\nC. 当一个父类实现序列化，子类若要实现序列化，需要显式实现Serializable接口\nD. 一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口', 'C', '解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (226, '关于JAVA序列化与反序列化错误的是', 'A. 对象的序列化结果是可以在网络中进行传输的字节序列\nB. 反序列化的输入数据可以由外部输入指定\nC. transient关键字可以阻止变量被序列化到文件中\nD. 不要序列化未经加密的敏感数据', 'B', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (227, '关于try-with-resources说法正确的是：', 'A. 不能加finally\nB. 按照创建的资源顺序关闭\nC. try中创建的变量在catch和finally可见\nD. 资源关闭在catch和finally中语句执行之前', 'D', '解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (228, '需要关闭资源，下面哪个写法更好？', 'A.\nInputStream in = ...;\nException ex = null;\ntry {\ntry {\n//code that might throw exceptions\n} catch (Exception e) {\nex = e;\nthrow e;\n}\n} finally {\ntry {\nin.close();\n} catch (Exception e) {\nif (ex == null) throw e;\n}\n}\nB.\ntry (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}\nC.\nInputStream in = ...\ntry {\n//code that might throw exceptions\n} finally {\nin.close();\n}', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (229, '属于经过验证、安全的、公开的加密算法的是：', 'A. AES的ECB模式\nB. RSA\nC. DSA/ECDSA\nD. 加入盐值的SHA256\nE. DES', 'BCD', '解析：\n见 规则9.2 禁止使用私有或者弱加密算法 章节', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (230, '推荐使用的数字签名算法有', 'A. DSA\nB. ECDSA\nC. RSA\nD. RC4', 'AB', '解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (231, '下面对zip文件的安全解压缩描述，错误的是', 'A. zip文件解压时，可以使用entry.getSize()对解压缩文件进行文件大小判断\nB. zip文件解压缩时，需判断文件名称中是否存在../这样的返回上层路径的情况\nC. zip文件解压时，需对解压缩的文件数量进行限制检查\nD. zip文件解压时，需通过边阅读文件内容边统计文件实际大小，对文件大小进行限制检查', 'A', '解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (232, '以下关于异常的说法正确的是', 'A. Throwable是所有Error或Exception的超类\nB. 只有Exception或Exception的子类，才能被catch\nC. Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError\nD. 编译器会强制要求使用者捕获RuntimeException或声明抛出\n解释：Error类及其子类也可以被catch捕获；Checked异常需要显式处理，否则会编译出错；Runtime异常不需要显式处理或声明抛出', 'AC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (233, '下面异常声明不推荐的是', 'A. public Image loadImage(String path) throws FileNotFoundException, EOFException\nB. public Image loadImage(String path) throws IOException\nC. public void drawImage(int num) throws ArrayIndexOutOfBoundsException', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (234, '关于下面代码中shutdown方法说法正确的是？\npublic static void main(String[] args) throws Exception {\nExecutorService executorService = Executors.newFixedThreadPool(10);\nfor (int i = 0; i < 100; i++) {\nexecutorService.submit(new Task());\n}\nexecutorService.shutdown();\nstatic class Task extends Thread {\n@Override\npublic void run() {\n}\n}\n}', 'A. 线程池不再接收新的任务，队列中等待任务不会执行\nB. 线程池终止正在执行的线程\nC. 线程池终止正在执行的线程，和B差不多\nD，线程池不再接收新的任务，队列中等待的任务会执行\nshutdown和shutdownNow的区别：\nshutdown将线程池的状态设置为SHUTWDOWN状态，并不会立即停止\n1) 停止接收外部submit的任务\n2) 内部正在跑的任务和队列里等待的任务，会执行完\n3) 等到第二步完成后，才真正停止\nshutdownNow将线程池状态设置为STOP状态企图立即停止，事实上不一定：\n1) 停止接收外部submit的任务\n2) 忽略队列里等待的任务\n3) 尝试中断正在跑的任务\n4) 返回未执行的任务', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (235, '如下代码片段中，假设SomeObject是一个暴露给非信任代码交互的类，则[1]处可以加入下面哪项代码：\npublic class SomeObject {\n[1]\npublic void changeValue() {\nsynchronized (lock) {\n// Locks on the private Object\n// ...\n}\n}\n}', 'A. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。', 'B', '解析：\nC. 非信任域内，锁不能用public\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (236, '下列代码示例中，加锁范围可能为全局而非当前类示例内的有哪些？', 'A.\nprivate final String lock = new String(\"LOCK\").intern();\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}\nB.\nprivate final String lock = \"lock\"\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}\nC.\nprivate final String lock = new String(\"LOCK\");\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}\nD.\nprivate final Boolean = Boolean.TRUE;\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}', 'ABD', '解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (237, '以下哪些在接收到Thread.interrupt()会抛出InterruptedException异常', 'A. Thread.sleep()\nB. java.net.Socket的阻塞方法\nC. java.nio.channels.SocketChannel的阻塞方法\nD. Thread.wait()', 'ACD', '解析：\n在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (238, '关于volatile关键字说法正确的是', 'A. volatile修饰的变量会优先读写线程工作内存\nB. 使用volatile可以解决原子性问题\nC. 使用volatile修改的变量，可以直接读取，不会有并发问题\nD. volatile可以解决数据可见性问题，即对volatile变量的变更，可以直接写入主内存', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (239, 'atomic包下提供的能原子更新数组中元素的类不包括', 'A. AtomicReferenceArray\nB. AtomicIntegerArray\nC. AtomicReference\nD. AtomicLongArray', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (240, '以下代码中，可以被gc回收的对象有\nclass A {\n}\npublic class Test {\nprivate static A staticA = new A();\npublic static final String CONSTANT = \"i am a string\";\npublic static void main(String[] args) {\nA innerA = new A();\n}\n}', 'A. staticA\nB. CONSTANT\nC. \"i am a string\"\nD. innerA\nGC Roots对象\n1) 虚拟机栈(栈帧中本地变量表)中引入的对象\n2) 方法区中类静态属性引用的对象\n3) 方法区中常量引用的对象\n4) 本地方法中JNI引用的对象', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (241, '使用javac编译时，包含以下哪几个过程？', 'A. 语义分析及生成字节码\nB. 词法分析及填充符号表\nC. Server Compiler\nD. 注解处理\nE. Client Compiler', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 0, 0);
INSERT INTO `question` VALUES (242, '关于Java中的ClassLoader下面的哪些描述是错误的：', 'A. 默认情况下，Java应用启动过程涉及三个ClassLoader：Boostrap, Extension, System\nB. 一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的\nC. 类装载器需要保证类装载过程的线程安全\nD. ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null\nE. ClassLoader的父子结构中，默认装载采用了父优先\nF. 所有ClassLoader装载的类都来自CLASSPATH环境指定的路径', 'BDF', '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (243, '关于类的卸载机制，表述正确的是', 'A. 一个类被首次加载后，会长期驻留JVM，直到JVM退出\nB. 由用户自定义的类加载器加载的类是可以被卸载的\nC. 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载\nD. 所有的java类都有一个静态属性class，它代表这个类的class对象', 'BCD', '解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (244, '下列有关Java反射的说法错误的是：', 'A. 反射可以获取Method，通过invoke进行方法的调用；\nB. 反射不可以直接通过getField获取私有成员的值；\nC. 反射可以获取注解（@Target为Runtime）信息；\nD. 反射可以获取类的构造器', 'C', '解析：\ngetFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；getDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。\n注解@Target没有Runtime，@Retention才有Runtime。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (245, '以下代码输出：\nclass Parent {\npublic int a = 100;\nprivate int b = 200;\nprotected int c =300;\npublic int f() {\nreturn 10;\n}\npublic static void main(String[] args) throws IllegalAccessException, InstantiationException {\nField[] fields = Parent.class.getDeclaredFields();\nSystem.out.println(fields.length);\nField[] fields1 = Parent.class.getFields();\nSystem.out.println(fields1.length);\n}\n}', 'A. 1 3\nB. 3 1\nC. 1 1\nD. 3 3\n注：getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；getDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (246, '关于Optional说法正确的是？', 'A. Optional可以被赋值为null\nB. Optional.of()可以用null做参数，返回Optional.empty()\nC. Optional.ofNullable(obj)，obj不为null时直接调用Optional.of(obj)\nD. Optiona.of()可以放置集合或对象', 'CD', '解析：\n禁止对optional对象赋值/返回为null，或与null比较', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (247, '在JAVA中关于抽象类的描述正确的是', 'A. 抽象类必须包含一个抽象方法\nB. 抽象类的方法必须是抽象的\nC. 声明抽象类必须带有abstract\nD. 抽象类可以被实例化', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (248, 'Java动态代理，(类似RPC框架）问什么阶段生效的？', 'A. 初始化\nB. 编译\nC. 加载\nD. 运行', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (249, '下面选项中的泛型代码片段哪些是正确的？', 'A.\nstatic class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<? super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}\nB.\nstatic class Fruit{}\nstatic class Apple extends Fruit{}\npublic static void main(String[] args) {\nList<? extends Fruit> list = new ArrayList<>();\nlist.add(new Apple());\n}\nC.\npublic class ShowTest<T> {\npublic static void show(T t) {\nSystem.out.println(t.toString());\n}\n}\nD.\nstatic class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}', 'AD', '解析：\n泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<? super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<? extends T>。\n- 2. 经常往里插入的，适合用<? super T>。\n<? extends T> = <subClass extends T> = T以及T的子类\n<? super T> = <superClass super T> = T以及T的父类', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (250, '以下代码输出什么\npublic class Point {\nprivate int x;\nprivate int y;\npublic Point(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\npublic void setLocation(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\npublic static void main(String[] args) {\nPoint p1 = new Point(0, 0);\nPoint p2 = new Point(0, 0);\nmodifyPoint(p1, p2);\nSystem.out.println(\"[\" + p1.x + \",\" + p1.y + \"],[\" + p2.x + \",\" + p2.y + \"]\");\n}\nprivate static void modifyPoint(Point p1, Point p2) {\nPoint tmpPoint = p1;\np1 = p2;\np2 = tmpPoint;\np1.setLocation(5, 5);\np2 = new Point(5, 5);\n}\n}', 'A. [0,0],[0,0]\nB. [5,5],[0,0]\nC. [0,0],[5,5]\nD. [5,5],[5,5]', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (251, '以下代码输出？\nclass Parent {\nint a = 100;\npublic int f() {\nreturn 10;\n}\n}\nclass Son extends Parent {\nint a = 200;\npublic int f() {\nreturn 20;\n}\npublic static void main(String[] args) {\nParent parent = new Son();\nSystem.out.println(parent.f() + \" \" + parent.a);\n}\n}', 'A. 20 100\nB. 20 200\nC. 10 200\nD. 10 100', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (252, '以下说法正确的是：\nclass Base {\npublic Base(int i) {\nSystem.out.println(\"Base(int i)\");\n}\n}\nclass MyOver extends Base {\npublic MyOver(int i) {\n}\npublic static void main(String[] args) {\nMyOver m = new MyOver(10);\n}\n}', 'A. 输出Base()\nB. 输出Base(int i)\nC. 什么都不输出\nD. 编译错误', 'D', '解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (253, '关于函数重写和重载，说法正确的是', 'A. 重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB. 重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC. 重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD. 声明为final或static的方法不能被重写', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (254, '下面说法不正确的是：', 'A. 避免文件过长，不超过2000行（非空非注释行）\nB. 一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔\nC. import包应当按照先华为公司，安卓、其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组\nD. 一个类或接口的声明部分应当按照类变量、实例变量、构造器、方法的顺序出现，且用空行分隔', 'C', '解析：\n建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (255, '生产环境不应该打印什么级别日志？', 'A. debug\nB. warn\nC. error\nD. trace', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (256, '需要对对象密封和数字签名来保证数据安全的场景有：', 'A. 序列化敏感数据\nB. 传输敏感数据\nC. 没有使用类似于SSL传输通道\nD. 敏感数据需要长久保存（比如在硬盘驱动器上）', 'ABCD', '解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (257, '敏感数据传输的正确处理：', 'A. 仅加密\nB. 仅签名\nC. 先加密后签名\nD. 先签名后加密', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (258, '有整数溢出风险的符号', 'A. ++\nB. %\nC. +=\nD. Java.lang.math.abs()', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (259, '以下有关Thread异常处理说法正确的是\nA．子线程自身不必捕获异常，而是由主线程捕获即可\nB．对于运行时异常可调用Thread.setUncaughtExceptionHandler()方法设置运行时异常处理器来进行处理\nC．默认情况下，运行时异常从线程抛出时，会在控制台输出堆栈记录\nD．子线程须自己捕获异常处理\n107. 按照编程规范，下列哪些信息时禁止输入到日志中的 (BCD)\nA．事件发生的时间、事件类型\nB．密钥\nC．明文口令\nD．密文口令\n108. 有关类加载器的双亲委派模型说法错误的是 (C)', 'A. 类加载器之间是有层次结构的\nB. 加载不到类，会抛出ClassNotFoundException();\nC. 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\nD. 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载', 'BCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (260, '下面关于字符流和字节流说法正确的是', 'A. 字符向字节转换时，需要注意编码问题\nB. 字节流继承于InputStream OutputStream，字符流继承于InputSteamReader OutputStreamWriter\nC. 字符流使用了缓冲区(Buffer)，而字节流没有使用缓冲区\nD. 字符是字节通过不同编码的包装，相同的字节代表相同的字符', 'ABC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (261, '集合描述错误的是', 'A. ArrayList的默认长度值16\nB. HashMap的默认长度值16\nC. HashSet的默认长度值16\nD. StringBuﬀer的默认长度值16', 'A', '解析：ArrayList默认是10', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (262, '禁止将系统内部使用的锁对象暴露给不可信代码', 'A. private final Boolean lock1 = Boolean.FALSE;\nB. private final Integer lock2 = 0;\nC. private final String lock3 = \"lock\";\nD. private final Integer lock4 = new Integer(0);', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (263, '容易被利用Dos攻击的异常', 'A. Java.lang.OutOfMemoryError\nB. Java.lang.StackOverflowError\nC. JarException\nD. InSufficientResourceException', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (264, 'Sytem.exit()调用方式符合安全编程规范的', 'A. JAVA进程出现OOM，主动调用System.exit()，结束进程\nB. 服务出现不能自愈的异常，直接调用System.exit()，终止进程\nC. 允许外部传入的命令中有System.exit()\nD. 命令行工具使用System.exit()\n例外场景：\n在命令行应用中调用System.exit()函数是允许的。', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (265, '以下说法正确的是', 'A. 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符\nB. 编码时尽量依赖平台默认的字符编码方式\nC. String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换\nD. 使用java.nio.charset中的类编码解码字符集', 'AD', '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (266, '关于敏感异常，说法不正确的是', 'A. 如果在传递异常的时候未对其中的敏感信息进行过滤，常常会导致信息泄露\nB. 重点关注异常中的文本消息，异常本身的类型不会泄露敏感信息\nC. 对出于问题定位目的，可将敏感异常信息记录到日志中，但必须做好日志的访问控制，防止日志被任意访问，导致敏感信息泄露给非授权用户。\nD. 可以通过限制输入. 安全策略方式过滤掉异常中的敏感信息', 'B', '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (267, '以下说法正确的是', 'A. 将含敏感数据的对象跨信任域传递前需要先加密后签名\nB. 默认情况下，自动签名认证机制使用JAR文件中包含的公钥来验证签名，这就可以保证公钥和签名未被恶意篡改\nC. 一些常用的JSON框架都具有type功能，它可以很方便的将java的对象类型和json数据格式之间进行转换，建议默认开启JSON框架的type功能\nD. 非静态的内部类序列化时会隐式的对外部类实例的非transient对象进行序列化', 'D', '解析：\nA错，先签名后加密\nB错，规则8.3 避免使用URLClassLoader和java.util.jar提供的自动签名检查机制\nC错，必须禁止开启JSON框架的type功能，如果无法禁止type功能，必须使用白名单校验。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (268, 'java中用来对字符串做归一化的方法是', 'A. java.lang.String.intern()\nB. java.lang.String.trim()\nC. java.text.Format.format()\nD. java.text.Normalizer.normalize()', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (269, 'switch支持的类型', 'A. byte\nB. long\nC. char\nD. String', 'ACD', '解析：\nswitch语句支持的类型：\nchar, byte, short, int\nCharacter, Byte, Short, Integer\nenum\nString\n没有boolean，long', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (270, '以下代码输出结果是\nString srcTxt = \"123\\\\d\";\nString rst1 = srcTxt.replaceAll(\"\\\\d\", \"456\");\nString rst2 = srcTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\nString rst3 = srcTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(rst1);\nSystem.out.println(rst2);\nSystem.out.println(rst3);', 'A.\n456456456\\d\n123456\n456456456\\d\nB.\n456456456\\d\n123456\n123456\nC.\n123456\n123456\n123456\nD\n123456\n123456\n45623\\d', 'B', '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (271, '动态代理扩展类是在什么阶段执行的？', 'A. 初始化\nB. 准备\nC. 解析\nD. 加载', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (272, '业务处理日志用', 'A. error\nB. debug\nC. warn\nD. info', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (273, 'JVM GC性能指标吞吐量是指', 'A. CPU运行时间内GC运行的次数\nB. CPU运行用户代码的时间与CPU总消耗时间的比值\nC. CPU运行时间内GC运行次数与所有运行线程次数的比值\nD. CPU运行GC线程的时间与用户代码的时间的比值', 'B', '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (274, '下面代码片段描述正确的是\npublic static int cardinality(Object obj, final Collection<?> col) {\nint count = 0;\nif (col == null) {\nreturn count;\n}\nIterator<?> it = col.iterator();\nwhile (it.hasNext()) {\nObject elt = it.next();\nif ((null == obj && null == elt) || obj.equals(elt)) {\ncount++;\n}\n}\nreturn count;\n}', 'A. 存在空指针异常风险\nB. 存在数组越界风险\nC. 代码编译报错\nD. 代码无异常风险', 'A', '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (275, '哪些语句在编译时不会出现编译警告', 'A. float f = 1.3;\nB. byte b = 257;\nC. boolean b = \"isStoped\";\nD. char i = 1;', 'D', '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (276, '定义本地方法正确的是', 'A. public void native XXX();\nB. public native void XXX();\nC. public native void XXX() {}\nD. public void static native XXX();', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (277, '方法过长意味着：', 'A. 方法需要抽象\nB. 功能不单一\nC. 过于复杂\nD. 不便于他人阅读和修改代码', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (278, '包装类可以用于下面那些：', 'A. 反射方法\nB. 泛型\nC. 集合中类型\nD. POJO RPC某些不需要设置默认值的类型', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (279, '下面是字节流的是：', 'A. writer\nB. inputstream\nC. outputstream\nD. reader', 'BC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (280, '非安全的口令加密算法有：', 'A. DES\nB. RSA\nC. SKIPJACK\nD. ECDSA', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (281, 'String sql = \"select * from product where id =\" + Integer.parseInt(request.getParameter(\"id\"))该代码存在什么样的安全问题?', 'A. XSS\nB. 无安全风险\nC. 无SQL注入风险，但是将String转化为int型变量时可能会有NumberFormatException抛出\nD. SQL注入', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (282, '下列代码存在什么安全风险：\npublic static int cardinality(Object obj, final Collection<?> col) {\nint count = 0;\nif (col == null) {\nreturn count;\n}\nIterator<?> it = col.iterator();\nwhile (it.hasNext()) {\nObject elt = it.next();\nif ((null == obj && null == elt) || obj.equals(elt)) {\ncount++;\n}\n}\nreturn count;\n}', 'A. 内存溢出\nB. 内存泄露\nC. 空指针引用\nD. 无安全风险', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (283, '下面哪种操作是编程规范推荐的写法?', 'A. System.out.print(\"Hello, world!\\n\");\nB. System.out.print(\"Hello, world!\\n\\r\");\nC. stringBuilder.append(System.lineSeparator());', 'C', '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (284, '下边这段代码的输出结果为\nint fst = 5;\nint snd = 2;\nwhile (snd < fst--) {\nsnd++;\n}\nSystem.out.print(snd);', 'A. 5\nB. 2\nC. 3\nD. 4', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (285, '下列程序的输出结果为\nint num = 2;\nswitch (num) {\ncase 1:\nSystem.out.println(\"The input is 1\");\ncase 2:\nSystem.out.println(\"The input is 2\");\ncase 3:\nSystem.out.println(\"The input is 3\");\ndefault:\nSystem.out.println(\"Bad input\");\n}', 'A.\nThe input is 2\nThe input is 3\nB.\nThe input is 1\nC.\nThe input is 2\nD.\nThe input is 2\nThe input is 3\nBad input', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (286, '关于代码格式如下说法错误的是', 'A. 一个源文件按顺序包含版本、package、import、顶层类、且用空行分隔\nB. 对于非空块和块状结构，左大括号放在行尾\nC. 空行不是代码，所以代码中多写几个空行没有关系\nD. 一个类或接口的声明部分应当按照类变量、实例变量，构造器，方法的顺序出现，且用空行分隔', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (287, '哪个异常可能会泄露文件系统结构信息', 'A. java.io.FileNotFountException\nB. java.io.IOException\nC. java.util.MissResourceException\nD. java.sql.SQLException', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (288, '下列对于Stream的操作错误的是', 'A.\nfinal Stream<String> stream = Steam.of(\"Red\", \"Blue\", \"Green\");\nList<String> colors = stream.collection(Collector.toList());\nB.\nIntStream stream = IntStream.of(10, 20, 30, 40, 50);\nC.\nlong count = Stream.of().count();\nD.\nfinal Stream<String> stream = Stream.of(\"Red\", \"Blue\", \"Green\");\nSet<String> colors = Stream.toSet();', 'D', '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (289, '某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场景下会读取转储文件，下列说法错误的', 'A. 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件\nB. 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密\nC. 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除\nD. 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (290, '下列哪些行为符合安全编码规范', 'A. 某产品为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志中\nB. 某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值\nC. 某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力\nD. 某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (291, 'Java的基本类型int在不同的操作系统平台的字长是', 'A. 32位\nB. 64位\nC. 16位\nD. 在32位系统上是32位，在64位系统上是64位', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (292, '下列赋值表达式不会报错的是', 'A. boolean isStop = \"true\";\nB. float fit = 3.1;\nC. int num = 1.0;\nD. char ch = 1;', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (293, '如下代码片段，s2的结果是哪项\nString str = \"123\";\nString s2 = str + 456;', 'A. 编译错误\nB. 123456\nC. 运行时抛异常\nD. 579', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (294, '编译并运行如下Java程序，将输出\npublic static void main(String[] args) {\ntry {\nint num1 = 2;\nint num2 = 0;\nint result = num1 / num2;\nSystem.out.println(result);\n} catch (ArrayIndexOutOfBoundsException e) {\nSystem.out.println(\"1\");\n} catch (NumberFormatException e) {\nSystem.out.println(\"2\");\n} catch (Exception e) {\nSystem.out.println(\"3\");\n} finally {\nSystem.out.println(\"4\");\n}\nSystem.out.println(\"5\");\n}', 'A. 345\nB. 134\nC. 2345\nD. 1345', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (295, '在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类', 'A. Error\nB. Exception\nC. RuntimeException\nD. Throwable', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (296, '关于synchronized的叙述错误的是', 'A. 占用锁的线程在调用wait()后，会自动释放线程占有的锁\nB. sychronized在JVM层面控制线程同步\nC. 占用锁的线程在发生异常时，会自动释放线程占用的锁\nD. synchronized可用于处理读写互斥，读读不互斥的操作场景', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (297, '有关NIO Selector说法错误的是：', 'A. 可以设定Selector的监听事件，包括Connect/Accept/Read/Write\nB. Selector需要与Channel配合使用，Selector是Channel的复用器\nC. Selector本身不是一个文件，不用Close\nD. Selector等事件就绪后，才会返回，避免了大量IO阻塞', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (298, '以下命名风格正确的是：', 'A.\nenum Gender {\nmale, female\n}\nB.\nclass Test {\nprivate boolean isNotFound;\n}\nC.\nclass Test {\nprivate String userName;\n}\nD.\nclass Test {\nprivate static final int NUM_FIVE = 5;\n}', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (299, '如下代码执行结果是：\npublic class Foo {\npublic static void main(String[] args) {\nfor (float flt = (float) 1000000000; flt < 1000000010; flt++) {\nSystem.out.println(flt);\n}\n}\n}', 'A.\n1000000000\n1000000001\n1000000002\n…\n1000000010\nB. 1000000000.0\nC. 输出结果不确定\nD. 死循环', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (300, '以下代码片断输出的结果是：\npublic class Demo {\npublic static void main(String[] args) {\nInteger fst = 1;\nInteger snd = new Integer(1);\nSystem.out.println(fst == snd);\nSystem.out.println(new Integer(1) == snd);\nSystem.out.println(fst == Integer.valueOf(1));\nInteger trd = 256;\nSystem.out.println(trd == Integer.valueOf(256));\n}\n}', 'A. false,false,true,false\nB. false,false,true,true\nC. false,false,false,false\nD. true,false,false,false', 'A', '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (301, '关于遮掩，说法不正确的是', 'A. 如果一个类或者一个包被遮掩了，那么不能通过其简单名引用到它，除非是这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字\nB. 遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式\nC. 一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内\nD. 如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上', 'C', '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (302, '以下描述错误的是：', 'A. 禁止使用主动GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中\nB. 将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作\nC. 进行IO操作时，应该在try-with-resource或者finally里关闭资源\nD. 可以在循环之外的节点主动GC', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (303, '执行如下语句，最终会运行什么文件？\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\");', 'A. 仅运行test.bat，并将notepad.exe作为test.bat的参数\nB. 仅运行notepad.exe\nC. 仅运行test.bat\nD. 运行test.bat和notepad.exe', 'D', '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (304, '以下Stream用法不正确的是', 'A. long test = Stream.of(\"1\",\"2\").count()\nB. List testList = Stream.of(\"1\",\"2\").collect(Collectors.toList())\nC. IntStream t = IntStream.of(10,20,30);\nD. Stream.of(\"1\",\"2\").toSet()', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (305, '可转换为double的数据类型有哪些？', 'A. byte\nB. String\nC. float\nD. long', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (306, 'interface不能被哪些修饰词修饰?', 'A. protected\nB. final\nC. public\nD. private', 'ABD', '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (307, '以下关于抽象类的描述正确的是', 'A. 必须定义前缀为abstract\nB. 所有方法必须定义为抽象\nC. 抽象类可以实例化\nD. 抽象类必须包含一个抽象方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (308, '字节流、字符流区别描述正确的是：', 'A. 字节流关注流，不关注内容，字符流按行读取，关注文本\nB. 字节流的基类InputStream/OutputStream，字符流是Reader/Writer\nC. 字符流是对字节流的装饰，释放时反向逐一关闭\nD. 字符流最终都会按照字节流处理', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (309, '关于方法返回值描述错误的是：', 'A. 方法的返回值必须被正确解析或者使用\nB. 方法可以没有返回值\nC. 返回值可以没有被用到\nD. 方法的返回值可被忽略', 'D', '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (310, '下列接口描述正确的是：', 'A. 类可以多重继承，接口可以多重继承\nB. 类可以多重继承，接口可以单重继承\nC. 类可以单重继承，接口可以多重继承\nD. 类可以单重继承，接口可以单重继承', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (311, '接口ableA，ableB下面正确的是：', 'A. class Test implements ableA, ableB\nB. class Test implements ableA, implements ableB\nC. interface Test implements ableA, implements ableB\nD. interface Test implements ableA, ableB\nE. interface Test extends ableA, ableB', 'AE', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (312, 'JDBC数据库连接的对象类型是：', 'A. Statement\nB. Connection\nC. DriverManager\nD. PreparedStatement', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (313, '关于Java8 Stream的描述正确的是', 'A. Stream跟迭代器类似，再次遍历需要重新生成\nB. Stream执行方式跟之前代码处理方式类似，中间操作立即执行\nC. 对Stream修改体现到数据源上\nD. Stream数据源只能是数组、容器或I/O', 'A', '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (314, '根据安全编程规范，Java类加载表述正确的是：', 'A. URLClassLoader的默认签名检查依赖jar包中的公钥，因此不能仅依赖该机制对jar包进行合法性检查\nB. 开发者不可以自定义类加载器\nC. 在JVM中，将不同ClassLoader实例加载的同一个类视为相同类\nD. 当自定义一个类加载器时，为了保证赋予权限的完整，应该直接覆写getPermissions()方法，无需调用基类的getPermission()方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (315, '以下代码可能导致命令注入的有', 'A.\nString encodeIP = HWEncoder.encodeForOS(new WindowsCodec(), args[0]);\nString cmd = \"cmd.exe /c ping \" + encodeIP;\nB.\nif (Pattern.matches(\"[0-9A-Za-z@]+\", dir)) {\nProcess proc = rt.exec(\"cmd.exec /c \" + dir);\n}\nC.\nFile dir = new File(args[0]);\nif (!validate(dir)) {\nSystem.out.println(\"An illegal directory\");\n}\nD.\nProcessor proc = rt.exec(\"cmd.exe /c dir \" + args[0]);', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (316, '如下哪些是immutable的？', 'A. char\nB. String\nC. short\nD. Integer', 'BD', '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (317, '关于类加载器以下说法正确的是：', 'A. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader', 'ABC', '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (318, 'String str = \"a\" + \"b\" + \"c\" + \"d\";总共会创建几个对象？', 'A. 1\nB. 2\nC. 3\nD. 4\nE. 5', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (319, '下面程序的输出是：\nint count1 = 0;\nfor (int rowNum = 0; rowNum < 3; rowNum++) {\nfor (int colNum = 0; colNum < 4; colNum++) {\nif (colNum % 2 == 1) {\ncontinue;\n}\ncount1++;\n}\n}\nint count2 = 0;\nfor (int rowNum = 0; rowNum < 3; rowNum++) {\nfor (int colNum = 0; colNum < 4; colNum++) {\nif (colNum % 2 == 1) {\nbreak;\n}\ncount2++;\n}\n}\nSystem.out.println(count1 + \",\" + count2);', 'A. 6, 6\nB. 9, 6\nC. 3, 3\nD. 6, 3', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (320, '下列说法错误的是：', 'A. TreeMap可以有\'null\'的key和value\nB. HashTable不允许有\'null\'的key和value\nC. HashMap线程不安全，但效率高\nD. HashTable是线程安全的，推荐使用', 'A', '解析：\nTreeMap键可以为\'null\'，值不允许', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (321, '关于HashMap的描述，以下说法错误的是：', 'A. HashMap能够保证其中元素的顺序\nB. HashMap允许将\'null\'作为值\nC. HashMap允许将\'null\'用作键\nD. HashMap使用键值的形式保存数据', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (322, '属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是', 'A.\npublic class GpsLocation implements Serializable {\nprivate double from;\nprivate double to;\nprivate String id; // non-sensitive field\n// other content\n}\nB.\npublic class GpsLocation implements Serializable {\nprivate double from;\nprivate double to;\nprivate String id; // non-sensitive field\n// other content\nprivate static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"id\", String.class)};\n}\nC.\npublic class GpsLocation implements Serializable {\nprivate volatile double from;\nprivate volatile double to;\nprivate String id; // non-sensitive field\n// other content\n}\nD.\npublic class GpsLocation implements Serializable {\nprivate transient double from;\nprivate transient double to;\nprivate String id; // non-sensitive field\n// other content\n}', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (323, '关于File的描述，正确的是', 'A. File实例不能用于封装目录只用于封装文件\nB. 创建一个File类的实例将导致打开指定文件进行读写\nC. File实例封装了指定文件的信息\nD. File类位于jav.io包中', 'CD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (324, 'Java NIO Channel通道和IO流的区别，说法正确的是：', 'A. 通道可以异步读写，流是同步读写\nB. 通道和流都可以支持Selector选择器多路复用\nC. 通道可以读也可以写，流一般来说是单向的\nD. 通道是面向缓冲区的，流是面向流的', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (325, '以下哪些关键字是与线程安全相关的', 'A. const\nB. synchronized\nC. protected\nD. volatile', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (326, '关于CountDownLatch的描述，正确的是', 'A. CountDownLatch.countDown()计数为0就会释放所有线程\nB. CountDownLatch计数为0后，无法重置\nC. CountDownLatch.countdown()为计数减控制\nD. CountDownLatch.await()只能触发阻塞等待，计数不会-1', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (327, '关于锁的说法错误的是', 'A. Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例\nB. 使用new出来的Integer实例作为对象的内置锁可能导致死锁\nC. 在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁\nD. Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (328, '关于多线程并发如下说法正确的是：', 'A. 对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁\nB. 能用无锁数据结构，就不要用锁\nC. 能用对象锁，就不要用类锁\nD. 能锁区块，就不要锁方法体', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (329, 'Java语言中，如果编写一个多线程程序，可以使用的方法是', 'A. 扩展类Thread\nB. 实现Runnable接口\nC. 实现接口Thread\nD. 扩展类Runnable', 'AB', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (330, '在java中，使用JDBC时，使用PreparedStatement执行sql语句有哪些好处', 'A. 使用PreparedStatement进行sql注入防护是优选方案\nB. 使用PreparedStatement多次执行同一条sql语句可以提升执行的效率\nC. 使用PreparedStatement可以有效解决所有的sql注入问题\nD. 正确使用PreparedStatement，可以有效防止sql注入的发生', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (331, '如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 \' 、 \" 符号转义，请问如下针对mysql数据库的查询中，哪条是有可能受到sql注入攻击的？', 'A. \"select * from users where id=\" + request.getParameter(\"id\");\nB. \"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";\nC. \"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";\nD. \"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (332, '以下路径属于标准化路径（Canonical Path）的是：', 'A. ~/test\nB. /opt/oss/log\nC. $ROOT/etc/conf\nD. /opt/oss/../../etc', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (333, '关于主动调用gc方法的描述，下列说法正确的是', 'A. 在频率/周期性的逻辑中更要尽量避免主动GC的调用\nB. 在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险\nC. 调用主动GC方法后，系统立即进行垃圾回收操作\nD. 如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (334, '正则表达式/a+(bab)?(caac)*/，下列选项中是该正则表达式的子集是?', 'A. /(bab)(caca)/\nB. /a(bab){2}(caac)*/\nC. /a{2}/(*)\nD. /a+(bab){0,1}(ca)+(ca)/\nE. /a(^bab)+(caac){1,}/\nF. /a+(babc){2,}(acc){1,}/', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (335, '将含敏感数据的对象跨信任域传递前应该', 'A. 先签名再加密后传输\nB. 加密传输\nC. 先加密再签名后传输\nD. 签名传输', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (336, '对于下面的代码片段，假设PasswordManager的实例可以被非信任代码所访问，且changePassword()方法调用属于敏感操作，则下列说法中不正确的是：\npublic class PasswordManager\n{\npublic final Object lock = new Object();\npublic void changePassport() throws FileNotFoundException\n{\nsynchronized(lock)\n{\n// ...\n}\n}\n}', 'A. 可以省去changePasword()方法中的同步块，直接将changePasword()方法声明为synchronized修饰的同步方法\nB. changePassport()方法中应该包含安全管理器检查，以确认调用代码是否具有该操作权限\nC. 将该lock成员变量的可见性声明为private\nD. changePassport()方法不应该抛出FileNotFoundException异常', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (337, '若程序中需要获取操作系统登录用户名，应采取下列哪种方法来获取：', 'A. 提示用户输入\nB. 由环境变量获取:System.getenv(\"USER\")\nC. 由JVM属性获取:System.getProperty(\"user.name\")\nD. 启动程序的时候由程序参数传入', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (338, '下列有关Map的操作错误的是：', 'A.\nMap<Integer, String> cityMap = new HashMap<>() {\n{\nput(1, \"Nanjing\");\nput(2, \"Beijing\");\nput(3, \"Shanghai\");\n}\n}\nB.\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\nSystem.out.println(city.getValue());\n}\nC.\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4, null);\nD.\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (339, '有关泛型，下面说法错误的是：', 'A. extends约束类型上限，如public int add(T n1, T n2); 表示方法参数必须是Number的子类型\nB. List numList = new ArrayList();\nList intList = new ArrayList();\n因为Integer是Number的子类，所以intList可以赋值给numberList\nC. 对于同一个类，可以使用不同的泛型参数类型声明类型和方法\nD. 泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考，当实例化时，使用具体的类型替代，这是实参', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (340, '下面的程序创建了一个文件输出流对象，用来向文件test.txt中输出数据。假设程序当前运行目录下不存在文件test.txt，编译后执行三次结果为\nimport java.io.*;\nimport java.nio.charset.StandardCharsets;\npublic class Test {\npublic static void main(String[] args) {\ntry {\nString str = \"ABCDE\";\nbyte[] bs = str.getBytes(StandardCharsets.UTF_8);\nFileOutputStream file = new FileOutputStream(\"test.txt\", true);\nfile.write(bs);\nfile.close();\n} catch (IOException e) {\nSystem.out.println(e.toString());\n}\n}\n}', 'A. ABCABC\nB. Test\nC. ABCDEABCDEABCDE\nD. ABCDE', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (341, 'Java中如何释放掉一个指定占据的内存空间', 'A. 程序员无法明确强制垃圾回收器运行\nB. 调用free()方法\nC. 赋值给该对象的引用为null\nD. 调用System.gc()方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (342, '以下描述错误的是', 'A.\npublic String getProductSummary(int index) {\nreturn products[index];\n}\n//该代码中index未校验，可能相起数组越界访问\nB.\nString userName = \"name\";\nResultSet rs = st.executeQuery(\"select * from user where name = \'\" + userName + \"\'\");\n//该代码可能会产生SQL注入漏洞\nC.\nRuntime.getRuntime().exec(\"cmd.exe /c dir \" + args[0]);\n//该代码可能会引起命令注入\nD.\nString command = System.getProPerty(\"command\");\nRuntime.getRuntime().exec(\"command\");\n//该代码可能会引起OS命令注入', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (343, '关于异常的说法错误的是', 'A. BindException异常泄露时可能造成开放端口列举\nB. 当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤\nC. FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构\nD. 可以在代码最外层捕获NullPointException防止代码出现预期之外的行为', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (344, '下面关于异常处理描述错误的是', 'A. FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常\nB. 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理\nC. 输入校验是一个常用的防止通过异常泄露敏感信息的方式\nD. 必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (345, 'Java IO Buffer状态变量不包括', 'A. capacity：最大容量\nB. flag：读写状态位\nC. position：当前已经读到的字节数\nD. limit：剩下的字节数', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (346, '关于sleep()和wait()，以下描述错误的是', 'A. sleep不释放对象锁，wait放弃对象锁\nB. sleep暂停线程，但监控状态仍然保持，结束后会自动恢复\nC. wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态\nD. sleep是线程类（Thread）的方法，wait是Object类的方法', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (347, 'Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流', 'A. 错误流\nB. 监控流\nC. 输出流\nD. 输入流', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (348, '下列单例实现正确的是', 'A.\npublic final class Helper {\npublic Helper() { }\n}\nfinal class Foo {\nprivate Helper helper = null;\npublic Helper getHelper() {\nif (helper == null) {\nsynchronized (this) {\nif (helper == null) {\nhelper = new Helper();\n}\n}\n}\nreturn helper;\n}\n}\nB.\npublic final class Helper {\nprivate final int n;\npublic Helper(int n) {\nthis.n = n;\n}\n}\nfinal class Foo {\nprivate Helper helper = null;\npublic Helper getHelper() {\nHelper h = helper;\nif (h == null) {\nsynchronized (this) {\nh = helper;\nif (h == null) {\nh = new Helper(42);\nhelper = h;\n}\n}\n}\nreturn h;\n}\n}\nC.\npublic final class Helper {\nprivate final int n;\npublic Helper(int n) {\nthis.n = n;\n}\n}\nfinal class Foo {\nprivate Helper helper = null;\npublic Helper getHelper() {\nif (helper == null) {\nsynchronized (this) {\nif (helper == null) {\nhelper = new Helper(42);\n}\n}\n}\nreturn helper;\n}\n}\nD.\npublic final class Helper {\npublic Helper() {}\n}\nfinal class Foo {\nprivate static class Holder {\nstatic Helper helper = new Helper();\n}\npublic Helper getInstance() {\nreturn Holder.helper;\n}\n}', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (349, '有关线程池关闭，以下说法正确的有', 'A. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，直到线程池中等待的任务全部处理完\nB. 执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出\nC. 执行shutdown方法后，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出\nD. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池试图停止所有正在执行的线程，不再处理池中等待的任务', 'CD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (350, '下列哪些是线程同步的？', 'A. TreeSet\nB. HashTable\nC. Vector\nD. LinkedList', 'BC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (351, '已知如下代码\npublic static void main(String[] args) {\nint nr = 5;\ndo {\nSystem.out.print(nr);\n} while (--nr > 5);\nSystem.out.print(\"finished\");\n}\n执行后的输出包含什么？', 'A. 5\nB. 4\nC. finished\nD. 6', 'AC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (352, '关于数据校验的说法正确的是', 'A. 在对不可信数据进行校验时，禁止使用assert语句\nB. \"白名单\"净化的方式包括删除，编码，替换\nC. \"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新，该校验方式就会很快过时\nD. 尽可能使用接收一直合法数据的白名单策略', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (353, '仅保存口令hash，不加盐的缺陷有', 'A. 攻击者可以使用事先计算好的哈希列表在几秒钟之内破解口令\nB. 加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加\nC. 没有盐值，攻击者可以根据哈希值反向解密出原始口令\nD. 由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (354, '关于异常，下列说法正确的是：', 'A. 如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码\nB. 方法抛出的异常，应该与本身的抽象层次相对应\nC. 对可容错处理的情况使用受检异常，对编程错误使用运行时异常\nD. 一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中记录每个抛出的异常及其条件', 'BCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (355, '如下四种数组声明方式，哪种不正确？', 'A. int[] hello1 = {1, 2, 3, 4};\nB. int[] hello2 = new int[4]{1, 2, 3, 4};\nC. int[] hello3 = new int[]{1, 2, 3, 4};\nD. int[] hello4 = new int[4];', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (356, 'Java语言中，下面哪个语句是创建数组的正确语句？', 'A. float f[][] = new float[6][6];\nB. float []f[] = new float[6][6];\nC. float f[][] = new float[][6];\nD. float[][] f = new float[6][6];\nE. float[][] f = new float[6][];', 'DE', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (357, '哪些数据类型能直接输出？', 'A. int[] test = {1, 2, 3, 4, 5};\nB. List list = new LinkedList<>();\nC. Map<Integer, Integer> map = new HashMap<>();\nD. List list = new ArrayList<>();', 'BCD', '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (358, '与表达式Integer a = 2;等价的类型是哪个？', 'A. int b = Integer.parseInt(\"2\");\nB. Integer b = Integer.valueOf(\"2\");', 'B', '解析：\nInteger.valueOf(value)在-128~127间，则会重用内存中缓存的对象', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (359, '哪些语句在编译时不会出现编译警告', 'A. float f = 1.3;\nB. byte b = 257;\nC. boolean b = null;\nD. int i = 10;', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (360, '有一个模拟赛跑游戏，运动员有跑得快的也有跑得慢的，运动员听到枪声后开始起跑，而最后一个运动员到达终点后，标志着比赛的结束。当前场景下，适合采用哪种线程同步机制?', 'A. CountDownLatch\nB. CyclicBarrier\nC. Semaphore\nD. BlockingQueue', 'A', '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (361, '20个人去银行存款，但是该银行只有两个办公柜台，有空位则上去存钱，没有空位则只能去排队等待，适合采用哪种线程同步机制', 'A. Semaphore信号量\nB. CountDownLatch\nC. CyclicBarrier\nD. BlockingQueue', 'A', '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (362, '下列哪种情况可以终止当前线程的运行？', 'A. 当一个优先级高的线程进入就绪状态时\nB. 当该线程调用sleep()方法时\nC. 当创建一个新线程时\nD. 抛出一个异常时', 'D', '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (363, '以下NIO语句是否有错误？', 'A. 大二进制文件读入\nB. 小二进制文件读入\nC. 小文本按行读入\nD. 小文本按字节数读入\nE. 结尾插入数据采用.APPEND而不是.CREATE', 'E', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (364, '下面字段声明中哪一个在interface主体内是合法的?', 'A. private final static int answer = 42;\nB. public static int answer = 42;\nC. final static answer = 42;\nD. int answer;', 'B', '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (365, '如下描述错误的是：', 'A. StackOverflowError是堆栈内存溢出\nB. OutOfMemoryError：Perm Gen是老年代内存溢出\nC. Java Heap Space溢出时，会导致所有线程暂停工作', 'B', '解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 0, 0);
INSERT INTO `question` VALUES (366, '107. 按照编程规范，下列哪些信息时禁止输入到日志中的', 'A．事件发生的时间、事件类型\nB．密钥\nC．明文口令\nD．密文口令', 'BCD', '', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (367, '108. 有关类加载器的双亲委派模型说法错误的是', 'A. 类加载器之间是有层次结构的\nB. 加载不到类，会抛出ClassNotFoundException();\nC. 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\nD. 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载', 'C', '', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
