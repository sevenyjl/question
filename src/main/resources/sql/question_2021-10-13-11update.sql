UPDATE question  SET title='下列说法错误的是（）',options='A 反射可以获取类的构造器B 反射可获以Method,通过invoke进行方法的调用；C 反射可以获取注解（@Target为Runtime）信息；D 反射能够直接get(obj)获取私有的Field成员的值；',answer='CD',parsing='A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法B:通过getMethods能获取方法并使用invoke进行调用C:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置D:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值故选择：CD',original_information='1、 下列说法错误的是（）A 反射可以获取类的构造器B 反射可获以Method,通过invoke进行方法的调用；C 反射可以获取注解（@Target为Runtime）信息；D 反射能够直接get(obj)获取私有的Field成员的值；答案：CD',q_type='MULTI_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=1;
UPDATE question  SET title='下列程序执行结果说法正确的（）public class Test {    public static void main(String[] args) {        List<String> list = new ArrayList<>();        list.add(\"str1\");        list.add(2, \"str2\");        String str = list.get(1);        System.out.println(str);    }}',options='A 编译时出现异常；B 正确运行，输出str1;C 正确运行，输出str2;D 运行时出现异常',answer='D',parsing='运行时list.add(2, \"str2\");报错，因为ArrayList在添加前会调用rangeCheckForAdd方法判断当前索引是否大于了当前数组的size一句话list.add(2, \"str2\")只能替换不能追加',original_information='2、 下列程序执行结果说法正确的（）1public class Test {23public static void main(String[]args) {4List<String> list = new ArrayList<>();5list.add(\"str1\");6list.add(2,\"str2\");7String str = list.get(1);8System.out.println(str);9}10}A 编译时出现异常；B 正确运行，输出str1;C 正确运行，输出str2;D 运行时出现异常答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=2;
UPDATE question  SET title='下边这段代码的输出结果为（）int fst = 5;int snd = 2;while (snd < fst--) {    snd++;}System.out.print(snd);',options='A 5B 2C 3D 4',answer='D',parsing='fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34',original_information='3、 下边这段代码的输出结果为（）1int fst = 5;2int snd = 2;3while(snd < fst--) {4snd++;5}6System.out.print(snd);A 5B 2C 3D 4答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=3;
UPDATE question  SET title='下列程序的输出结果为（）（一旦匹配，立即顺序执行；包装类型也是可以接受的）int num = 2;switch (num) {    case 1:        System.out.println(\"The input is 1\");    case 2:        System.out.println(\"The input is 2\");    case 3:        System.out.println(\"The input is 3\");    default:        System.out.println(\"Bad input\");}',options='AThe input is 2​The input is 3B The input is 1C The input is 2D The input is 2​The input is 3​Bad input',answer='D',parsing='switch没有break会执行完后面的如果        int num = 2;        switch (num) {            case 2:                System.out.println(\"The input is 2\");            case 1:                System.out.println(\"The input is 1\");            case 3:                System.out.println(\"The input is 3\");            default:                System.out.println(\"Bad input\");        }会输出213 Bad input',original_information='4、 下列程序的输出结果为（）（一旦匹配，立即顺序执行；包装类型也是可以接受的）1int num=2;2switch(num) {3case 1:4System.out.println(\"The input is 1\");5case 2:6System.out.println(\"The input is 2\");7case 3:8System.out.println(\"The input is 3\");9default :10System.out.println(\"Bad input\");11}A The input is 2​The input is 3B The input is 1C The input is 2D The input is 2​The input is 3​Bad input答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=4;
UPDATE question  SET title='下列对于Stream的操作错误的是：',options='A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");List<String> colors = stream.collection(Collector.toList());B IntStream stream IntStream.of(10,20,30,40,50);C long count = Stream.of().count();D final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");Set<String> colors = Stream.toSet();（根本就没有你的这种用法）',answer='D',original_information='8、 下列对于Stream的操作错误的是：1A final Stream<String> stream = Steam.of(\"Red\",\"Blue\",\"Green\");2List<String> colors = stream.collection(Collector.toList());3B IntStream stream IntStream.of(10,20,30,40,50);4C long count = Stream.of().count();5D final Stream<String> stream = Stream.of(\"Red\",\"Blue\",\"Green\");6Set<String> colors = Stream.toSet();（根本就没有你的这种用法）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=8;
UPDATE question  SET title='下列关于Thread类提供的线程控制方法的说法中，错误的是（）',options='A currentThread()方法返回当前线程的引用B 线程A通过调用interrupt()方法来中断其阻塞状态C 线程A中执行线程B的join()方法，则线程A等待直到B执行完成D 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。',answer='D',original_information='9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）A currentThread()方法返回当前线程的引用B 线程A通过调用interrupt()方法来中断其阻塞状态C 线程A中执行线程B的join()方法，则线程A等待直到B执行完成D 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=9;
UPDATE question  SET title='某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）',options='A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件B 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密C 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；D 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640',answer='D',parsing='D:看来权限是给高了，个人感觉是不是600就可以了',original_information='10、某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件B 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密C 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；D 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640（看来权限是给高了）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=10;
UPDATE question  SET title='下列赋值表达式不会报错的是（）',options='A boolean isStop = “true”;B float fit = 3.1;C int num = 1.0;D char ch = 1;（char可以容纳的数字范围是多少）',answer='D',original_information='14、下列赋值表达式不会报错的是（）A boolean isStop = “true”;B float fit = 3.1; // float fit = 3.1f;C int num = 1.0;D char ch = 1;（char可以容纳的数字范围是多少）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=14;
UPDATE question  SET title='下列赋值表达式不会报错的是（）',options='A boolean isStop = “true”;B float fit = 3.1;C int num = 1.0;D char ch = 1;',answer='B',parsing='float fit = 3.1--->>float fit = 3.1f',original_information='14、下列赋值表达式不会报错的是（）A boolean isStop = “true”;B float fit = 3.1; // float fit = 3.1f;C int num = 1.0;D char ch = 1;（char可以容纳的数字范围是多少）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=14;
UPDATE question  SET title='下列赋值表达式不会报错的是（）',options='A boolean isStop = “true”;B float fit = 3.1;C int num = 1.0;D char ch = 1;',answer='D',parsing='A:用Boolean.parseBoolean(\"true\")B:float fit = 3.1--->>float fit = 3.1fC:int 只能是整数D：正确',original_information='14、下列赋值表达式不会报错的是（）A boolean isStop = “true”;B float fit = 3.1; // float fit = 3.1f;C int num = 1.0;D char ch = 1;（char可以容纳的数字范围是多少）答案：D',q_type='SINGLE_CHOICE',hide_answer=1,likeable=1,doubtful=1  WHERE id=14;
