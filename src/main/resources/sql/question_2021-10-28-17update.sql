INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下关于java Stream的描述正确的是( )','A. 	Stream执行方式跟之前代码处理方式类似，中间操作是立即执行的。B. 	Stream数据源只能是数组、容器或者I/O。C. 	对Stream的修改都会体现到数据源上。D. 	Stream跟迭代器类似，再次遍历需要重新生成。','C','C以下关于java Stream的描述正确的是( )A. 	Stream执行方式跟之前代码处理方式类似，中间操作是立即执行的。B. 	Stream数据源只能是数组、容器或者I/O。C. 	对Stream的修改都会体现到数据源上。D. 	Stream跟迭代器类似，再次遍历需要重新生成。','SINGLE_CHOICE',1,1,1 ,825);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '执行如下语句，最终会运行什么文件（ ）Runtime.getRuntime().exec(\"test.bat & notepad.exe\");','A. 	仅运行test.batB. 	仅运行notepad.exeC. 	仅运行test.bat，并将notepad.exe作为test.bat的参数D. 	运行test.bat和notepad.exe','D','D执行如下语句，最终会运行什么文件（ ）Runtime.getRuntime().exec(\"test.bat & notepad.exe\");A. 	仅运行test.batB. 	仅运行notepad.exeC. 	仅运行test.bat，并将notepad.exe作为test.bat的参数D. 	运行test.bat和notepad.exe','SINGLE_CHOICE',1,1,1 ,826);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下程序的输出为（）String s = \"123456\";String s1 = \"123456\";String s2 = \"123\" + \"456\";String s3 = \"456\";String s4 = \"123\" + s3;System.out.print (s == s1);System.out.print (s == s2);System.out.print (s == s4);','A. 	false false falseB. 	true false falseC. 	true true falseD. 	true true true','C','C如下程序的输出为（）String s = \"123456\";String s1 = \"123456\";String s2 = \"123\" + \"456\";String s3 = \"456\";String s4 = \"123\" + s3;System.out.print (s == s1);System.out.print (s == s2);System.out.print (s == s4);A. 	false false falseB. 	true false falseC. 	true true falseD. 	true true true','SINGLE_CHOICE',1,1,1 ,827);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '有以下一段代码：public class PrintCollection {    public void print(List<String> collection) {        Collections.sort(collection, (s1, s2) -> s1.compareTo(s2));        collection.stream().forEach(System.out::println);    }    public static void main(String[] args) {        List<String> list1 = Arrays.asList(\"4\", \"3\", \"2\", \"1\");        PrintCollection printer = new PrintCollection();        printer.print(list1);    }}请问使用以下哪条命令编译无编译错误？','A. 	javac -source 5 -Xlint:all PrintCollection.javaB. 	javac -source 6 -Xlint:all PrintCollection.javaC. 	javac -source 7 -Xlint:all PrintCollection.javaD. 	javac -source 8 -Xlint:all PrintCollection.java','D','D有以下一段代码：public class PrintCollection {    public void print(List<String> collection) {        Collections.sort(collection, (s1, s2) -> s1.compareTo(s2));        collection.stream().forEach(System.out::println);    }    public static void main(String[] args) {        List<String> list1 = Arrays.asList(\"4\", \"3\", \"2\", \"1\");        PrintCollection printer = new PrintCollection();        printer.print(list1);    }}请问使用以下哪条命令编译无编译错误？A. 	javac -source 5 -Xlint:all PrintCollection.javaB. 	javac -source 6 -Xlint:all PrintCollection.javaC. 	javac -source 7 -Xlint:all PrintCollection.javaD. 	javac -source 8 -Xlint:all PrintCollection.java','SINGLE_CHOICE',1,1,1 ,828);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '无情重构又称童子军原则，指你打开一个代码，如果很难理解，就应该试着去重构它，你离开的时候代码应该比你来的时候更易懂。但是通常我们由于缺乏足够的知识，不能在无情重构中进行复杂的重构，常常以抽取函数为主，但不好的抽取并不能让代码更易理解，反而更复杂。那么今天，你打开了下列的代码，可能不清楚具体的业务背景，但请尝试用函数抽取的方式进行无情重构。你觉得哪部分代码被抽出去作为一个函数，并不能提升代码的可读性（请忽略不同编程语言的规范和语法差异）。( )1 public class BusinessSite {2     private Reading[] readings = new Reading[1000];3     private static final double START_RATE = 0.09;4     private static double END_RATE = 0.05;5     private static int END_AMOUNT = 1000;6 7     public void addReading(Reading newReading) {8         readings[++lastReading] = newReading;9     }10 11    private int lastReading;12 13    public Dollars charge() {14        Dollars result;15        int usage = readings[lastReading].getAmount() - readings[lastReading - 1].getAmount();16        if (usage == 0) {17            return new Dollars(0);18        }19        double t1 = START_RATE - ((END_RATE * END_AMOUNT) - START_RATE) / (END_AMOUNT - 1);20        double t2 = ((END_RATE * END_AMOUNT) - START_RATE) * Math.min(END_AMOUNT, usage) /21                (END_AMOUNT - 1);22        double t3 = Math.max(usage - END_AMOUNT, 0) * END_RATE;23        result = new Dollars(t1 + t2 + t3);24        result = result.plus(new Dollars(usage * 0.0175));2526        Dollars base1 = new Dollars(result.min(new Dollars(50)).times(0.07));27        if (result.isGreaterThan(new Dollars(50))) {28            base1 = new Dollars(base1.plus(result.min(new Dollars(75)).minus(29                    new Dollars(50)).times(0.06)30            ));31        }32        if (result.isGreaterThan(new Dollars(75))) {33            base1 = new Dollars(base1.plus(result.minus(new Dollars(75)).times(0.05)));34        }35        result = result.plus(base1);36        return result;37   }38 }','A. 	第15行B. 	第19～23行C. 	第26～34行D. 	第14～24行','A','A无情重构又称童子军原则，指你打开一个代码，如果很难理解，就应该试着去重构它，你离开的时候代码应该比你来的时候更易懂。但是通常我们由于缺乏足够的知识，不能在无情重构中进行复杂的重构，常常以抽取函数为主，但不好的抽取并不能让代码更易理解，反而更复杂。那么今天，你打开了下列的代码，可能不清楚具体的业务背景，但请尝试用函数抽取的方式进行无情重构。你觉得哪部分代码被抽出去作为一个函数，并不能提升代码的可读性（请忽略不同编程语言的规范和语法差异）。( )1 public class BusinessSite {2     private Reading[] readings = new Reading[1000];3     private static final double START_RATE = 0.09;4     private static double END_RATE = 0.05;5     private static int END_AMOUNT = 1000;6 7     public void addReading(Reading newReading) {8         readings[++lastReading] = newReading;9     }10 11    private int lastReading;12 13    public Dollars charge() {14        Dollars result;15        int usage = readings[lastReading].getAmount() - readings[lastReading - 1].getAmount();16        if (usage == 0) {17            return new Dollars(0);18        }19        double t1 = START_RATE - ((END_RATE * END_AMOUNT) - START_RATE) / (END_AMOUNT - 1);20        double t2 = ((END_RATE * END_AMOUNT) - START_RATE) * Math.min(END_AMOUNT, usage) /21                (END_AMOUNT - 1);22        double t3 = Math.max(usage - END_AMOUNT, 0) * END_RATE;23        result = new Dollars(t1 + t2 + t3);24        result = result.plus(new Dollars(usage * 0.0175));2526        Dollars base1 = new Dollars(result.min(new Dollars(50)).times(0.07));27        if (result.isGreaterThan(new Dollars(50))) {28            base1 = new Dollars(base1.plus(result.min(new Dollars(75)).minus(29                    new Dollars(50)).times(0.06)30            ));31        }32        if (result.isGreaterThan(new Dollars(75))) {33            base1 = new Dollars(base1.plus(result.minus(new Dollars(75)).times(0.05)));34        }35        result = result.plus(base1);36        return result;37   }38 }A. 	第15行B. 	第19～23行C. 	第26～34行D. 	第14～24行','SINGLE_CHOICE',1,1,1 ,829);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '基于《密码算法应用规范》,下列哪种随机数生成方式自身会出现安全漏洞？A. 	Linux操作系统的/dev/random设备接口B. 	OpenSSL1.1.X的RAND_priv_bytesC. 	NIST SP 800-90','A标准中的DualEC-DRBG生成器D. 	JDK的java.security.SecureRandom','A','A基于《密码算法应用规范》,下列哪种随机数生成方式自身会出现安全漏洞？A. 	Linux操作系统的/dev/random设备接口B. 	OpenSSL1.1.X的RAND_priv_bytesC. 	NIST SP 800-90A标准中的DualEC-DRBG生成器D. 	JDK的java.security.SecureRandom','SINGLE_CHOICE',1,1,1 ,830);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '两台设备间需要通过外部网络传输和协商秘钥信息，为了防止传输过程中信息被攻击者篡改，下面哪个方法可以识别出信息被篡改：A. 	使用CRC32校验B. 	使用SHA512校验C. 	使用','ASE256进行加密保护D. 	使用TLS协议来传输信息','B','B两台设备间需要通过外部网络传输和协商秘钥信息，为了防止传输过程中信息被攻击者篡改，下面哪个方法可以识别出信息被篡改：A. 	使用CRC32校验B. 	使用SHA512校验C. 	使用ASE256进行加密保护D. 	使用TLS协议来传输信息','SINGLE_CHOICE',1,1,1 ,831);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '一点都不会！哈希表有14个桶，哈希函数为h(key)=key%11。表中现有数据30、48、66、18、72和90，如果分别采用线性探测法和二次探测再散列处理冲突，则28的位置（从0开始计数）可能是（）A','. 	9B. 	10C. 	11D. 	12','AC','AC一点都不会！哈希表有14个桶，哈希函数为h(key)=key%11。表中现有数据30、48、66、18、72和90，如果分别采用线性探测法和二次探测再散列处理冲突，则28的位置（从0开始计数）可能是（）A. 	9B. 	10C. 	11D. 	12','MULTI_CHOICE',1,1,1 ,832);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '针对重构方法，下列说法错误的是（）A','. 	提取接口（Extract Interface）和提取超类（Extract Superclass）本质上是一回事，均可提取通用代码。B. 	隐藏委托关系（Hide Delegate）会使代码层次更清晰，因此委托类的功能越多越好。C. 	当发现某个子类并未带来该有的派生价值时，可以考虑使用移除子类（Remove Subclass）手法进行重构。D. 	将值域上移到父类（即字段上移 Pull Up Field）会有效减少子类的成员变量，只需要搬移值域，不需要搬移对该值域的操作方法。','BD','BD针对重构方法，下列说法错误的是（）A. 	提取接口（Extract Interface）和提取超类（Extract Superclass）本质上是一回事，均可提取通用代码。B. 	隐藏委托关系（Hide Delegate）会使代码层次更清晰，因此委托类的功能越多越好。C. 	当发现某个子类并未带来该有的派生价值时，可以考虑使用移除子类（Remove Subclass）手法进行重构。D. 	将值域上移到父类（即字段上移 Pull Up Field）会有效减少子类的成员变量，只需要搬移值域，不需要搬移对该值域的操作方法。','MULTI_CHOICE',1,1,1 ,833);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下面哪些设计是符合权限最小化要求的？（）A. 	一个帐号只能拥有该角色必需的权限，不分配不必要的权限。B. 	权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则。C. 	为保证有足够权限读取到数据，连接Web服务数据库应该使用Ad','ministrator帐号。D. 	审计日志只有管理员或日志审计员有权限读取，普通用户无法访问读取。','ABD','ABD下面哪些设计是符合权限最小化要求的？（）A. 	一个帐号只能拥有该角色必需的权限，不分配不必要的权限。B. 	权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则。C. 	为保证有足够权限读取到数据，连接Web服务数据库应该使用Administrator帐号。D. 	审计日志只有管理员或日志审计员有权限读取，普通用户无法访问读取。','MULTI_CHOICE',1,1,1 ,834);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '下面保护操作系统的做法正确的有（ ）A. 	关闭没有使用的服务，如：Telnet和FTPB. 	对存有重要信息的文件目录或分区进行加密C. 	启用SELinux，增强系统安全性D. 	使用Aud','itd组件对系统中的重要目录或文件进行审计','ABCD','ABCD下面保护操作系统的做法正确的有（ ）A. 	关闭没有使用的服务，如：Telnet和FTPB. 	对存有重要信息的文件目录或分区进行加密C. 	启用SELinux，增强系统安全性D. 	使用Auditd组件对系统中的重要目录或文件进行审计','MULTI_CHOICE',1,1,1 ,835);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '根据华为Java编程规范,下列选项中变量声明错误的有哪些？A. 	int a, b;B. 	int replacementLen = replacement.length();String string = sequence.toString();int pos = indexIn(string);if (replacementLen == 0) {    return removeFrom(sequence);}if (replacementLen == 1) {    return replaceFrom(sequence, replacement.charA','t(0));}if (pos == -1) {    return string;}C. 	String args[];D. 	public boolean matches(char c) {    switch (c) {        case \'\\t\':        case \'\\n\':        case \'\\u205f\':        case \'\\u3000\':            return true;        case \'\\u2007\':            return false;        default:            return false;    }}','BD','BD根据华为Java编程规范,下列选项中变量声明错误的有哪些？A. 	int a, b;B. 	int replacementLen = replacement.length();String string = sequence.toString();int pos = indexIn(string);if (replacementLen == 0) {    return removeFrom(sequence);}if (replacementLen == 1) {    return replaceFrom(sequence, replacement.charAt(0));}if (pos == -1) {    return string;}C. 	String args[];D. 	public boolean matches(char c) {    switch (c) {        case \'\\t\':        case \'\\n\':        case \'\\u205f\':        case \'\\u3000\':            return true;        case \'\\u2007\':            return false;        default:            return false;    }}','MULTI_CHOICE',1,1,1 ,836);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下说法正确的是（ ）A','. 	Optional类主要解决的问题是空指针异常（NullPointerException）B. 	实现Serializable接口的可序列化类应该显式声明serialVersionUIDC. 	尽量避免实现Serializable接口D. 	不要在控制性条件表达式中执行赋值','BC','BC如下说法正确的是（ ）A. 	Optional类主要解决的问题是空指针异常（NullPointerException）B. 	实现Serializable接口的可序列化类应该显式声明serialVersionUIDC. 	尽量避免实现Serializable接口D. 	不要在控制性条件表达式中执行赋值','MULTI_CHOICE',1,1,1 ,837);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如下用例运行失败的有（）A. ','	@Test(timeout = 100)public void testWithTimeout() throws Exception {    TimeUnit.MILLISECONDS.sleep(10);}B. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(10);@Testpublic void testWithTimeout() throws Exception {    TimeUnit.SECONDS.sleep(11);}C. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(5);@Test(timeout = 7 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}D. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(7);@Test(timeout = 5 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}','ABCD','ABCD如下用例运行失败的有（）A. 	@Test(timeout = 100)public void testWithTimeout() throws Exception {    TimeUnit.MILLISECONDS.sleep(10);}B. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(10);@Testpublic void testWithTimeout() throws Exception {    TimeUnit.SECONDS.sleep(11);}C. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(5);@Test(timeout = 7 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}D. 	@Rulepublic Timeout globalTimeout = Timeout.seconds(7);@Test(timeout = 5 * 1000)public void testTimeOut() throws Exception {    TimeUnit.SECONDS.sleep(6);}','MULTI_CHOICE',1,1,1 ,838);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 ‘ 和 “ 符号转义，请问如下针对 mysql 数据库的查询中，哪条是有可能受到sql 注入攻击的？A','. 	\"select * from users where id=\" + request.getParameter(\"id\");B. 	\"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";C. 	\"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";D. 	\"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");','AB','AB如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 ‘ 和 “ 符号转义，请问如下针对 mysql 数据库的查询中，哪条是有可能受到sql 注入攻击的？A. 	\"select * from users where id=\" + request.getParameter(\"id\");B. 	\"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";C. 	\"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";D. 	\"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");','MULTI_CHOICE',1,1,1 ,839);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '当我们做简单业务，通过数据库连接池，获得一个数据库连接Connection，执行一个Statement，获得一个ResultSet后，就结束业务了，那么下面错误的是？A','. 	我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显式地关闭ResultSet和Statement，保持代码简单和简洁。B. 	我们需要先关闭Connection，接着显式地关闭ResultSet和Statement。C. 	我们需要先关闭Connection，接着显式地关闭Statement和ResultSetD. 	我们需要先关闭ResultSet和Statement，然后Connection就自动被关闭了，不需要显式地关闭Connection。','AD','AD当我们做简单业务，通过数据库连接池，获得一个数据库连接Connection，执行一个Statement，获得一个ResultSet后，就结束业务了，那么下面错误的是？A. 	我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显式地关闭ResultSet和Statement，保持代码简单和简洁。B. 	我们需要先关闭Connection，接着显式地关闭ResultSet和Statement。C. 	我们需要先关闭Connection，接着显式地关闭Statement和ResultSetD. 	我们需要先关闭ResultSet和Statement，然后Connection就自动被关闭了，不需要显式地关闭Connection。','MULTI_CHOICE',1,1,1 ,840);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '以下可能造成死锁的代码是（）A. 	public class LeftRightLock {    private final Object left = new Object();    private final Object right = new Object();    public void functionA() {        synchronized (left) {            synchronized (right) {                doSomething();            }        }    }    public void functionB() {        synchronized (right) {            synchronized (left) {                doSomething();            }        }}……}B. 	public void transferMony(Account fromAccount, Account toAccount, int amount) {    synchronized (fromAccount) {        synchronized (toAccount) {            fromAccount.debit(amount);            toAccount.credit(amount);        }    }}C. 	public class Taxi {    private Point location;    private Point destinztion;    private final Dispatcher dispatcher;    public Taxi(Dispatcher dispatcher) {        this.dispatcher = dispatcher;    }    public synchronized Point getLocation() {        return location;    }    public synchronized void setLocation(Point location) {        this.location = location;        if (this.location.equals(destinztion)) {            dispatcher.notifyAvailable(this);        }}……}public class Dispatcher {    private final Set<Taxi> taxis = new HashSet<>();    private final Set<Taxi> availableTaxis = new HashSet<>();    public synchronized void notifyA','vailable(Taxi taxi) {        availableTaxis.add(taxi);    }    public synchronized Image getImage() {        final Image image = new Image();        for (final Taxi taxi : taxis) {            image.drawMarket(taxi.getLocation());        }        return image;}……}D. 	private final ExecutorService executor = Executors.newSingleThreadExecutor();public void renderPage() throws InterruptedException, ExecutionException{    Future<String> page = executor.submit(new RenderPageTask());    frame.set(page.get());}public class RenderPageTask implements Callable<String> {    @Override    public String call() throws Exception {        final Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));        final Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));        return header.get() + \"page\" + foot.get();    }}','AC','AC以下可能造成死锁的代码是（）A. 	public class LeftRightLock {    private final Object left = new Object();    private final Object right = new Object();    public void functionA() {        synchronized (left) {            synchronized (right) {                doSomething();            }        }    }    public void functionB() {        synchronized (right) {            synchronized (left) {                doSomething();            }        }}……}B. 	public void transferMony(Account fromAccount, Account toAccount, int amount) {    synchronized (fromAccount) {        synchronized (toAccount) {            fromAccount.debit(amount);            toAccount.credit(amount);        }    }}C. 	public class Taxi {    private Point location;    private Point destinztion;    private final Dispatcher dispatcher;    public Taxi(Dispatcher dispatcher) {        this.dispatcher = dispatcher;    }    public synchronized Point getLocation() {        return location;    }    public synchronized void setLocation(Point location) {        this.location = location;        if (this.location.equals(destinztion)) {            dispatcher.notifyAvailable(this);        }}……}public class Dispatcher {    private final Set<Taxi> taxis = new HashSet<>();    private final Set<Taxi> availableTaxis = new HashSet<>();    public synchronized void notifyAvailable(Taxi taxi) {        availableTaxis.add(taxi);    }    public synchronized Image getImage() {        final Image image = new Image();        for (final Taxi taxi : taxis) {            image.drawMarket(taxi.getLocation());        }        return image;}……}D. 	private final ExecutorService executor = Executors.newSingleThreadExecutor();public void renderPage() throws InterruptedException, ExecutionException{    Future<String> page = executor.submit(new RenderPageTask());    frame.set(page.get());}public class RenderPageTask implements Callable<String> {    @Override    public String call() throws Exception {        final Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));        final Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));        return header.get() + \"page\" + foot.get();    }}','MULTI_CHOICE',1,1,1 ,841);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '对于架构威胁建模方法（STRIDE-SD）中的关键活动，以下哪些描述是正确的？A. ','	价值资产识别：根据系统部件和数据对系统所有者的价值，从软件、硬件、服务、人员等维度识别系统中的价值资产B. 	暴露面及其风险分析：对产品暴露的硬件、软件接口及协议栈进行全面的梳理，并评估暴露面风险C. 	攻击路径分析：从价值资产的成功攻击为根节点，逐步展开使攻击成功的各级子节点，直至暴露面，形成攻击树D. 	威胁建模：考虑到系统已被入侵的可能，对系统架构元素建立全面的威胁模型','ABCD','ABCD对于架构威胁建模方法（STRIDE-SD）中的关键活动，以下哪些描述是正确的？A. 	价值资产识别：根据系统部件和数据对系统所有者的价值，从软件、硬件、服务、人员等维度识别系统中的价值资产B. 	暴露面及其风险分析：对产品暴露的硬件、软件接口及协议栈进行全面的梳理，并评估暴露面风险C. 	攻击路径分析：从价值资产的成功攻击为根节点，逐步展开使攻击成功的各级子节点，直至暴露面，形成攻击树D. 	威胁建模：考虑到系统已被入侵的可能，对系统架构元素建立全面的威胁模型','MULTI_CHOICE',1,1,1 ,842);
INSERT INTO question  ( title,options,answer,original_information,q_type,hide_answer,likeable,doubtful ,id)  VALUES  ( '张三要给李四写一封信，为了确保内容不被泄漏，张三采用了如下行为：将信的内容按照密码本进行替换，并将密码本放到用只有李四可以打开的带锁的盒子中，然后在信封上写上”信内一共有 200 个字和1000个笔画”，最后将信和盒子快递给李四。从类比角度思考，请问这个过程利用了哪些密码学算法思想( )A','. 	对称加密算法B. 	非对称加密算法(加密)C. 	非对称加密算法(签名)D. 	散列函数','AD','AD张三要给李四写一封信，为了确保内容不被泄漏，张三采用了如下行为：将信的内容按照密码本进行替换，并将密码本放到用只有李四可以打开的带锁的盒子中，然后在信封上写上”信内一共有 200 个字和1000个笔画”，最后将信和盒子快递给李四。从类比角度思考，请问这个过程利用了哪些密码学算法思想( )A. 	对称加密算法B. 	非对称加密算法(加密)C. 	非对称加密算法(签名)D. 	散列函数','MULTI_CHOICE',1,1,1 ,843);
