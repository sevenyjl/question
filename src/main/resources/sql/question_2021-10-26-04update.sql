INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (858, '下列有关Java反射的说法 错误 的是：', 'A 反射可以获取Method，通过invoke进行方法的调用；\nB 反射不可以直接通过getField获取私有成员的值；\nC 反射可以获取注解（@Target为Runtime）信息；\nD 反射可以获取类的构造器；', 'C', 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (859, '下面代码执行结果？\npublic class Object1 {\n    private String name=\"java\";\n    public static void main(String[] args)\n        throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        Object1 object1 = Object1.class.getDeclaredConstructor().newInstance();\n        for (Field declaredField : Object1.class.getDeclaredFields()) {\n            System.out.println(declaredField.get(object1));\n        }\n\n        Object2 object2 = Object2.class.getDeclaredConstructor().newInstance();\n        for (Field declaredField : Object2.class.getDeclaredFields()) {\n            System.out.println(declaredField.get(object2));\n        }\n    }\n}\nclass Object2{\n    private String name=\"java\";\n}', 'A、抛出异常\nB、java\nC、java 抛出异常\nD、java java', 'C', '这个暂时记住先。。。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (860, '以下代码输出：\nclass Parent {\n    public int a = 100;\n    private int b = 200;\n    protected int c =300;\n    public int f() {\n        return 10;\n    }\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException {\n        Field[] fields = Parent.class.getDeclaredFields();\n        System.out.println(fields.length);\n \n        Field[] fields1 = Parent.class.getFields();\n        System.out.println(fields1.length);\n    }\n}', 'A、1 3\nB、3 1\nC、1 1\nD、3 3', 'B', 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (861, '关于Optional说法正确的是？', 'A. Optional可以被赋值为null\nB. Optional.of()可以用null做参数，返回Optional.empty()\nC. Optional.ofNullable(obj)，obj不为null时直接调用Optional.of(obj)\nD. Optiona.of()可以放置集合或对象。', 'CD', 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (862, '父类的哪个不能被子类隐藏 ', 'A. 私有方法\nB. 属性\nC. 内部类\nD. 静态方法', 'A', '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (863, '以下代码输出什么\nString strTxt = \"123\\\\d\";\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'A 123456 123456 123456\nB 123456 123\\\\d 123456\nC 123\\\\d 123456 123\\\\d\nD 123\\d  123456 123\\d\nE 456456456\\d 123456 123456', 'E', '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (864, '关于函数重写和重载，说法正确的是', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'ACD', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (865, '根据通用规范，方法注释中不应出现如下', 'A、线程安全\nB、修改日期\nC、性能约束\nD、api特性、原理', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (866, '下面说法不正确的是：', '\nA、避免文件过长，不超过2000行（非空非注释行）\nB、一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔\nC、import包应当按照先华为公司，安卓、其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组\nD、一个类或接口的声明部分应当按照类变量、实例变量、构造器、方法的顺序出现，且用空行分隔', 'C', '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
