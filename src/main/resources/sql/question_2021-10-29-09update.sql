INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (893, '在执行JDBC查询数据库时，假设物理内存足够用，如果查询结果集ResultSet要返回的记录数很多，比如上百万记录，则下列选项中对ResultSet的fetchsize属性描述正确的是', 'A、ResultSet的fetchSize越大，数据库服务端消耗的内存越小，性能也越快\n\nB、ResultSet的fetchSize越大，数据库服务端消耗的内存越大，性能也越快\n\nC、ResultSet的fetchSize越大，JDBC client端消耗的内存越大，性能也越快\n\nD、ResultSet的fetchSize越大，JDBC client端消耗的内存越小，性能也越快', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (894, '以下代码输出\nclass Parent {\n    public int a = 100;\n    private int b = 200;\n    protected int c = 300;\n    public int f() {\n        return 10;\n    }\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException {\n        Field[] fields = Parent.class.getDeclaredFields();\n        System.out.println(fields.length);\n        Field[] fields1 = Parent.class.getFields();\n        System.out.println(fields1.length);\n    }\n}', 'A、1 3\n\nB、3 1\n\nC、1 1\n\nD、3 3', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (895, '下面哪个不是Class类中定义的反射方法', 'A、getDeclaredFields\n\nB、getDeclaredNames\n\nC、getDeclaredMethods\n\nD、getDeclaredConstructors', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (896, '1、下面那些可以编译成功', 'A、float f = 10f\n\nB、char c = 10.0\n\nC、byte b = 10b\n\nD、double d = 10\n\nE、float f = 10.0\n\nF、double d = 10.0', 'ADF', '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (897, '关于集合，以下说法正确的是', 'A、HashMap使用的是数组+链表（或红黑树）的方式，查找key时，先判断key的equals是否相等，相等时再判断 hashCode是否一致\n\nB、HashMap和HashSet的默认值大小为16，HashTable的默认值大小为11\n\nC、LinkedHashMap保持插入的顺序，TreeMap保持key的自然顺序\n\nD、Collection的直接子类包含Set、List、Map和Queue', 'BC', 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (898, 'switch支持的类型', 'A、byte \nB、long \nC、char  \nD、String', 'ACD', '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (899, '关于函数重写和重载，说法正确的是', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\n\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\n\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\n\nD、声明为final或static的方法不能被重写', 'ACD', 'B 返回值同不同 都不满足', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (900, '以下关于异常说法正确的是', 'A、Throwable是所有Error或Exception的超累\n\nB、只有是Exception或Exception子类，才能被catch\n\nC、Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError\n\nD、编译器会强制要求使用者捕获RuntimeException或申明抛出', 'ACD', 'B 纯属狗屁了，你把Throwable不放在眼里', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (901, '有关多线程中异常处理的说法正确的是', 'A、Java多线程程序中，线程不允许抛出未捕获的Checked Exception\n\nB、Java多线程程序中，线程允许抛出未捕获的Checked Exception\n\nC、Java多线程程序中，建议使用Thread对象的setUncaughtExceptionHandler方法注册Runtime异常的处理者\n\nD、Java多线程中，主线程可通过try catch捕获子线程异常', 'AC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (902, 'Java反射机制的作用包括', 'A、在运行时判断任意一个对象所属的类。\n\nB、在运行时构造任意一个类的对象。\n\nC、在运行时判断任意一个类所具有的成员变量和方法。\n\nD、在运行时调用任意一个对象的方法。', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (903, 'SocketChannel可以向Selector注册哪些事件', 'A、SelectionKey.OP_ACCEPT\n\nB、SelectionKey.OP_CONNECT\n\nC、SelectionKey.OP_WRITE\n\nD、SelectionKey.OP_READ', 'ABCD', '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (904, '如下类型，哪些是值不可变类型', 'A、char\n\nB、Integer\n\nC、String\n\nD、short', 'BC', '貌似包装类都是final class可能看看源码加深记忆', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (905, '在64位虚拟机，如下数据类型中，长度不是4字节的类型有哪些', 'A、char\n\nB、int\n\nC、long\n\nD、short', 'ACD', 'https://blog.csdn.net/u012611878/article/details/52455576', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (906, '以下代码执行两遍，文件text.txt中的内容为\n\nFileOutputStream outputStream = new FileOutputStream(\"test.txt\",true);\noutputStream.write(\"ABCDE\".getBytes(StandardCharsets.UTF_8));\noutputStream.close();', 'A、ABCDE\n\nB、ABCDEABCDE\n\nC、什么都没有\n\nD、EDCBAEDCBA', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (907, '以下代码输出什么\n\nList arrayList = new ArrayList();\narrayList.add(\"aaaa\");\narrayList.add(100);\nSystem.out.println((String)arrayList.get(1));', 'A、100 \nB、编译错误 \nC、运行异常 \nD、aaaa', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (908, '以下代码输出什么\nString str = \"abc@x.y+com\";\nString str1 = \"ab_c@x.y.com\";\nString regex = \"^[a-zA-Z0-9.-_]+@([a-zA-Z0-9]+.)+com$\";\nSystem.out.println(str.matches(regex));\nSystem.out.println(str1.matches(regex));', 'A、true true  \nB、true false \nC、false true \nD、false false', 'A', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (909, '不属于NIO Buffer中的属性变量', 'A、capacity \nB、flag \nC、position \nD、limit', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (910, '关于IO/NIO说法不正确的是', 'A、IO是面向流的，NIO是面向缓存的\n\nB、IO是阻塞IO，NIO支持非阻塞IO\n\nC、IO值能顺序读取数据，NIO可以通过缓存区前后移动获取数据\n\nD、IO允许一个线程监听多个输入通道', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (911, '不属于NIO组件的是', 'A、Buffer \nB、Channel\nC、Selectors \nD、Reader', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (912, '下面说法正确的', 'A、volatile保证操作的修改可见性和原子性\n\nB、volatile和synchronized则可以使用在变量、方法、和类级别的\n\nC、synchronized和ReentrantLock都是可重入锁\n\nD、synchronized适合一写多读场景', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (913, '以下代码输出什么\n\nComparator<Integer> df = new Comparator<Integer>() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return o1 > o2 ? 1 : (o1 == o2) ? 0 : -1;\n    }\n};\nSystem.out.println(df.compare(new Integer(1),new Integer(1)));', 'A、0 \nB、1 \nC、-1 \nD、运行时异常', 'C', 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (914, '不属于启动安全管理器的是？', 'A、启动程序的时候通过附加参数启动安全管理器：-Djava.security.manager\n\nB、若要同时指定配置文件 -Djava.security.manager -Djava.security.policy=\"E:/java.policy\"\n\nC、编码方式启动 System.setSecurityManager(new SecurityManager());\n\nD、编码方式启动 System.setProperty(“java.security.manager”, xxx);', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (915, '正确的执行System.exit()的方式', 'A、OOM时，主动执行System.exit()\n\nB、进程发生不可预知的异常时，主动执行System.exit()\n\nC、命令行执行System.exit()\n\nD、服务出现不可恢复的异常时，主动执行System.exit()', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (916, '以下说法正确的是', 'A、调用Thread.interrupt() 用于请求另外一个线程中止执行，而不是直接中止\n\nB、推荐使用Thread.current().isInterrupted()，而不是Thread.interrupted()检查自己是否被interrupt\n\nC、检测到当前线程被interrupt后，应抛出InterruptedException，并在finally或try-with-resource中清理执行状态\n\nD、调用线程的interrupt方法，只有当线程走到了sleep, wait, join等阻塞这些方法的时候，才会抛出InterruptedException。', 'ACD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (917, '以下哪些在接收到Thread.interrupt()会抛出InterruptedException异常', 'A、Thread.sleep()\n\nB、java.net.Socket的阻塞方法\n\nC、java.nio.channels.SocketChannel的阻塞方法\n\nD、Thread.wait()\n', 'ACD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (918, '下面哪些是线程安全的（）', 'A、LinkedList\nB、Vector\nC、Hashtable\nD、TreeMap\nE、TreeSet\nF、ConcurrentHashMap\nG、Stack', 'BCFG', 'Stack<E> extend Vector<E> 故线程安全', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (919, '关于溢出描述正确的是', 'A、java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。\n\nB、java.lang.StackOverflowError: 线程栈空间不足\n\nC、java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (920, '属于java并发库的线程同步类', 'A、Exchanger \nB、Semaphore \nC、CountDownLatch  \nD、CyclicBarrier  \nE、Phaser', 'ABCDE', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question`.`question` (`id`, `title`, `options`, `answer`, `parsing`, `remark`, `original_information`, `subject`, `q_type`, `hide_answer`, `doubtful`, `likeable`, `error_times`, `right_times`, `doubted_times`) VALUES (921, '下面说法正确的', 'A、FileChannel 从文件读取数据，或将数据写入文件，无法设置为非阻塞模式\n\nB、DatagramChannel 使用TCP协议通过网络来读写数据\n\nC、SocketChannel 使用UDP协议通过网络来读写数据\n\nD、ServerSocketChannel 可以监听新进来的TCP连接', 'AD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
UPDATE question  SET title='1、下面那些可以编译成功',options='A、float f = 10f\n\nB、char c = 10.0\n\nC、byte b = 10b\n\nD、double d = 10\n\nE、float f = 10.0\n\nF、double d = 10.0',answer='ADF',parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',q_type='MULTI_CHOICE',hide_answer=0,likeable=0,doubtful=0,error_times=0,right_times=0,doubted_times=0  WHERE id=896;

