UPDATE question  SET title='关于synchronized的叙述错误的是()\n\n',options='A 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景\n\n',answer='D',parsing='A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？',original_information='21、关于synchronized的叙述错误的是()\n\nA 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步（这个真不知道，难道这个锁住的逻辑，还有在很多的层面实现的吗）\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁（发生异常会自动释放）\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景（啥玩意都互斥）\n\n答案：D',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=21;
UPDATE question  SET doubtful=0  WHERE id=22;
UPDATE question  SET doubtful=0  WHERE id=22;
UPDATE question  SET doubtful=0  WHERE id=24;
UPDATE question  SET title='有关类加载器的双亲委派模型说法错误的时（）\n\n',options='A 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载\n\n',answer='C',parsing='参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。',original_information='24、 有关类加载器的双亲委派模型说法错误的时（）\n\nA 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；（类加载机制）\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载（优先机制）\n\n答案：C（自定义类加载器有什么用处呢）（双亲委托机制：\n\n简单来说就是加载一个类进内存，先从系统类加载器找，往上从扩展类中找，往上再从根加载器中找）（可以随心所欲的进行安全校验）（实例加载的时候，就会以子类开始了）',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=24;
UPDATE question  SET doubtful=0  WHERE id=23;
UPDATE question  SET doubtful=0  WHERE id=23;
UPDATE question  SET title='对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\n',options='A 使得第idx个参数的值设为val\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n',answer='A',parsing='PreparedStatement的索引是从1开始',original_information='25、对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\nA 使得第idx个参数的值设为val（这个还是死记硬背吧，和我们平常理解的不一样的）\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n答案：A',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=25;
UPDATE question  SET title='有关NIO Selector说法错误的是：\n\n',options='A 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n',answer='C',parsing='A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭',original_information='26、有关NIO Selector说法错误的是：\n\nA 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;（看来机制介绍的还是很清楚的）\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close（buffer里面属性使用都时在NIO的使用，在NIO）（capacity、position、limit）\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n答案：C',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=26;
UPDATE question  SET title='下面锁用的正确的是：\n\n',options='A\nprivate int count=0;\nprivate final Integer lock=new Integer(count);\npublic void doSomething(){\n    Synchronized(lock){\n    Count++;\n    }\n}\n\n B\nprivate final String lock=\"LOCK”;\npublic void doSomething(){\n    synchronized (lock){\n    //..\n    }\n}\n\nC \nBoolean isInitialized=Boolean.FALSE;\npublic void doSomething(){\n    synchronized (isInitialized){\n    //..\n    }\n}\n\n    D\nprivate int count=0;\nprivate final integer lock=count;\npublic void doSomething(){\n    synchronized (lock){\n        lock++;\n    }\n}\n\n',answer='A',parsing='一句话，锁不要公用',original_information='27、下面锁用的正确的是：\n\nA\n\n1\n\nprivate int count = 0;\n\n2\n\nprivate final Integer lock = new Integer(count);\n\n3\n\npublic void doSomething() {\n\n4\n\nSynchronized (lock) {\n\n5\n\nCount++;\n\n6\n\n}\n\nB\n\n1\n\nprivate final String lock = \"LOCK”;\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (lock) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nC\n\n1\n\nBoolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (isInitialized) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nD\n\n1\n\nprivate int count = 0;\n\n2\n\nPrivate final integer lock = count;锁必须不能是公共人可以获取的东西\n\n3\n\npublic void doSomething() {\n\n4\n\nsynchronized (lock) {\n\n5\n\nlock++;\n\n6\n\n}\n\n7\n\n}（因为别的程序还要用）\n\n答案：A',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=27;
UPDATE question  SET title='下面锁用的正确的是：\n\n',options='A\nprivate int count=0;\nprivate final Integer lock=new Integer(count);\npublic void doSomething(){\n    Synchronized(lock){\n    Count++;\n    }\n}\n\n B\nprivate final String lock=\"LOCK”;\npublic void doSomething(){\n    synchronized (lock){\n    //..\n    }\n}\n\nC \nBoolean isInitialized=Boolean.FALSE;\npublic void doSomething(){\n    synchronized (isInitialized){\n    //..\n    }\n}\n\n    D\nprivate int count=0;\nprivate final integer lock=count;\npublic void doSomething(){\n    synchronized (lock){\n        lock++;\n    }\n}\n\n',answer='A',parsing='一句话，锁不要公用，容易阻塞/死锁',original_information='27、下面锁用的正确的是：\n\nA\n\n1\n\nprivate int count = 0;\n\n2\n\nprivate final Integer lock = new Integer(count);\n\n3\n\npublic void doSomething() {\n\n4\n\nSynchronized (lock) {\n\n5\n\nCount++;\n\n6\n\n}\n\nB\n\n1\n\nprivate final String lock = \"LOCK”;\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (lock) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nC\n\n1\n\nBoolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (isInitialized) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nD\n\n1\n\nprivate int count = 0;\n\n2\n\nPrivate final integer lock = count;锁必须不能是公共人可以获取的东西\n\n3\n\npublic void doSomething() {\n\n4\n\nsynchronized (lock) {\n\n5\n\nlock++;\n\n6\n\n}\n\n7\n\n}（因为别的程序还要用）\n\n答案：A',q_type='SINGLE_CHOICE',hide_answer=0,likeable=0,doubtful=0  WHERE id=27;
