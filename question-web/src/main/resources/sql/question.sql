/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : question

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 14/11/2021 21:37:26
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for question
-- ----------------------------
DROP TABLE IF EXISTS `question`;
CREATE TABLE `question`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '题目',
  `options` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '选项',
  `answer` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '答案',
  `parsing` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '解析',
  `remark` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '备注',
  `original_information` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '原始信息',
  `subject` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '科目',
  `q_type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '题型',
  `hide_answer` tinyint(4) NULL DEFAULT 1 COMMENT '0隐藏1显示',
  `doubtful` tinyint(4) NULL DEFAULT 1 COMMENT '存疑的0存疑1不存疑',
  `likeable` tinyint(4) NULL DEFAULT 1 COMMENT '收藏 0收藏1不收藏',
  `error_times` int(11) NULL DEFAULT 0 COMMENT '错误次数',
  `right_times` int(11) NULL DEFAULT 0 COMMENT '正确次数',
  `doubted_times` int(11) NULL DEFAULT 0 COMMENT '存疑次数',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 654 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of question
-- ----------------------------
INSERT INTO `question` VALUES (1, '下列说法错误的是（）', 'A 反射可以获取类的构造器\n\nB 反射可获以Method,通过invoke进行方法的调用；\n\nC 反射可以获取注解（@Target为Runtime）信息；\n\nD 反射能够直接get(obj)获取私有的Field成员的值；', 'CD', 'A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法\nB:通过getMethods能获取方法并使用invoke进行调用\nC:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置\nD:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值\n故选择：CD', NULL, '1、 下列说法错误的是（）A 反射可以获取类的构造器B 反射可获以Method,通过invoke进行方法的调用；C 反射可以获取注解（@Target为Runtime）信息；D 反射能够直接get(obj)获取私有的Field成员的值；答案：CD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (2, '下列程序执行结果说法正确的（）\npublic class Test {\n    public static void main(String[] args) {\n        List<String> list = new ArrayList<>();\n        list.add(\"str1\");\n        list.add(2, \"str2\");\n        String str = list.get(1);\n        System.out.println(str);\n    }\n}', 'A 编译时出现异常；\nB 正确运行，输出str1;\nC 正确运行，输出str2;\nD 运行时出现异常', 'D', '运行时list.add(2, \"str2\");报错，因为ArrayList在添加前会调用rangeCheckForAdd方法判断当前索引是否大于了当前数组的size一句话list.add(2, \"str2\")只能替换不能追加', NULL, '2、 下列程序执行结果说法正确的（）1public class Test {23public static void main(String[]args) {4List<String> list = new ArrayList<>();5list.add(\"str1\");6list.add(2,\"str2\");7String str = list.get(1);8System.out.println(str);9}10}A 编译时出现异常；B 正确运行，输出str1;C 正确运行，输出str2;D 运行时出现异常答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 4, 0);
INSERT INTO `question` VALUES (3, '关于代码格式如下说法错误的是（）\n\n', 'A 一个源文件按顺序包含版本、package、import、顶层、且用空行分隔；\n\nB 对于非空块和块状结构，左大括号放在行尾；\n\nC 空行不是代码，所以代码中多写几个空行没有关系；\n\nD 一个类或接口的声明部分应当按照类变、实例变量，构造器，方法的顺序出现，且用空行分隔；\n\n', 'C', NULL, NULL, '5、 关于代码格式如下说法错误的是（）\n\nA 一个源文件按顺序包含版本、package、import、顶层、且用空行分隔；\n\nB 对于非空块和块状结构，左大括号放在行尾；\n\nC 空行不是代码，所以代码中多写几个空行没有关系；\n\nD 一个类或接口的声明部分应当按照类变、实例变量，构造器，方法的顺序出现，且用空行分隔；\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (4, '哪个异常可能会泄露文件系统结构信息（）\n\n', 'A java.io.FileNotFountException\n\nB java.io.IOException\n\nC java.util.MissResourceException\n\nD java.sql.SQLException\n\n', 'A', NULL, NULL, '6、 哪个异常可能会泄露文件系统结构信息（）\n\nA java.io.FileNotFountException\n\nB java.io.IOException\n\nC java.util.MissResourceException\n\nD java.sql.SQLException\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (5, '有关ORM的说法错误的是（）\n\n', 'A ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；\n\nB ORM依赖于JDBC和DataSource;\n\nC ORM有多种实现，主流的Mybatis与Hibernate;\n\nD ORM、对象关系转换，即数据库的单条数据与Java对应之间的映射；\n\n', 'A', NULL, NULL, '7、 有关ORM的说法错误的是（）\n\nA ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；\n\nB ORM依赖于JDBC和DataSource;\n\nC ORM有多种实现，主流的Mybatis与Hibernate;\n\nD ORM、对象关系转换，即数据库的单条数据与Java对应之间的映射；\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (6, '下列关于Thread类提供的线程控制方法的说法中，错误的是（）', 'A currentThread()方法返回当前线程的引用\n\nB 线程A通过调用interrupt()方法来中断其阻塞状态\n\nC 线程A中执行线程B的join()方法，则线程A等待直到B执行完成\n\nD 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。', 'D', 'D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了', NULL, '9、 下列关于Thread类提供的线程控制方法的说法中，错误的是（）A currentThread()方法返回当前线程的引用B 线程A通过调用interrupt()方法来中断其阻塞状态C 线程A中执行线程B的join()方法，则线程A等待直到B执行完成D 若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。（完全矛盾的判断啊）答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 3, 0);
INSERT INTO `question` VALUES (7, '某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）', 'A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件\n\nB 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密\n\nC 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；\n\nD 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640', 'D', 'D:看来权限是给高了，个人感觉是不是600就可以了', NULL, '10、某业务会在运行过程中在linux系统中创建转储文件，当文件数量达到预定阈值时会将最老的文件删除，该业务在某些场下会读取转储文件，下列说法错误的时（）A 创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件B 转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密C 转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；D 结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640（看来权限是给高了）答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (8, '若一个实现了Serializable接口的类中包含有敏感信息字段，为了防止该类对象被序序列化时导致敏感信息泄露，可以使用下面哪个关键字（）\n\n', 'A private\n\nB static\n\nC volatile\n\nD transient\n\n', 'D', NULL, NULL, '11、若一个实现了Serializable接口的类中包含有敏感信息字段，为了防止该类对象被序序列化时导致敏感信息泄露，可以使用下面哪个关键字（）\n\nA private\n\nB static\n\nC volatile\n\nD transient\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (9, '下列哪些行为符合安全编码规范\n\n', 'A 某产品在为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志汇中。\n\nB 某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值（生日判定）\n\nC 某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力\n\nD 某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字\n\n', 'D', NULL, NULL, '12、下列哪些行为符合安全编码规范\n\nA 某产品在为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志汇中。\n\nB 某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值（生日判定）\n\nC 某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力\n\nD 某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 3, 6, 1);
INSERT INTO `question` VALUES (10, 'Java的基本类型的int在不同的操作系统平台的字长是\n\n', 'A 32位\n\nB 64位\n\nC 16位\n\nD 在32位系统上是32位，在64位系统上是64位\n\n', 'A', 'D:long类型在不同的操作系统才有区别', NULL, '13、Java的基本类型的int在不同的操作系统平台的字长是\n\nA 32位（只能记住）\n\nB 64位\n\nC 16位\n\nD 在32位系统上是32位，在64位系统上是64位 //long类型在不同的操作系统才有区别\n\n答案：A', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (11, '下列赋值表达式不会报错的是（）\n\n', 'A boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n', 'D', NULL, NULL, '14、下列赋值表达式不会报错的是（）\n\nA boolean isStop = “true”;\n\nB float fit = 3.1; // float fit = 3.1f;\n\nC int num = 1.0;\n\nD char ch = 1;（char可以容纳的数字范围是多少）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (12, '编译并运行如下Java程序，将输出（）\npublic static void main(String[] args) {\n    try {\n        int num1 = 2;\n        int num2 = 0;\n        int result = num1 / num2;\n        System.out.println(result);\n    } catch (ArrayIndexOutOfBoundsException e) {\n        System.out.println(\"1\");\n    } catch (NumberFormatException e) {//（数字格式报错）\n        System.out.println(\"2\");\n    } catch (Exception e) {\n        System.out.println(\"3\");\n    } finally {\n        System.out.println(\"4\");\n    }\n    System.out.println(\"5\");\n}', 'A 345\r\n\r\nB 134\r\n\r\nC 2345\r\n\r\nD 1345\n', 'A', NULL, NULL, '16、编译并运行如下Java程序，将输出（）\n\n1\n\npublic static void main(String[] args) {\n\n2\n\ntry {\n\n3\n\nint num1 = 2;\n\n4\n\nint num2 = 0;\n\n5\n\nint result = num1 / num2;\n\n6\n\nSystem.out.println(result);\n\n7\n\n} catch (ArrayIndexOutOfBoundsException e) {\n\n8\n\nSystem.out.println(\"1\");\n\n9\n\n} catch (NumberFormatException e) {（数字格式报错）\n\n10\n\nSystem.out.println(\"2\");\n\n11\n\n} catch (Exception e) {\n\n12\n\nSystem.out.println(\"3\");\n\n13\n\n} finally {\n\n14\n\nSystem.out.println(\"4\");\n\n15\n\n}\n\n16\n\nSystem.out.println(\"5\");\n\n17\n\n}\n\n​ A 345\n\n​B 134\n\n​C 2345\n\n​D 1345\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 3, 0);
INSERT INTO `question` VALUES (13, '在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类', '\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n', 'B', NULL, NULL, '17、在JAVA的异常处理中，用户自定义的异常类一般应该是（）的子类\n\nA Error\n\nB Exception\n\nC RuntimeException\n\nD Throwable\n\n（UnkownTypeException，这种错误以前从没有注意过）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 2, 3, 0);
INSERT INTO `question` VALUES (14, '集合API中的Set接口的特点是哪些？', '\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n', 'D', '顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n', NULL, '18、集合API中的Set接口的特点是哪些？\n\nA 允许重复元素，元素无顺序\n\nB 允许重复无素，元素有顺序\n\nC 不允许重复元素，元素有顺序\n\nD 不允许重复元素，元素无顺序\n\n答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (15, '下列操作有关Map操作错误的是：', 'A\nMap<Integer, String> cityMap = new HashMap<Integer, String>() {\n    {\n        put(1, \"Nanjing\");\n        put(2, \"Beijing\");\n        put(3, \"Shanghai\");\n    }\n};\n\nB\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n    System.out.println(city.getValue());\n}\n\nC\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4,null);\n\nD\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 'D', 'D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}', NULL, '19、下列操作有关Map操作错误的是：\n\nA\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>() {\n\n2\n\n{\n\n3\n\nput(1, \"Nanjing”);\n\n4\n\nput(2, \"Beijing”);\n\n5\n\nput(3, \"Shanghai”);\n\n6\n\n}\n\n7\n\n}（这里应该会实现装包机制）\n\nB\n\n1\n\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n\n2\n\nSystem.out.println(city.getValue());\n\n3\n\n}\n\nC\n\n1\n\nMap<Integer, String> cityMap = new HashMap<>();\n\n2\n\ncityMap.put(4, null);（我记得有些Map是不允许放入null的）\n\nD\n\n1\n\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);（这里面的map都是不可以修改的，不可以修改的原因是什么了？）\n\n2\n\nunmodifiableMap.clear();（看过了你的方法，真的是无耻）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (16, '有关泛型，下面说法错误的是：\n\n', 'A extends约束类型上限，如public int add (T n1, T n2); 表示方法参数必须是Number的子类型；\n\nB List numList = new ArrayList();\n\nList intList = new ArrayList();\n\n因为Integer是Number的子类，所以intList可以赋值给numberList\n\nC 对于同一个类，可以使用不同的泛型参数类型声明类型和方法；\n\nD 泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考；当实例化时，使用具体的类型替代，这是实参\n\n', 'B', 'A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n', NULL, '20、有关泛型，下面说法错误的是：\n\nA extends约束类型上限，如public int add (T n1, T n2); 表示方法参数必须是Number的子类型；（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\n\nB List numList = new ArrayList();\n\nList intList = new ArrayList();（赋值是不可能的，不过可以addAll）\n\n因为Integer是Number的子类，所以intList可以赋值给numberList（这题给的也太简洁了吧）\n\nC 对于同一个类，可以使用不同的泛型参数类型声明类型和方法；\n\nD 泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考；当实例化时，使用具体的类型替代，这是实参\n\n答案：B', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 1, 4, 2);
INSERT INTO `question` VALUES (17, '关于synchronized的叙述错误的是()\n\n', 'A 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景\n\n', 'D', 'A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？', NULL, '21、关于synchronized的叙述错误的是()\n\nA 占用锁的线程在调用wait()后，会自动释放线程占有的锁\n\nB sychronized是JVM层面控制线程同步（这个真不知道，难道这个锁住的逻辑，还有在很多的层面实现的吗）\n\nC 占用锁的线程在发生异常，会自动释放线程占用的锁（发生异常会自动释放）\n\nD synchronized可用于处理读写互斥，读读不互斥的操作场景（啥玩意都互斥）\n\n答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 3, 1);
INSERT INTO `question` VALUES (18, '下面的程序创建了一个文件输出流对象，用来向向文件test.txt中输出数据。假设程序当前运行目录下不存在文件test.txt（自动重建），编译后执行结果为（）（编译后的结果怎么控制呢）\nimport java.io.*;\npublic class Test {\n    public static void main(String[] args) {\n        try {\n            String str = \"ABCDE”;\n            byte[] bs = str.getBytes(StandardCharsets.UTF_8);\n            FileOutputStream file = new FileOutputStream(\"test.txt”, true);\n                file.write(bs);\n            file.close();\n        } catch (IOException e) {\n            System.out.println(e.toString());\n        }\n    }\n}//（你这个是什么样子的思考方法）', '\n\nA ABCABC\n\nB Test\n\nC ABCDEABCDEABCDE\n\nD ABCDE\n\n', 'D', NULL, NULL, '22、下面的程序创建了一个文件输出流对象，用来向向文件test.txt中输出数据。假设程序当前运行目录下不存在文件test.txt（自动重建），编译后执行结果为（）（编译后的结果怎么控制呢）\n\n1\n\nimport java.io.*;\n\n2\n\n3\n\npublic class Test {\n\n4\n\npublic static void main(String[] args) {\n\n5\n\ntry {\n\n6\n\nString str = \"ABCDE”;\n\n7\n\nbyte[] bs = str.getBytes(StandardCharsets.UTF_8);\n\n8\n\nFileOutputStream file = new FileOutputStream(\"test.txt”, true);\n\n9\n\nfile.write(bs);\n\n10\n\nfile.close();\n\n11\n\n} catch(IOException e) {\n\n12\n\nSystem.out.println(e.toString());\n\n13\n\n}\n\n14\n\n}\n\n15\n\n}（你这个是什么样子的思考方法）\n\nA ABCABC\n\nB Test\n\nC ABCDEABCDEABCDE\n\nD ABCDE\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 1, 3, 0);
INSERT INTO `question` VALUES (19, '非0整数的匹配，下列正则表达式正确的是\n\n', 'A ^[0-9]*$\n\nB ^(0|[1-9][0-9]*)$\n\nC ^[1-9][0-9]*$\n\nD (0|[1-9][0-9]*)\n\n', 'C', NULL, NULL, '23、非0整数的匹配，下列正则表达式正确的是\n\nA ^[0-9]*$\n\nB ^(0|[1-9][0-9]*)$\n\nC ^[1-9][0-9]*$\n\nD (0|[1-9][0-9]*)\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (20, '有关类加载器的双亲委派模型说法错误的时（）\n\n', 'A 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载\n\n', 'C', '参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。', NULL, '24、 有关类加载器的双亲委派模型说法错误的时（）\n\nA 类加载器之间是有层次结构\n\nB 加载不到类，会抛出ClassNotFoundException();\n\nC 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；（类加载机制）\n\nD 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载（优先机制）\n\n答案：C（自定义类加载器有什么用处呢）（双亲委托机制：\n\n简单来说就是加载一个类进内存，先从系统类加载器找，往上从扩展类中找，往上再从根加载器中找）（可以随心所欲的进行安全校验）（实例加载的时候，就会以子类开始了）', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (21, '对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\n', 'A 使得第idx个参数的值设为val\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n', 'A', 'PreparedStatement的索引是从1开始', NULL, '25、对于PreparedStatement的setInt(inti dx,int val)方法的功能，描述正确的是（）\n\nA 使得第idx个参数的值设为val（这个还是死记硬背吧，和我们平常理解的不一样的）\n\nB 使得第idx-1个参数的值设为val\n\nC 使得第val-1个参数的值设为idx\n\nD 使得第val个参数的值设为idx\n\n答案：A', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (22, '有关NIO Selector说法错误的是：\n\n', 'A 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n', 'C', 'A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭', NULL, '26、有关NIO Selector说法错误的是：\n\nA 可以设定Selector的监听事件，包括Connect/Accept/Read/Write;（看来机制介绍的还是很清楚的）\n\nB Selector需要与Channel配合使用，Selector是Channel的复用器；\n\nC Selector本身不是一个文件，不用Close（buffer里面属性使用都时在NIO的使用，在NIO）（capacity、position、limit）\n\nD Selector等事件就绪后，才会返回，避免了大量IO阻塞；\n\n答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (23, '下面锁用的正确的是：\n\n', 'A\r\nprivate int count=0;\r\nprivate final Integer lock=new Integer(count);\r\npublic void doSomething(){\r\n    Synchronized(lock){\r\n    Count++;\r\n    }\r\n}\r\n\r\nB\r\nprivate final String lock=\"LOCK”;\r\npublic void doSomething(){\r\n    synchronized (lock){\r\n    //..\r\n    }\r\n}\r\n\r\nC \r\nBoolean isInitialized=Boolean.FALSE;\r\npublic void doSomething(){\r\n    synchronized (isInitialized){\r\n    //..\r\n    }\r\n}\r\n\r\nD\r\nprivate int count=0;\r\nprivate final integer lock=count;\r\npublic void doSomething(){\r\n    synchronized (lock){\r\n        lock++;\r\n    }\r\n}', 'A', '一句话，锁不要公用，容易阻塞/死锁', NULL, '27、下面锁用的正确的是：\n\nA\n\n1\n\nprivate int count = 0;\n\n2\n\nprivate final Integer lock = new Integer(count);\n\n3\n\npublic void doSomething() {\n\n4\n\nSynchronized (lock) {\n\n5\n\nCount++;\n\n6\n\n}\n\nB\n\n1\n\nprivate final String lock = \"LOCK”;\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (lock) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nC\n\n1\n\nBoolean isInitialized = Boolean.FALSE;（难道说Boolean.FALSE也不具备唯一性质吗）\n\n2\n\npublic void doSomething() {\n\n3\n\nsynchronized (isInitialized) {\n\n4\n\n//..\n\n5\n\n}\n\n6\n\n}\n\nD\n\n1\n\nprivate int count = 0;\n\n2\n\nPrivate final integer lock = count;锁必须不能是公共人可以获取的东西\n\n3\n\npublic void doSomething() {\n\n4\n\nsynchronized (lock) {\n\n5\n\nlock++;\n\n6\n\n}\n\n7\n\n}（因为别的程序还要用）\n\n答案：A', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (24, '以下命名风格正确的是：\n\n', 'A enum Gender { male, femal}（形容词）\n\nB class Test {\n\n​private boolean isNotFount;\n\n}\n\nC class Test {\n\n​private String userName;\n\n}\n\nD class Test {\n\n​private static final int NUM_FIVE = 5;\n\n}\n\n', 'C', 'A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对', NULL, '28、 以下命名风格正确的是：\n\nA enum Gender { male, femal}（形容词）\n\nB class Test {\n\n​private boolean isNotFount;\n\n}\n\nC class Test {\n\n​private String userName;\n\n}\n\nD class Test {\n\n​private static final int NUM_FIVE = 5;\n\n}\n\n答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (25, '如下代码执条结果是：\npublic class Foo {\n    public static void main(String[] args) {\n        for (float flt = (float) 1000000000; flt < 1000000010; flt++) {\n            System.out.println(flt);\n        }\n    }\n}', 'A 1000000000​\r\n  1000000001​\r\n  1000000002​ \r\n  ….​\r\n  1000000010​\r\n\r\nB 1000000000.0\r\n\r\nC 输出结果不确定', 'C', 'System.out.println(1000000000f == 1000000010f);//true\n应该是float精度问题？？？', NULL, '29、如下代码执条结果是：1public class Foo {2public static void main(String[] args) {3for (float flt = (float)1000000000;flt < 1000000010; flt++) {4System.out.println(flt);5}6}7}​A 1000000000​1000000001​1000000002​ ….​1000000010​B 1000000000.0​ C 输出结果不确定答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (26, '根据安全编码规范，以下代码中正确的时（）（不能和操作耦合在一起去思考）', 'A assert (Patten.matches(\"[0-9A-Za-z@]+\", dir);\n  Process proc = rt.exec(\"cmd.exe /c \" + dir);\n\nB ArrayList<String> names;\n  //…\n  assert names.remove(null);\n\nC assert index++ != MAX_LENGTH;\n\nD boolean isNullsRemoved = names.remove(null);\n  assert isNullsRemoved', 'D', '没懂A为啥不对', NULL, '33、根据安全编码规范，以下代码中正确的时（）（不能和操作耦合在一起去思考）A1assert (Patten.matches(\"[0-9A-Za-z@]+”, dir);2Process proc = rt.exec(”cmd.exe /c \" + dir);B1ArrayList<String> names;2//…3assert names.remove(null);C1assert index++ != MAX_LENGTH;  这里的自增操作D1boolean isNullsRemoved = names.remove(null);2assert isNullsRemoved // 所以每次都会出现这个情况啊答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 1, 4, 1);
INSERT INTO `question` VALUES (27, '标识出垃圾后，需要回收，有关回收的说法错误是：\n\n', 'A 复制copy后，即把内存区域分成两个等分，from区域与to区域，都从from区分内存，回收即是把from区域还在使用的内存，copy到to内存,….，比较消耗内存；\n\nB 压缩compact，重新整理达在使用的内存，一般做法是把还在使用的内存前移，填充回收空间，留下一大片连续的内存；压缩的问题是开销大；\nC Java的GC机制会选择其中一种方法进行垃圾回收；\n\nD 消除Sweep，直接清除，方法简单，但是会造成内存碎片，给再分配造成不可抑制的麻烦；\n\n', 'C', 'A：（看来不同的路线，选择机制还是不一样的）\nB：（这块需要反复计算才可以解决）\nC：（GC的回收过程中多种回收机制一起处理的结果）\nD：（这个缺点是很明显的）\n', NULL, '34、标识出垃圾后，需要回收，有关回收的说法错误是：\n\nA 复制copy后，即把内存区域分成两个等分，from区域与to区域，都从from区分内存，回收即是把from区域还在使用的内存，copy到to内存,….，比较消耗内存；（看来不同的路线，选择机制还是不一样的）\n\nB 压缩compact，重新整理达在使用的内存，一般做法是把还在使用的内存前移，填充回收空间，留下一大片连续的内存；压缩的问题是开销大；（这块需要反复计算才可以解决）\n\nC Java的GC机制会选择其中一种方法进行垃圾回收；（GC的回收过程中多种回收机制一起处理的结果）\n\nD 消除Sweep，直接清除，方法简单，但是会造成内存碎片，给再分配造成不可抑制的麻烦；（这个缺点是很明显的）\n\n答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 3, 0);
INSERT INTO `question` VALUES (28, '类加载表述正确的是()\n\n', 'A URLClassLoader的签名校验依赖jar包里的公钥，因此不能使用URLClassLoader来校验jar的合法性；（里面可能被人修改过，里面是底层的源码）\n\nB 在JVM中将不同的ClassLoader实例加载的同一个类视为相同的类；（看来不同的加载器生成的类也是不同的）\n\nC 开发者不可以自定义类加载器；\n\n', 'A', NULL, NULL, '37、Java类加载表述正确的是()\n\nA URLClassLoader的签名校验依赖jar包里的公钥，因此不能使用URLClassLoader来校验jar的合法性；（里面可能被人修改过，里面是底层的源码）\n\nB 在JVM中将不同的ClassLoader实例加载的同一个类视为相同的类；（看来不同的加载器生成的类也是不同的）\n\nC 开发者不可以自定义类加载器；\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (29, '以下描述错误的是', 'A public String getProductSummary(int index) {\n    return products[index];\n}\n//该代码中index未校验，可能相起数组越界访问\n\nB String userName = \"name”;\n  ResultSet rs = st.executeQuery(\"select * from user where name = ‘” + userName + \"’”);\n//该代码可能会产生SQL注入漏洞\n\nC Runtime.getRuntime().exec(\"cmd.exe /c dir ” + args[0]);\n//该代码可能会引起命令注入\n\nD String command = System.getProPerty(\"command”);\n  Runtime.getRuntime().exec(\"command”);\n//该代码可能会引起OS命令注入', 'B', 'B 这题好牵强哦~ 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验', NULL, '38、以下描述错误的是A1public String getProductSummary(int index) {2return products[index];3}4//该代码中index未校验，可能相起数组越界访问B1String userName = \"name”;2ResultSet rs = st.executeQuery(\"select * from user where name = ‘” + userName + \"’”);3//该代码可能会产生SQL注入漏洞（是不是里面的双引号起的作用）C1Runtime.getRuntime().exec(\"cmd.exe /c dir ” + args[0]);2//该代码可能会引起命令注入D1String command = System.getProPerty(\"command”);2Runtime.getRuntime().exec(\"command”);3//该代码可能会引起OS命令注入（这个和环境变量耦合在一起的使用命令）答案：B', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (30, '以下代码可能导致命令注入的的有()', 'A String encodeIP=HWEncoder.encodeForOS(new WindowsCodec(),args[0]);\n  String cmd=\"cmd.exe /c ping \"+encodeIP;\n\nB if(Pattern.matches(\"[0-9A-Za-z@]+”, dir)) {\n    Process proc=rt.exec(cmd.exec/c\" + dir);\n   }\n\nC  File dir=new File(args[0]);\n   if(!validate(dir)){\n    System.out.println(\"An illegal directory”);\n   }\n\nD Processor proc=rt.exec(\"cmd.exe /c dir ” + args[0]);', 'D', '选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入\n选项B：使用正则校验，过滤特殊字符\n选项C：对文件的有效性进行校验\n选项D：无任何校验，可能导致命令注入', NULL, '39、以下代码可能导致命令注入的的有()A1String encodeIP = HWEncoder.encodeForOS(new WindowsCodec(), args[0]);2String cmd = \"cmd.exe /c ping \" + encodeIP;B1if (Pattern.matches(\"[0-9A-Za-z@]+”, dir)) {2Process proc = rt.exec(cmd.exec /c \" + dir);3}C1File dir = new File(args[0]);2if (!validate(dir)) {（对文件进行了检查）3System.out.println(\"An illegal directory”);4}D1Processor proc = rt.exec(\"cmd.exe /c dir ” + args[0]);答案：D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (31, '关于异常的说法错误的是\n\n', 'A BindException异常泄露时可能造成开放端口列举\n\nB 当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤\n\nC FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构；\n\nD 可以在代码最外层捕获NullPointException防止代码出现预期之外的行为\n\n', 'D', NULL, NULL, '40、关于异常的说法错误的是\n\nA BindException异常泄露时可能造成开放端口列举\n\nB 当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤\n\nC FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构；\n\nD 可以在代码最外层捕获NullPointException防止代码出现预期之外的行为\n\n答案：D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (32, '下面关于异常处理的描述错误的是\n\n', 'A FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常（这个也是敏感异常）（DOS攻击）\n\nB 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理\n\nC 输入校验是一个常用的防止通过异常泄露敏感信息的方式；\n\nD 必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户\n\n', 'A', NULL, NULL, '41、下面关于异常处理的描述错误的是\n\nA FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常（这个也是敏感异常）（DOS攻击）\n\nB 对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理\n\nC 输入校验是一个常用的防止通过异常泄露敏感信息的方式；\n\nD 必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户\n\n答案：A', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (33, '关于锁的说法错误的是\n\n', 'A 封包过Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例\n\nB 使用new出来的Integer实例作为对象的内置锁可能导致死锁\n\nC 在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁；\n\nD Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。\n\n', 'B', 'A:-128~127将存入缓存\nB:new出来的好像没有什么问题\nC:这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存\nD:都是用的这两个', NULL, '42、关于锁的说法错误的是\n\nA 封包过Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例\n\nB 使用new出来的Integer实例作为对象的内置锁可能导致死锁（new出来的好像没有什么问题）\n\nC 在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁；（这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存）\n\nD Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。（都是用的这两个）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (34, '状态变量不包括\n\n', 'A capacity：最大容量\n\nB flag：读写状态位\n\nC position：当前已经读到的字节数\n\nD limit：剩下的字节数（写入的时候奏效）\n\n', 'B', NULL, NULL, '43、 Java IO Buffer状态变量不包括\n\nA capacity：最大容量\n\nB flag：读写状态位\n\nC position：当前已经读到的字节数\n\nD limit：剩下的字节数（写入的时候奏效）\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (35, '正则表达式\\[^A-Za-z0-9_\\]与以下哪个表达式等价', '\n\nA \\t\n\nB \\d\n\nC \\W\n\nD \\v\n\nE \\w\n\n', 'C', NULL, NULL, '44、正则表达式\\[^A-Za-z0-9_\\]与以下哪个表达式等价\n\nA \\t\n\nB \\d\n\nC \\W = [^A-Za-z0-9_]（所以大W，都是去反的含义字母和数字）\n\nD \\v\n\nE \\w = [A-Za-z0-9_]\n\n答案：C', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 2, 4, 2);
INSERT INTO `question` VALUES (36, '关于多线程并发如下说法正确的是\n\n', 'A 对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁\n\nB 能用无锁数据结构，就不要用锁\n\nC 能用对象锁，就不要用类锁\n\nD 能锁区块，就不要锁方法体\n\n', 'ABCD', NULL, NULL, '46、关于多线程并发如下说法正确的是\n\nA 对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁（有道理）\n\nB 能用无锁数据结构，就不要用锁\n\nC 能用对象锁，就不要用类锁\n\nD 能锁区块，就不要锁方法体（尽可能的减少影响的方法）\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (37, '方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流（流也会被分别清空吗）（一会再次来解决这个）\n\n', 'A 错误流\n\nB 监控流\n\nC 输出流\n\nD 输入流\n\n', 'ACD', NULL, NULL, '47、Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流（流也会被分别清空吗）（一会再次来解决这个）\n\nA 错误流\n\nB 监控流\n\nC 输出流\n\nD 输入流\n\n答案：ACD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 1);
INSERT INTO `question` VALUES (38, '属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是（）', 'A.public class GpsLocation implements Serializable {\n    private double from;\n    private double to;\n    private String id;\n    // non-sensitive field    \n    // other content\n}\n\nB.public class GpsLocation implements Serializable {\n    private double from;\n    private double to;\n    private String id;\n    // non-sensitive field\n    // other content\n    private static final ObjectStreamField[] serialPersistentFields = {\n        new ObjectStreamField(\"id\", String.class)\n    };\n}\n\nC.public class GpsLocation implements Serializable {\n    private volatile double from;\n    private volatile double to;\n    private String id;\n    // non-sensitive field\n    // other content\n}\n\nD .public class GpsLocation implements Serializable {\n    private transient double from;\n    private transient double to;\n    private String id;\n    // non-sensitive field\n    // other content\n}', 'BD', '防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确', NULL, '48、属性from to保存的是敏感信息，则以下代码中序列化没有安全问题的是（）A.1public class GpsLocation implements Serializable{2private double from;3private double to;4private String id; // non-sensitive field5// other content6}（完全裸露在外）B.1public class GpsLocation implements Serializable{2private double from;3private double to;4private String id; // non-sensitive field5// other content6private static final ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"id\", String.class)};7}（看来它认为from和to是敏感信息，明确了只能序列化的字段）C.1public class GpsLocation implements Serializable{2private volatile double from;3private volatile double to;4private String id; // non-sensitive field5// other content6}D.1public class GpsLocation implements Serializable{2private transient double from;3private transient double to;4private String id; // non-sensitive field5// other content6}答案：BD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (39, '下列单例实现正确的是', 'A.\npublic final class Helper {\n    public Helper() {\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n\n    public Helper getHelper() {\n        if (helper == null) {\n            synchronized (this) {\n                if (helper == null) {\n                    helper = new Helper();\n                }\n            }\n        }\n        return helper;\n    }\n}\n\nB. \npublic final class Helper {\n    private final int n;\n\n    public Helper(int n) {\n        this.n = n;\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        Helper h = helper;\n        if (h == null) {\n            synchronized (this) {\n                h = helper;\n                if (h == null) {\n                    h = new Helper(42);\n                    helper = h;\n                }\n            }\n        }\n        return h;\n    }\n}\n\nC.\npublic final class Helper {\n    private final int n;\n\n    public Helper(int n) {\n        this.n = n;\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        if (helper == null) {\n            synchronized (this) {\n                if (helper == null) {\n                    helper = new Helper(42);\n                }\n            }\n        }\n        return helper;\n    }\n}\n\nD.\npublic final class Helper {\n    public Helper() {\n    }\n}\nfinal class Foo {\n    private static class Holder {\n        static Helper helper = new Helper();\n    }\n    public Helper getInstance() {\n        return Holder.helper;\n    }\n}', 'BD', '选项A的private Helper helper = null; 没有加volatile进行修饰，可能线程A和线程B都进入了第一个判断，但是A先获取锁，B被阻塞，A释放后创建了helper对象但是B又能获取锁创建一个新的helper对象违背单例模式原则\n\n选项B在获取锁后重新赋值了h的值类似与volatile通知线程修改副本值，所以即使没有加入volatile修饰也是可行的\n选项C同选项A一样选项\n\nD是饿汉式非懒加载，但是线程安全故选择：BD', NULL, '49、下列单例实现正确的是A.1public final class Helper{2public Helper() { }3}4final class Foo{5private Helper helper = null;6public Helper getHelper(){（这是双重锁机制带来的问题导致的）7if(helper ==null){()8synchronized (this){9if(helper ==null){10helper = new Helper();11}12}13}14return helper;15}16}B.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10Helper h =helper;11if (h == null) {12synchronized (this) {13h=helper;（这个是什么含义呢）14if (h == null) {15h = new Helper(42);16helper = h;17}18}19}20return h;21}22}C.1public final class Helper {2private final int n;3public Helper(int n) {4this.n = n;5}6}7final class Foo {8private Helper helper = null;9public Helper getHelper() {10if (helper == null) {11synchronized (this) {12if (helper == null) {13helper = new Helper(42);14}15}16}17return helper;18}19}D.1public final class Helper {2public Helper() {}3}4final class Foo {5private static class Holder{6static Helper helper = new Helper()（虽然不是懒加载机制，但是也是可行的）;7}8public Helper getInstance(){9return Holder.helper;10}11}答案：BD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (40, '有关线程池关闭 说明正确的有\n\n', 'A. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，指导线程池中等待的任务全部处理完\n\nB. 执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出\n\nC. 执行shutdown方法中，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出\n\nD. 执行shutdownNow方法后，不能能再往线程池中添加任务，线程池视图停止所有正在执行的线程，不再处理池中等待的任务\n\n', 'CD', NULL, NULL, '50、有关线程池关闭 说明正确的有\n\nA. 执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，指导线程池中等待的任务全部处理完\n\nB. 执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出\n\nC. 执行shutdown方法中，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出\n\nD. 执行shutdownNow方法后，不能能再往线程池中添加任务，线程池视图停止所有正在执行的线程，不再处理池中等待的任务\n\n答案：CD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (41, '哪些是同步的？\n\n', 'A. TreeSet\n\nB. HashTable\n\nC. Vector\n\nD. LinkedList\n\n', 'BC', NULL, NULL, '51、哪些是同步的？\n\nA. TreeSet\n\nB. HashTable\n\nC. Vector\n\nD. LinkedList\n\n答案：BC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (42, '已知如下代码\npublic static void main(String[] args) {\n    int nr = 5;\n    do {\n        System.out.print(nr);\n    } while (--nr > 5);\n    System.out.print(\"finished\");\n}\n执行后的输出包含什么？', 'A. 5\n\nB. 4\n\nC. finished\n\nD. 6', 'AC', '首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished', NULL, '52、已知如下代码1public static void main(String[] args) {2int nr = 5;3do{4System.out.print(nr)5}while(--nr>5);6System.out.print(\"finished\");7}执行后的输出包含什么？A. 5B. 4C. finishedD. 6答案：AC', '科目2', 'MULTI_CHOICE', 0, 0, 0, 2, 5, 1);
INSERT INTO `question` VALUES (43, '正则表达式A*B可以匹配', '\n\nA. ACD\n\nB. AAB\n\nC. A\n\nD. AB\n\n', 'BD', NULL, NULL, '53、正则表达式A*B可以匹配\n\nA. ACD\n\nB. AAB\n\nC. A\n\nD. AB\n\n答案：BD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (44, '关于File的描述，正确的是?\n\n', 'A. File实例 不能用于封装目录只用于封装文件\n\nB. 创建一个File类的实例将导致打开指定文件进行读写\n\nC. File实例封装了指定文件的信息\n\nD. File类位于jav.io包中\n', 'CD', NULL, NULL, '54、关于File的描述，正确的是?\n\nA. File实例 不能用于封装目录只用于封装文件\n\nB. 创建一个File类的实例将导致打开指定文件进行读写（按照它的意思，你不执行读写，是不会生效的）\n\nC. File实例封装了指定文件的信息\n\nD. File类位于jav.io包中（这个只能死记硬背）\n\n答案：CD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 3, 4, 0);
INSERT INTO `question` VALUES (45, '关于主动调用gc方法的描述，下列说法正确的是\n\n', 'A. 在频率/周期性的逻辑中更要尽量 避免主动GC的调用\n\nB. 在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险（说的有道理）\n\nC. 调用主动GC方法后，系统立即进行垃圾回收操作（系统也要找机会才行）\n\nD. 如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间\n\n', 'ABD', NULL, NULL, '55、关于主动调用gc方法的描述，下列说法正确的是\n\nA. 在频率/周期性的逻辑中更要尽量 避免主动GC的调用\n\nB. 在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险（说的有道理）\n\nC. 调用主动GC方法后，系统立即进行垃圾回收操作（系统也要找机会才行）\n\nD. 如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间\n\n答案：ABD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (46, '关于数据校验的说法正确的是（）\n\n', 'A. 在对不可信数据进行校验时，禁止使用assert语句（）\n\nB. \"白名单\"方式净化的方式包括删除，编码 ，替换\n\nC. \"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新 ，该校验方式就会很快过时\n\nD. 尽可能使用接收一直合法数据的白名单策略（这个我是记得的）\n\n', 'ABCD', NULL, NULL, '56、关于数据校验的说法正确的是（）\n\nA. 在对不可信数据进行校验时，禁止使用assert语句（）\n\nB. \"白名单\"方式净化的方式包括删除，编码 ，替换\n\nC. \"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新 ，该校验方式就会很快过时\n\nD. 尽可能使用接收一直合法数据的白名单策略（这个我是记得的）\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 1);
INSERT INTO `question` VALUES (47, '语言中，如果编写一个多线程程序，可以使用的方法是\n\n', 'A. 扩展类Thread\n\nB. 实现Runnable接口\n\nC. 实现接口Thread\n\nD. 扩展类Runnable\n\n', 'AB', NULL, NULL, '57、Java语言中，如果编写一个多线程程序，可以使用的方法是\n\nA. 扩展类Thread\n\nB. 实现Runnable接口（这个完全就是基本功）\n\nC. 实现接口Thread\n\nD. 扩展类Runnable\n\n答案：AB', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (48, '仅保存口令hash，不加盐的缺陷有\n\n', 'A. 攻击者可以使用实现计算好的哈希列表在几秒钟之内破解口令\n\nB. 加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加\n\nC. 没有盐值，攻击者可以根据哈希值反向解密出原始口令\n\nD. 由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候（难道是有什么规律吗）\n\n', 'ABD', 'C:hash不可逆', NULL, '58、仅保存口令hash，不加盐的缺陷有\n\nA. 攻击者可以使用实现计算好的哈希列表在几秒钟之内破解口令\n\nB. 加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加\n\nC. 没有盐值，攻击者可以根据哈希值反向解密出原始口令（hash不可逆）\n\nD. 由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候（难道是有什么规律吗）\n\n答案：ABD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 2, 1);
INSERT INTO `question` VALUES (49, '类加载器说法正确的是：\n\n', 'A. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\n\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\n\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定 的路径中的所有类\n\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader\n\n', 'ABC', NULL, NULL, '59、类加载器说法正确的是：\n\nA. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\n\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\n\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定 的路径中的所有类\n\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader\n\n答案：ABC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 5, 4, 7);
INSERT INTO `question` VALUES (50, '关于异常，下列说法正确的是：\n\n', 'A. 如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码\n\nB. 方法抛出的异常，应该与本身的抽象层次相对应\n\nC. 对可容错处理的情况使用受检异常，对编程错误使用运行时异常\n\nD. 一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中年记录每个抛出的异常及其条件\n\n', 'BCD', NULL, NULL, '60、关于异常，下列说法正确的是：\n\nA. 如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码\n\nB. 方法抛出的异常，应该与本身的抽象层次相对应\n\nC. 对可容错处理的情况使用受检异常，对编程错误使用运行时异常\n\nD. 一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中年记录每个抛出的异常及其条件\n\n答案：BCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (51, '栈帧的大小在什么时候确定的？\n\n', 'A. 程序代码编译时\nB. 类加载时\nC. 运行调用时\n', 'A', '程序代码编译时确定', NULL, '61.栈帧的大小在什么时候确定的？\n\nA. 程序代码编译时\nB. 类加载时\nC. 运行调用时\n答案：A，程序代码编译时确定。', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 2, 4, 0);
INSERT INTO `question` VALUES (52, '如下四种数组声明方式，哪种不正确？\n\n', 'A int[] hello1 = {1,2,3,4};\nB int[] hello2 = new int[4] {1,2,3,4};\nC int[] hello3 = new int[] {1,2,3,4};\nD int[] hello4 = new int[4];\n\n', 'B', NULL, NULL, '63.如下四种数组声明方式，哪种不正确？\n\nA int[] hello1 = {1,2,3,4};\nB int[] hello2 = new int[4] {1,2,3,4};\nC int[] hello3 = new int[] {1,2,3,4};\nD int[] hello4 = new int[4];\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 1, 3, 0);
INSERT INTO `question` VALUES (53, '与表达式 Integer a = 2;等价的类型是哪个？\n\n', 'A. int b = Integer.parseInt(“2”);\n\nB. Integer b = Integer.valueOf(“2”);\n\n', 'B', '解析：\nInteger.valueOf(value)在-128~127间，则会重用内存中缓存的对象', NULL, '66.与表达式 Integer a = 2;等价的类型是哪个？\n\nA. int b = Integer.parseInt(“2”);\n\nB. Integer b = Integer.valueOf(“2”);\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (54, '精度最高的数据类型？\n\n', 'A. int\nB. long\nC.BigInteger\nD.byte\n', 'C', '和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', NULL, '70.精度最高的数据类型？\n\nA. int\nB. long\nC.BigInteger\nD.byte\n答案：C\n\n和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 2, 4, 0);
INSERT INTO `question` VALUES (55, '以下异常列表哪些属于敏感异常（）？\n\n', 'A. java.io.FileNotFoundException\n\nB. java.net.BindException\n\nC. java.util.ConcurrentModificationException\n\nD. java.sql.SQLException\n\nE. java.lang.NullPointerException\n\nF. java.lang.IllegalArgumentException\n\n', 'ABCD', '', NULL, '77.以下异常列表哪些属于敏感异常（）？\n\nA. java.io.FileNotFoundException\n\nB. java.net.BindException\n\nC. java.util.ConcurrentModificationException\n\nD. java.sql.SQLException\n\nE. java.lang.NullPointerException\n\nF. java.lang.IllegalArgumentException\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (56, '下列哪个数据结构不是继承自集合Collection类？\n\n', 'A. List\r\nB. Set \r\nC. Queue \r\nD. Map', 'D', NULL, NULL, '78.下列哪个数据结构不是继承自集合Collection类？\n\nA. List B. Set C. Queue D. Map\n\n答案： D', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (57, '不修改Map说的是什么，如下语句是否可以正确执行？ \nMap<Integer,String> test = new HashMap<>();\ntest.put(1,“hello”);\ntest.put(2,“unmodifiable”);\nMap<Integer,String> umap = Collections.unmodifiableMap(test);\numap.clear();\n', 'A 正确\nB 错误\n', 'B', NULL, NULL, '79.不修改Map说的是什么，如下语句是否可以正确执行？ \nMap<Integer,String> test = new HashMap<>();\ntest.put(1,“hello”);\ntest.put(2,“unmodifiable”);\nMap<Integer,String> umap = Collections.unmodifiableMap(test);\numap.clear();\nA 正确\nB 错误\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (58, '哪个类写操作是线程安全的？\n\n', 'A.FileWriter\n\nB.RandomAccessFile\n\nC.FileOutputStream\n\nD.FileChannel\n\n', 'D', 'http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png', NULL, '83.哪个类写操作是线程安全的？\n\nA.FileWriter\n\nB.RandomAccessFile\n\nC.FileOutputStream\n\nD.FileChannel\n\n答案： D', '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (59, '以下NIO语句是否有错误？\n\n', 'A.大二进制文件读入\nB. 小二进制文件读入\nC. 小文本按行读入\nD. 小文本按字节数读入\nE. 结尾插入数据采用.APPEND而不是 .CREATE\n\n', 'E', NULL, NULL, '84.以下NIO语句是否有错误？\n\nA.大二进制文件读入\nB. 小二进制文件读入\nC. 小文本按行读入\nD. 小文本按字节数读入\nE. 结尾插入数据采用.APPEND而不是 .CREATE\n\n答案：E', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 1, 1);
INSERT INTO `question` VALUES (60, 'Java8 中stream流的概念和使用问题。如下选项，哪个是对的（）\n\n', 'A．stream 流的数据ﾷ源只能是数组、容器、文件\n\nB． stream 流跟迭代器一样，使用完再次使用时需要重新生成\n\nC. stream的map是中间结果???\n\nD. ???\n\n', 'B', NULL, NULL, '88.（单选）Java8 中stream流的概念和使用问题。如下选项，哪个是对的（）\n\nA．stream 流的数据源只能是数组、容器、文件\n\nB． stream 流跟迭代器一样，使用完再次使用时需要重新生成\n\nC. stream的map是中间结果???\n\nD. ???\n\n答案：B', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (61, '变量命名符合规范的有哪些？\n\n', 'A. private boolean isNotFound;\n\nB. enum {male,female}\n\nC. private String userName;\n\nD. private static final int NUM_FIVE = 5;\n\n', 'C', NULL, NULL, '89.变量命名符合规范的有哪些？\n\nA. private boolean isNotFound;\n\nB. enum {male,female}\n\nC. private String userName;\n\nD. private static final int NUM_FIVE = 5;\n\n答案：C', '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (62, '禁止采用如下哪些算法进行口令加密？\n\n', 'A. RSA\n\nB. DES\n\nC. SKIPJACK\n\nD.MD5\n\n', 'BD', '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', NULL, '92.禁止采用如下哪些算法进行口令加密？\n\nA. RSA\n\nB. DES\n\nC. SKIPJACK\n\nD.MD5\n\n答案：BD，迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (63, '常见敏感异常：(考了原题)\n\n', 'A java.io.FileNotFoundException \n\nB java.util.jar.JarException \n\nC java.util.MissingResourceException \n\nD java.security.acl.NotOwnerException \n\nE java.util.ConcurrentModificationException \n\nF javax.naming.InsufficientResourcesException \n\nG java.net.BindException \n\nH java.lang.OutOfMemoryError \n\nI java.lang.StackOverflowError\n\nO java.sql.SQLException \n', 'ABCDEFGHIO', 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', NULL, '94.常见敏感异常：(考了原题)\n\nA java.io.FileNotFoundException 泄露文件系统结构和文件名列举\n\nB java.util.jar.JarException 泄露文件系统结构\n\nC java.util.MissingResourceException 资源列举\n\nD java.security.acl.NotOwnerException 所有人列举\n\nE java.util.ConcurrentModificationException 可能提供线程不安全的代码信息\n\nF javax.naming.InsufficientResourcesException 服务器资源不足（可能有利于DoS攻击）\n\nG java.net.BindException 当不信任客户端能够选择服务器端口时造成开放端口列举\n\nH java.lang.OutOfMemoryError DoS\n\nI java.lang.StackOverflowError DoS\n\nO java.sql.SQLException 数据库结构，用户名列举\n答案：ABCDEFGHIO', '科目2', 'MULTI_CHOICE', 0, 0, 0, 3, 3, 1);
INSERT INTO `question` VALUES (64, '不能被哪些修饰符修饰？\n\n', 'A: private\n\nB: public\n\nC: final\n\nD: abstract\n\n', 'AC', NULL, NULL, '95.Interface不能被哪些修饰符修饰？\n\nA: private\n\nB: public\n\nC: final\n\nD: abstract\n\n答案：AC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 2, 3, 0);
INSERT INTO `question` VALUES (65, '正则匹配\"^[a-zA-Z0-9_]+@[(a-zA-Z)+.]+com$\"，哪些是匹配的？ \n\n', 'A) abc@host.com\n\nB) abc_@host.com\n\nC) abc@host.org.com\n\nD) abc_@host+com\n\n', 'ABCD', NULL, NULL, '96.正则匹配\"^[a-zA-Z0-9_]+@[(a-zA-Z)+.]+com$\"，哪些是匹配的？ \n\nA) abc@host.com\n\nB) abc_@host.com\n\nC) abc@host.org.com\n\nD) abc_@host+com\n\n答案：ABCD', '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (66, '能够产生DoS攻击的敏感异常有哪些（）？', 'A. Java.lang.OutOfMemoryError\r\n\r\nB. Java.lang.StackOverflowError\r\n\r\nC. javax.naming.InsufficientResourcesException\r\n\r\nD. java.util.jar.JarException', 'ABC', NULL, NULL, '76.能够产生DoS攻击的敏感异常有哪些（）？\r\n\r\nA. Java.lang.OutOfMemoryError\r\n\r\nB. Java.lang.StackOverflowError\r\n\r\nC. javax.naming.InsufficientResourcesException\r\n\r\nD. java.util.jar.JarException\r\n\r\n答案: ABC', '科目2', 'MULTI_CHOICE', 1, 0, 0, 8, 3, 0);
INSERT INTO `question` VALUES (67, '以下代码的执行结果\nchar alpha = \'A\';\nint foo = 65;\nboolean trueExp = true;\nSystem.out.println(trueExp ? alpha : 0);\nSystem.out.println(trueExp ? alpha : foo);', 'A、A A\nB、65 65\nC、A 65\nD、65 A', 'C', '参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (68, '下面代码执行结果是？ \nTreeSet<Person> personSet = new TreeSet<>((o1, o2) -> o1.age - o2.age);\npersonSet.add(new Person(\"zhao\", 2));\npersonSet.add(new Person(\"qian\", 4));\npersonSet.add(new Person(\"sun\", 1));\npersonSet.add(new Person(\"li\", 4));\nSystem.out.println(personSet);', 'A sun zhao li qian\nB sun zhao qian li\nC sun zhao qian\nD sun zhao li', 'C', '在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (69, '属于经过验证、安全的、公开的加密算法的是', 'A、AES的ECB模式\nB、RSA\nC、DSA/ECDSA\nD、加入盐值的SHA256\nE、DES', 'BCD', '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (70, '输入校验不可以防止以下哪种漏洞？', 'A. CSRF\nB. SQL注入\nC. XSS\nD. XML注入', 'AC', '有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (71, '下面代码运行结果是？\n    public static void main(String[] args) {\n        try {\n            System.out.println(\"aa:\" + func());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    private static int func() throws Exception {\n        for (int i = 0; i < 1; i++) {\n            try {\n                throw new Exception(\"bb\");\n            } catch (Exception e) {\n                throw e;\n            } finally {\n                continue;\n            }\n        }\n        return 0;\n    }', 'A、aa:0\nB、抛出异常\nC、编译错误\nD、既打印aa:0 同时抛出异常', 'A', '这里finally的continue使得catch中的throw e无效了', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 4, 0);
INSERT INTO `question` VALUES (72, '关于下面代码中shutdown方法说法正确的是\npublic static void main(String[] args) throws Exception {\n    ExecutorService executorService = Executors.newFixedThreadPool(10);\n    for (int i = 0; i < 100; i++) {\n        executorService.submit(new Task());\n    }\n    executorService.shutdown();\n    static class Task extends Thread {\n        @Override\n        public void run() {\n        }\n    }\n}', 'A， 线程池不再接收新的任务，队列中等待任务不会执行\nB， 线程池终止正在执行的线程\nC， 线程池终止正在执行的线程，和B差不多\nD， 线程池不再接收新的任务，队列中等待的任务会执行', 'D', 'shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 0, 0, 0, 4, 0);
INSERT INTO `question` VALUES (73, '以下哪些在接收到Thread.interrupt()会抛出InterruptedException异常', 'A、Thread.sleep()\nB、java.net.Socket的阻塞方法\nC、java.nio.channels.SocketChannel的阻塞方法\nD、Thread.wait()', 'ACD', '在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (74, '以下代码中，可以被gc回收的对象有\nclass A {\n \n}\n \npublic class Test {\n    private static A staticA = new A();\n    public static final String CONSTANT = \"i am a string\";\n    public static void main(String[] args) {\n        A innerA = new A();\n    }\n}', 'A、staticA\nB、CONSTANT\nC、“i am a string”\nD、innerA', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (75, '栈帧的内部结构', 'A.动态链接\nB.局部变量表\nC.操作数栈\nD.方法返回地址', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (76, '默认jvm参数运行时，会做哪些优化？', 'A. JITTest.doubleIndex被内联\nB. JITTest.doubleIndex会被编译成机器码执行\nC. JITTest.sum会被编译成机器码执行\nD. 拆箱和装箱', 'ABC', '默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 5, 3, 0);
INSERT INTO `question` VALUES (77, '下列有关Java反射的说法 错误 的是：', 'A 反射可以获取Method，通过invoke进行方法的调用；\nB 反射不可以直接通过getField获取私有成员的值；\nC 反射可以获取注解（@Target为Runtime）信息；\nD 反射可以获取类的构造器；', 'C', 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (78, '下面代码执行结果？\npublic class Object1 {\n    private String name=\"java\";\n    public static void main(String[] args)\n        throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {\n        Object1 object1 = Object1.class.getDeclaredConstructor().newInstance();\n        for (Field declaredField : Object1.class.getDeclaredFields()) {\n            System.out.println(declaredField.get(object1));\n        }\n\n        Object2 object2 = Object2.class.getDeclaredConstructor().newInstance();\n        for (Field declaredField : Object2.class.getDeclaredFields()) {\n            System.out.println(declaredField.get(object2));\n        }\n    }\n}\nclass Object2{\n    private String name=\"java\";\n}', 'A、抛出异常\nB、java\nC、java 抛出异常\nD、java java', 'C', '这个暂时记住先。。。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 4, 1);
INSERT INTO `question` VALUES (79, '以下代码输出：\nclass Parent {\n    public int a = 100;\n    private int b = 200;\n    protected int c =300;\n    public int f() {\n        return 10;\n    }\n    public static void main(String[] args) throws IllegalAccessException, InstantiationException {\n        Field[] fields = Parent.class.getDeclaredFields();\n        System.out.println(fields.length);\n \n        Field[] fields1 = Parent.class.getFields();\n        System.out.println(fields1.length);\n    }\n}', 'A、1 3\nB、3 1\nC、1 1\nD、3 3', 'B', 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 4, 0);
INSERT INTO `question` VALUES (80, '关于Optional说法正确的是？', 'A. Optional可以被赋值为null\nB. Optional.of()可以用null做参数，返回Optional.empty()\nC. Optional.ofNullable(obj)，obj不为null时直接调用Optional.of(obj)\nD. Optiona.of()可以放置集合或对象。', 'CD', 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (81, '父类的哪个不能被子类隐藏 ', 'A. 私有方法\nB. 属性\nC. 内部类\nD. 静态方法', 'A', '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 3, 4, 2);
INSERT INTO `question` VALUES (82, '以下代码输出什么\nString strTxt = \"123\\\\d\";\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'A 123456 123456 123456\nB 123456 123\\\\d 123456\nC 123\\\\d 123456 123\\\\d\nD 123\\d  123456 123\\d\nE 456456456\\d 123456 123456', 'E', '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 3, 0);
INSERT INTO `question` VALUES (83, '关于函数重写和重载，说法正确的是', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'ACD', 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (84, '根据通用规范，方法注释中不应出现如下', 'A、线程安全\nB、修改日期\nC、性能约束\nD、api特性、原理', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (85, '下面说法不正确的是：', '\nA、避免文件过长，不超过2000行（非空非注释行）\nB、一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔\nC、import包应当按照先华为公司，安卓、其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组\nD、一个类或接口的声明部分应当按照类变量、实例变量、构造器、方法的顺序出现，且用空行分隔', 'C', '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (86, '以下说法不正确的是？', 'A、Integer i1 = 10; Integer i2 = 10; i1和i2指向同一个对象\n\nB、整数型包装类型应使用equals做相等的比较\n\nC、基本类型优于包装类型\n\nD、浮点型包装类型建议使用equals或flt.compareTo(another)==0做相等的比较', 'D', '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (87, '以下说法正确的是', 'A、class Swan {\n    public static void fly() {\n        System.out.println(\"swan can fly ...\");\n    }\n}\nclass UglyDuck extends Swan {\n    public static void fly() {\n        System.out.println(\"ugly duck can\'t fly ...\");\n    }\n}\npublic class TestFly {\n    public static void main(String[] args) {\n        Swan swan = new Swan();\n        Swan uglyDuck = new UglyDuck();\n        swan.fly();\n        uglyDuck.fly();\n    }\n}\n输出：\nswan can fly …\nUglyDuck can fly …\n\nB、class WhoKnows {\n    static String sentence = \"I don\'t know.\";\n    public static void main(String[] args) {\n        String sentence = \"I know!\";\n        System.out.println(sentence);\n    }\n}\n输出\"I know!\"\n\nC、public class Obscure {\n    static String System;\n    public static void main(String[] args) {\n        System.out.println(\"hello, obscure world!\");\n    }\n}\n代码输出\"hello, obscure world!\"\n', 'B', 'A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (88, '以下代码正确的是：', 'A   String[] arr = new String[]{\"1\",\"2\",\"3\",\"4\",\"5\"};\n\nList<String> list =Arrays.asList(arr);\n\nlist.remove(\"5\");\n\nlist.add(\"6\");\n\nB   Map<String,String> map = new HashMap<>();\n\nmap.put(\"1\",\"a\");\n\nmap.put(\"2\",\"b\");\n\nList<String> list = new ArrayList<>();\n\nlist.addAll(map.values());\n\nlist.addAll(Collections.singleton(\"c\"));\n\nC   List<String> list = Collections.emptyList();\n\nlist.add(\"1\");\n\nD   List<String> list = new ArrayList<>();\n\nlist.add(\"1\");\n\nlist.add(\"2\");\n\nArrayList<String> subList = (ArrayList<String>) list.subList(0,0);', 'B', 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 5, 1);
INSERT INTO `question` VALUES (89, '将list转换为数组时最佳SIZE\nList<String> list = new ArrayList<>(DEFAULT_CAPACITY);\n\nlist.add(\"1\");\n\nlist.add(\"2\");\n\nString[] array = list.toArray(new String[SIZE]);', 'A、0  \nB、1  \nC、2 \nD、3', 'A', '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (90, '以下说法正确的是', 'A、建议使用String存储敏感数据，使用结束后立即赋为空\n\nB、使用java.net.Socket类在不安全的传输通道中传输敏感数据\n\nC、调用SecurityManager执行的安全检查，进行安全检查的方法必须声明为private或final\n\nD、编写自定义类加载器时，需要复写getPermissions()方法时，可以忽略了基类的getPermissions()', 'C', 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (91, '以下代码输出什么\nMap<Integer, Integer> map = new LinkedHashMap<Integer, Integer>(16,0.75f,true){\n@Override\nprotected boolean removeEldestEntry(Map.Entry eldest){\n        return size()\n> 5;\n}\n\n};\n\nfor(int i = 0; i < 10; i++){\nmap.put(i,i);\n\n}\n\nmap.get(6);\n\nSystem.out.println(map.keySet());', 'A、[5,6,7,8,9]\n\nB、[9,8,7,6,5]\n\nC、[5,7,8,9,6]\n\nD、[6,5,7,8,9] ', 'C', '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (92, '以下代码返回值为\nclass Point {\n    private int x;\n\n    public static void main(String[] args) {\n        System.out.println(test1().x);\n        System.out.println(test2());\n        System.out.println(test3());\n    }\n    public static Point test1() {\n        Point p = new Point();\n        try {\n            p.x = 20;\n            return p;\n        } finally {\n            p.x = 30;\n        }\n    }\n    public static int test2() {\n        int a = 100;\n        try {\n            a = 200;\n            return a;\n        } finally {\n            a = 300;\n        }\n    }\n    public static int test3() {\n        int a = 100;\n        try {\n            a = 200;\n            return a;\n        } finally {\n            a = 300;\n            return a;\n        }\n    }\n}', 'A、30 200 200\n\nB、20 200 300\n\nC、30 200 300\n\nD、20 300 200', 'C', '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (93, '可能触发fullgc的条件', 'A、MaxDirectMemeorySize写满\n\nB、永生代（Perm）或Metaspace被写满\n\nC、年老代（tenured）被写满\n\nD、显示调用System.gc', 'ABCD', '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (94, '关于溢出描述正确的是', 'A、java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。\n\nB、java.lang.StackOverflowError: 线程栈空间不足\n\nC、java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (95, '以下说法不正确的是', 'A、当关闭断言时，会导致程序的运行结果不一致\n\nprivate ArrayList<String> names;\n\nvoid process(int index) {\n\nassert names.remove(null);\n\n// ...\n\n}\nB、建议子类通过重载扩大方法的可访问性，这样可以拥有更大的访问权限\nC、对于实现了java.lang.Cloneable接口的类，应该将方法clone()的可访问性从protected增加为public\nD、如果忽略方法的返回值或对函数调用失败情况未正确处理，可能会导致安全风险。', 'B', 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 3, 4, 1);
INSERT INTO `question` VALUES (96, '以下说法不正确的是', 'A、使用不可信数据构造格式化字符串时，当转换参数与对应的格式符不匹配时，标准类库会抛出异常，不会造成系统信息泄露或拒绝服务\n\nB、用户可以通过输入一个回车符或一个换行符（CRLF）来将一条合法日志拆分成两条日志，使得日志内容可能令人误解\n\nC、尽可能使用“黑名单”策略来接收跨信任边界的数据，而不是使用白名单，白名单校验方式较弱\n\nD、对不可信数据校验建议使用断言的方式校验', 'ACD', 'A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 16, 4, 3);
INSERT INTO `question` VALUES (97, '以下说法正确的是', 'A、将含敏感数据的对象跨信任域传递前需要先加密后签名\n\nB、默认情况下，自动签名认证机制使用JAR文件中包含的公钥来验证签名，这就可以保证公钥和签名未被恶意篡改\n\nC、一些常用的JSON框架都具有type功能，它可以很方便的将java的对象类型和json数据格式之间进行转换，建议默认开启JSON框架的type功能\n\nD、非静态的内部类序列化时会隐式的对外部类实例的非transient对象进行序列化', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 4, 1);
INSERT INTO `question` VALUES (98, 'java中用来对字符串做归一化的方法是', 'A、java.lang.String.intern()\n\nB、java.lang.String.trim()\n\nC、java.text.Format.format()\n\nD、java.text.Normalizer.normalize()', 'D', '在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (99, '以下说法不正确的是', 'A、临时文件由于会定期被清理掉，所以不用显示的清理临时文件\n\nB、java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改\n\nC、运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空\n\nD、Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值', 'ABD', 'A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (100, '以下代码正确的是', 'A、short s = 1;s = s + 1;\n\nB、\n\nint big = 1999999999;\n\nfloat one=1.0f;\n\nSystem.out.println(big * one);\n\n \n\nC、\n\nint ni = 6789;\n\ndouble d1 = ni / 30;\n\n \n\nD、\n\nlong nl = 4664382371590123456L;\n\ndouble d2 = (double) nl * 2;', 'D', 'A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (101, '关于可变参数说法正确的是', 'A、可以接受指定类型的1个到多个参数\n\nB、不建议使用varargs重写使用一个固定长度数组作为参数的方法\n\nC、JDK1.5引入Varargs（variable number of arguments）可变数量参数，应该在确实需要操作可变长度的值的序列时使用\n\nD、可变参数必须位于最后一项', 'BCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 4, 5, 2);
INSERT INTO `question` VALUES (102, '关于方法说法正确的是', 'A、方法的参数个数不应超过5个\n\nB、构造方法如果参数较多，尽量重用\n\nC、方法的入参建议当做工作变量/临时变量\n\nD、避免方法过长，不超过50行（非空非注释）；避免方法的代码块嵌套过深，不要超过4层', 'ABD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 2, 4, 0);
INSERT INTO `question` VALUES (103, '以下说法正确的是', 'A、Java 8使用Optional代替null作为返回值或者可能的缺失值;禁止对optional对象赋值为null\n\nB、禁止对optional对象赋值/返回为null，或与null比较\n\nC、不应该返回Optional<Integer> , Optional<Long> , Optional<Double> ,而用OptionalInt,OptionalLong,OptionalDouble\n\nD、枚举常量的序号生成建议依赖ordinal()方法', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 4, 7, 1);
INSERT INTO `question` VALUES (104, '以下说法正确的是', 'A、不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符\n\nB、编码时尽量依赖平台默认的字符编码方式\n\nC、String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换\n\nD、使用java.nio.charset中的类编码解码字符集', 'AD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (105, '关于接口说法正确的是', 'A、接口中可包含静态方法和default方法\n\nB、接口中属性默认public static final修饰词\n\nC、方法已缺省具有public abstract修饰词', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 3, 1);
INSERT INTO `question` VALUES (106, '目录遍历攻击可以直接带来哪些危害？', 'A、攻击者可以访问受限目录和文件\n\nB、攻击者可以篡改系统的任意文件\n\nC、攻击可可以恶意删除系统中的文件\n\nD、攻击者可以窃取内存中数据', 'ABC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (107, '预防ReDos攻击，比较有效的防护手段有', 'A、进行正则匹配前，先对匹配的文本的长度进行校验\n\nB、在编写正则时，尽量不要使用过于复杂的正则，越复杂越容易有缺陷\n\nC、在编写正则时，尽量减少分组的使用\n\nD、避免动态构建正则，当使用不可信数据构造正则时，要使用黑名单进行严格校验', 'ABC', '避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (108, '防止未加密的敏感数据被序列的方法有', 'A、使用transient定义敏感数据\n\nB、使用serialPersistentFields定义非敏感数据\n\nC、重新定义Serializable接口的writeObject()、writeReplace()、writeExternal()这些函数，不将包含敏感信息的字段写到序列化字节流中。\n\nD、在在序列化与反序列化涉及的writeObject()和readObject()方法中使用安全管理器', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 4, 1);
INSERT INTO `question` VALUES (109, '以下说法正确的是', 'A、文件路径校验前必须先进行标准化处理，建议使用getAbsolutePath()\n\nB、未对程序输入做有效的校验与限制可能会导致zip炸弹攻击、SQL注入、OS命令注入、XML注入以及目录遍历等攻击\n\nC、数值运算，建议使用先决条件检查、Math.*Exact()方法、向上类型转换等方式防止溢出\n\nD、建议通过System.exit()函数来终止运行的程序和线程', 'BC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 3, 4, 1);
INSERT INTO `question` VALUES (110, '在执行JDBC查询数据库时，假设物理内存足够用，如果查询结果集ResultSet要返回的记录数很多，比如上百万记录，则下列选项中对ResultSet的fetchsize属性描述正确的是', 'A、ResultSet的fetchSize越大，数据库服务端消耗的内存越小，性能也越快\n\nB、ResultSet的fetchSize越大，数据库服务端消耗的内存越大，性能也越快\n\nC、ResultSet的fetchSize越大，JDBC client端消耗的内存越大，性能也越快\n\nD、ResultSet的fetchSize越大，JDBC client端消耗的内存越小，性能也越快', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (111, '下面哪个不是Class类中定义的反射方法', 'A、getDeclaredFields\n\nB、getDeclaredNames\n\nC、getDeclaredMethods\n\nD、getDeclaredConstructors', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (112, '1、下面那些可以编译成功', 'A、float f = 10f\n\nB、char c = 10.0\n\nC、byte b = 10b\n\nD、double d = 10\n\nE、float f = 10.0\n\nF、double d = 10.0', 'ADF', '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', NULL, NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 0, 2, 0);
INSERT INTO `question` VALUES (113, '关于集合，以下说法正确的是', 'A、HashMap使用的是数组+链表（或红黑树）的方式，查找key时，先判断key的equals是否相等，相等时再判断 hashCode是否一致\n\nB、HashMap和HashSet的默认值大小为16，HashTable的默认值大小为11\n\nC、LinkedHashMap保持插入的顺序，TreeMap保持key的自然顺序\n\nD、Collection的直接子类包含Set、List、Map和Queue', 'BC', 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 5, 5, 0);
INSERT INTO `question` VALUES (114, 'switch支持的类型', 'A、byte \nB、long \nC、char  \nD、String', 'ACD', '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 1);
INSERT INTO `question` VALUES (115, '以下关于异常说法正确的是', 'A、Throwable是所有Error或Exception的超累\n\nB、只有是Exception或Exception子类，才能被catch\n\nC、Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError\n\nD、编译器会强制要求使用者捕获RuntimeException或申明抛出', 'ACD', 'B 纯属狗屁了，你把Throwable不放在眼里', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 3, 4, 0);
INSERT INTO `question` VALUES (116, '有关多线程中异常处理的说法正确的是', 'A、Java多线程程序中，线程不允许抛出未捕获的Checked Exception\n\nB、Java多线程程序中，线程允许抛出未捕获的Checked Exception\n\nC、Java多线程程序中，建议使用Thread对象的setUncaughtExceptionHandler方法注册Runtime异常的处理者\n\nD、Java多线程中，主线程可通过try catch捕获子线程异常', 'AC', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 4, 0);
INSERT INTO `question` VALUES (117, 'Java反射机制的作用包括', 'A、在运行时判断任意一个对象所属的类。\n\nB、在运行时构造任意一个类的对象。\n\nC、在运行时判断任意一个类所具有的成员变量和方法。\n\nD、在运行时调用任意一个对象的方法。', 'ABCD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (118, 'SocketChannel可以向Selector注册哪些事件', 'A、SelectionKey.OP_ACCEPT\n\nB、SelectionKey.OP_CONNECT\n\nC、SelectionKey.OP_WRITE\n\nD、SelectionKey.OP_READ', 'ABCD', '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (119, '如下类型，哪些是值不可变类型', 'A、char\n\nB、Integer\n\nC、String\n\nD、short', 'BC', '貌似包装类都是final class可能看看源码加深记忆', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (120, '在64位虚拟机，如下数据类型中，长度不是4字节的类型有哪些', 'A、char\n\nB、int\n\nC、long\n\nD、short', 'ACD', 'https://blog.csdn.net/u012611878/article/details/52455576', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 3, 0);
INSERT INTO `question` VALUES (121, '以下代码执行两遍，文件text.txt中的内容为\n\nFileOutputStream outputStream = new FileOutputStream(\"test.txt\",true);\noutputStream.write(\"ABCDE\".getBytes(StandardCharsets.UTF_8));\noutputStream.close();', 'A、ABCDE\n\nB、ABCDEABCDE\n\nC、什么都没有\n\nD、EDCBAEDCBA', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 3, 0);
INSERT INTO `question` VALUES (122, '以下代码输出什么\n\nList arrayList = new ArrayList();\narrayList.add(\"aaaa\");\narrayList.add(100);\nSystem.out.println((String)arrayList.get(1));', 'A、100 \nB、编译错误 \nC、运行异常 \nD、aaaa', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 3, 0);
INSERT INTO `question` VALUES (123, '以下代码输出什么\nString str = \"abc@x.y+com\";\nString str1 = \"ab_c@x.y.com\";\nString regex = \"^[a-zA-Z0-9.-_]+@([a-zA-Z0-9]+.)+com$\";\nSystem.out.println(str.matches(regex));\nSystem.out.println(str1.matches(regex));', 'A、true true  \nB、true false \nC、false true \nD、false false', 'A', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 5, 0);
INSERT INTO `question` VALUES (124, '不属于NIO Buffer中的属性变量', 'A、capacity \nB、flag \nC、position \nD、limit', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (125, '关于IO/NIO说法不正确的是', 'A、IO是面向流的，NIO是面向缓存的\n\nB、IO是阻塞IO，NIO支持非阻塞IO\n\nC、IO值能顺序读取数据，NIO可以通过缓存区前后移动获取数据\n\nD、IO允许一个线程监听多个输入通道', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (126, '不属于NIO组件的是', 'A、Buffer \nB、Channel\nC、Selectors \nD、Reader', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (127, '下面说法正确的', 'A、volatile保证操作的修改可见性和原子性\n\nB、volatile和synchronized则可以使用在变量、方法、和类级别的\n\nC、synchronized和ReentrantLock都是可重入锁\n\nD、synchronized适合一写多读场景', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (128, '以下代码输出什么\n\nComparator<Integer> df = new Comparator<Integer>() {\n    @Override\n    public int compare(Integer o1, Integer o2) {\n        return o1 > o2 ? 1 : (o1 == o2) ? 0 : -1;\n    }\n};\nSystem.out.println(df.compare(new Integer(1),new Integer(1)));', 'A、0 \nB、1 \nC、-1 \nD、运行时异常', 'C', 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 2, 3, 0);
INSERT INTO `question` VALUES (129, '不属于启动安全管理器的是？', 'A、启动程序的时候通过附加参数启动安全管理器：-Djava.security.manager\n\nB、若要同时指定配置文件 -Djava.security.manager -Djava.security.policy=\"E:/java.policy\"\n\nC、编码方式启动 System.setSecurityManager(new SecurityManager());\n\nD、编码方式启动 System.setProperty(“java.security.manager”, xxx);', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 4, 2);
INSERT INTO `question` VALUES (130, '正确的执行System.exit()的方式', 'A、OOM时，主动执行System.exit()\n\nB、进程发生不可预知的异常时，主动执行System.exit()\n\nC、命令行执行System.exit()\n\nD、服务出现不可恢复的异常时，主动执行System.exit()', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 3, 0);
INSERT INTO `question` VALUES (131, '以下说法正确的是', 'A、调用Thread.interrupt() 用于请求另外一个线程中止执行，而不是直接中止\n\nB、推荐使用Thread.current().isInterrupted()，而不是Thread.interrupted()检查自己是否被interrupt\n\nC、检测到当前线程被interrupt后，应抛出InterruptedException，并在finally或try-with-resource中清理执行状态\n\nD、调用线程的interrupt方法，只有当线程走到了sleep, wait, join等阻塞这些方法的时候，才会抛出InterruptedException。', 'ACD', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 1, 0);
INSERT INTO `question` VALUES (132, '下面哪些是线程安全的（）', 'A、LinkedList\nB、Vector\nC、Hashtable\nD、TreeMap\nE、TreeSet\nF、ConcurrentHashMap\nG、Stack', 'BCFG', 'Stack<E> extend Vector<E> 故线程安全', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 3, 0);
INSERT INTO `question` VALUES (133, '属于java并发库的线程同步类', 'A、Exchanger \nB、Semaphore \nC、CountDownLatch  \nD、CyclicBarrier  \nE、Phaser', 'ABCDE', '', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 3, 0);
INSERT INTO `question` VALUES (134, '针对DT FUZZ测试，下面的说法正确的是？', 'A. DT FUZZ测试中，如果被测函数代码有修改，但被测函数被调用逻辑没有修改，不需要修改测试用例\n\n \n\nB. 尽量选择模块外层函数为被测目标，编写测试用例，测试过程中，本模块内部函数可以随意打桩\n\n \n\nC. DT FUZZ测试，编写测试用例可以不考虑函数的调用上下文\n\n \n\nD. 结构化的参数DT FUZZ工具都可以构造', 'A', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 3, 4, 3);
INSERT INTO `question` VALUES (135, '当线程调用start后，其所处的状态是 ', 'A. 新建\n\n \n\nB. 阻塞\n\n \n\nC. 运行\n\n \n\nD. 就绪\n', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (136, '下面对Java反序列化的描述正确的是：', 'A. jdk提供的序列化操作，会将Java对象序列化二进制流，可以有效防止信息泄露或恶意篡改\n\n \n\nB. Java的反序列化操作，可以绕过对象构造函数的执行\n\n \n\nC. 对象序列化后，即使包含敏感数据也不会产生风险\n\n \n\nD. Java反序列化时，目标class与预期class不一致时，会导致类型转换错误，所以即使反序列化不可信数据也不会有安全风险', 'B', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (137, '下列哪项危害不是，不正确的构造正则可能会导致的安全风险', 'A. CSRF\n\n \n\nB. 敏感信息泄露\n\n \n\nC. ReDos攻击\n\n \n\nD. 正则注入', 'A', 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (138, '下面对敏感数据记录日志，描述正确的是', 'A. 做好日志访问权限控制，日志可以记录敏感信息\n\n \n\nB. 敏感信息记录日志时，直接将信息内容替换等长的*即可\n\n \n\nC. 日志中如果必须记录敏感信息，需要使用长度固定的*替代\n\n \n\nD. 敏感信息加密后可以记录日志', 'C', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (139, '常见的xml实体解析导致的安全风险有那几种？', 'A. xPath注入\n\n \n\nB. XXE\n\n \n\nC. 内部实体扩展\n\n \n\nD. xml注入', 'BC', '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 3, 0);
INSERT INTO `question` VALUES (140, '下面对命令注入的防护措施中，无效的是', 'A. 避免使用shell方式执行命令，直接启动具体的进程\n\n \n\nB. 代码避免使用外部输入拼接命令行，代码中对命令进行硬编码\n\n \n\nC. 对于使用外部输入构造的命令行，在执行前进行转码处理\n\n \n\nD. 外部输入进行白名单校验，禁止使用&|>;等特殊字符', 'C', '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 1, 4, 1);
INSERT INTO `question` VALUES (141, '下列生成随机数最安全的方法为', 'A. java.util.Random()\n\n \n\nB. Math.random()\n\n \n\nC. java.util.concurrent.ThreadLocalRandom()\n\n \n\nD. java.Security.SecureRandom()', 'D', '', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (142, '对于不安全反序列化漏洞的防护描述错误的是：', 'A. XMLDecoder是jdk原生类，提供了xml的反序列化操作，所以相对Xstream，更推荐使用XMLDecoder进行xml数据的反序列化操作\n\n \n\nB. 使用jdk原生api进行反序列化操作，涉及不可信数据时，可以重载ObjectInputStream的resolveClass()方法，在该方法中对目标class进行白名单校验\n\n \n\nC. 对不可信的XML数据进行反序列化操作，推荐使用XStream实现，该组件支持白名单检查，新版本也提供了默认安全校验机制\n\n \n\nD. 对不可信的json数据进行反序列化操作，可通过禁止开启type功能进行防护\n\n ', 'A', 'java原生的XMLDecoder类常被用来序列化反序列化XML格式数据，但是这个类也存在严重安全问题，这里解析任意xml文件可以导致反序列化命令执行，oracle官方未提供任何针对此问题的安全措施，所以在反序列化不可信xml数据时，强烈建议不要使用此类。', NULL, NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (143, '以下哪些程序示例是正确的？\n①public class OuterSer implements Serializable {\n    private int rank;\n    class InnerSer implements Serializable {\n        protected String name;\n        // ...\n    }\n}\n\n②public class OuterSer implements Serializable {\n    private int rank;\n    class InnerSer {\n        protected String name;\n        // ...\n    }\n}\n\n③public class OuterSer implements Serializable {\n    private int rank;\n    static class InnerSer implements Serializable {\n        protected String name;\n        // ...\n    }\n}', 'A. ③\n\nB. ②\n\nC. ①\n', 'AB', '规则7.5 禁止序列化非静态的内部类', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 3, 4, 1);
INSERT INTO `question` VALUES (144, '下列哪些方法的返回Buffer对象暴露给不受信任的代码，存在原始数据被恶意修改的风险', 'A. CharBuffer.asReadOnlyBuffer();\n\n \n\nB. CharBuffer.duplicate();\n\n \n\nC. CharBuffer.subSequence();\n\n \n\nD. CharBuffer.wrap();', 'BCD', 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 2, 0);
INSERT INTO `question` VALUES (145, '下面对线程同步描述错误的是', 'A. Java中一般会使用同步方法或同步代码块实现线程同步操作\nB. 对于单例模式的java类，即使该类对象可暴露给不可信代码，使用同步方法可以正确进行线程同步\nC. 使用private final的锁对象更安全\nD. 同步方法与基于this引用的同步代码块使用的是相同的锁', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (146, '在一般情形下，仅仅忽略对回车换行的过滤(\\x0d, \\x0a)有可能会导致如下哪种安全问题：', 'A. 反序列化漏洞\nB. 日志注入\nC. json注入共计\nD. 缓冲区溢出', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (147, '下面的代码实现中，对xml内部实体扩展没有防护作用的是：\n①DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\nDocumentBuilder db = dbf.newDocumentBuilder();\ndb.parse(inStream);\n②DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setFeature(\"http://oracle.com/xml/jaxp/properties/entityExpansionLimit\", \"200\");\nDocumentBuilder db = dbf.newDocumentBuilder();\ndb.parse(inStream);\n③System.setProperties(\"entityExpansionLimit\", \"200\");\nDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\nDocumentBuilder db = dbf.newDocumentBuilder();\ndb.parse(inStream);\n④SAXParserFactory factory = SAXParserFactory.newInstance();\nfactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\nfactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(inStream, defaultHandler);', 'A. ③\nB. ④\nC. ①\nD. ②', 'B', '解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (148, '下面对java中创建的具有输出流或错误流的进程的处理，正确的是？', 'A.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nerrorGobbler.start();\nint exitVal = proc.waitFor();\nB.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nStreamGobbler outputGobbler = new StreamGobbler(proc.getInputStream(), System.out);\nerrorGobbler.start();\noutputGobbler.start();\nint exitVal = proc.waitFor();\nC.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nint exitVal = proc.exitValue();\nD.\nRuntime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nint exitVal = proc.waitFor();', 'B', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 4, 2);
INSERT INTO `question` VALUES (149, '就以下程序说法正确的是：\npublic class Sys extends Thread {\nboolean stop = false;\npublic static void main(String[] args) throws interruptedException {\nSys thread = new Sys();\nthread.start();\nThread.sleep(3000)\nthread.interrupt();\nThread.sleep(3000)\nSystem.out.println(\"Stopping application...\");\n}\npublic void run() {\nwhile(!stop) {\nSystem.out.println(\"Thread is running...\");\n}\nSystem.out.println(\"Thread exiting under request...\");\n}\n}', 'A. 调用interrupt()后线程停止\nB. interrupt()可以实现在线程受到阻塞时抛出一个中断信号\nC. 中断线程推荐使用stop()函数\nD. 线程会一直运行', 'D', '解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 7, 0);
INSERT INTO `question` VALUES (150, '下列对sql注入防护措施中的转码描述正确的是', 'A. 转码是优选的sql注入防护措施\nB. 转码仅对拼接sql语句中，单引号或双引号限制的字段生效\nC. 在拼接sql语句前进行转码，可以彻底解决sql注入问题\nD. 转码对表名、字段等不适用于参数化查询的场景是优选的方案', 'B', '解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 3, 0);
INSERT INTO `question` VALUES (151, '下面代码中存在XML实体注入的是：', 'A. SAXParserFactory factory = SAXParserFactory.newInstance();\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(inStream, defaultHandler);\nB. public static String DDD = \"http://apache.org/xml/features/disallow-doctype-decl\";\npublic static String EGE = \"http://xml.org/sax/features/external-general-entities\";\npublic static String EPE = \"http://xml.org/sax/features/external-parameter-entities\";\npublic static String LED = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\nSAXReader reader = new SAXReader();\nreader.setFeature(LED, false);\nreader.setFeature(EGE, false);\nreader.setFeature(EPE, false);\nC. XMLReader reader = saxParser.getXMLReader();\nreader.serEntityResolve(new CustomerResolver());\nreader.setErrorHandler(defaultHandler);\nD. DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false)', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 1);
INSERT INTO `question` VALUES (152, '下面加密算法中，哪类属于不安全的加密算法', 'A. AES-GCM\nB. AES-ECB\nC. DES\nD. MD5', 'BCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 4, 1, 0);
INSERT INTO `question` VALUES (153, '下列操作中可导致任意代码执行的操作有哪些？', 'A. 使用不安全的XSLT转换XML文件\nB. 对不可信数据进行反序列化操作\nC. 使用不可信数据拼接sql语句\nD. 使用不可信数据拼接命令行', 'ABD', '解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 4, 3, 0);
INSERT INTO `question` VALUES (154, '以下哪种攻击方式是针对XML数据应用', 'A. 外部实体注入(XXE)\nB. 内部实体扩展\nC. LDAP注入\nD. XPath注入', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 2, 4, 3);
INSERT INTO `question` VALUES (155, '在Java环境中，允许处于不同受信域的组件进行数据通信，从而出现跨受信边界的数据传输。以下哪种方式可以在一定程度上解决反序列化中的信息泄漏问题：', 'A. 将属性声明为final\nB. 将敏感数据声明为transient\nC. 将属性声明为private\nD. 特殊情况下正确加密了的数据可以被序列化', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 4, 0);
INSERT INTO `question` VALUES (156, '下列描述中，可能会产生死锁的是', 'A. 同步方法或使用对象内置锁的同步代码块中，直接抛出异常\nB. 异常条件下没有正确释放锁\nC. 两个或多个线程以不同的顺序请求和释放锁\nD. 在产生阻塞的操作中持有锁', 'BCD', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (157, '请阅读下面的代码，分析代码中存在哪些安全风险：\nString password;\npassword = \"\";\nProperties properties = new Properties();\nFileInputSteam streamFileInput = null;\ntry {\nstreamFileInput = new FileInputSteam(\"../common/config.properties\");\nproperties.load(streamFileInput);\npassword = properties.getProperty(\"passport\");\nstreamFileInput.close();\n} catch (IOException exceptIO) {\nIO.logger.log(Level.WARNING, \"Error with stream reading\");\n}\nConnection dBConnection = null;\ntry {\ndBConnection = DriverManager.getConnection(\"192.168.105.23\", \"sa\", password);\n} catch (SQLException exceptSql) {\nIO.logger.log(Level.WARNING, \"Error with database connection\");\n}', 'A. 资源未正确释放\nB. 敏感异常导致信息泄漏\nC. sql注入\nD. 配置文件中明文保存密码', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 4, 0);
INSERT INTO `question` VALUES (158, '栈帧存储了哪些信息？', 'A. 方法的局部变量表\nB. 操作数栈\nC. 动态连接\nD. 方法返回地址', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 7, 3, 0);
INSERT INTO `question` VALUES (159, 'gc主要回收的内存区域是哪块', 'A. 堆区\nB. 方法区', 'AB', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (160, '以下类型精度最高的是？', 'A. int\nB. long\nC. BigInteger\nD. byte', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 4, 0);
INSERT INTO `question` VALUES (161, '下面语句运行结果为\nswitch (5) {\ndefault:\nSystem.out.println(5);\ncase 0:\nSystem.out.println(0);\ncase 1:\nSystem.out.println(1);\nbreak;\ncase 2:\nSystem.out.println(2);\nbreak;\n}', 'A. 501\nB. 1\nC. 0\nD. 5', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (162, '正则表达式，[^a-zA-Z0-9_]等价于', 'A. \\W   \r\nB. \\w   \r\nC. \\t   \r\nD. \\v', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (163, '如下操作属于中间结果的是', 'A. reduce()\nB. map()\nC. forEach()\nD. stream()', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (164, '以下代码执行结果为\nint count = 0;\nfor (int i = 0; i < 100; i++) {\ncount=count++;\n}\nSystem.out.println(count);', 'A. 0\nB. 100\nC. 1\nD. 99', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (165, '关于RandomAccessfile的说法错误的是？', 'A. 内部基于指针形式可以随机读写文件\nB. 可以通过RandomAccessFile的FileChannel间进行mmap操作\nC. RandomAccessFile继承InputStream和OutputStream\nD. RandomAccessFile只能对文件进行操作\nE. 支持r,rw,rws,rwd四种模式', 'C', '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (166, '如下代码执行三次的结果\nFileOutputStream outputStream = new FileOutputStream(\"test.txt\", true);\noutputStream.write(\"ABCDE\".getBytes(StandardCharsets.UTF_8));\noutputStream.close();', 'A. ABCDE\nB. ABCDEABCDEACBDE\nC. 编译报错\nD. ABCDE\nABCDE\nABCDE', 'B', '解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 4, 0);
INSERT INTO `question` VALUES (167, '为从文本文件中进行读取内容，应该使用哪个处理流文件', 'A. BufferedReader\nB. BufferedWriter\nC. BufferedInputStream\nD. BufferedOutputStream', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 4, 1);
INSERT INTO `question` VALUES (168, '下面说法正确的是', 'A. FileChannel从文件读取数据，或将数据写入文件，无法设置为非阻塞模式\nB. DatagramChannel使用TCP协议通过网络来读写数据\nC. SocketChannel使用UDP协议通过网络来读写数据\nD. ServerSocketChannel可以监听新进来的TCP连接', 'AD', '解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (169, '安全编程规范中，下面说法正确的有', 'A. 创建文件时指定合理的访问权限\nB. 对所有外部输入进行校验\nC. 记录日志时可以抛异常\nD. 禁止不受信任的代码直接终止JVM', 'ABD', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 3, 0);
INSERT INTO `question` VALUES (170, '以下说法正确的是', 'A. 临时文件由于会定期被清理掉，所以不用显示的清理临时文件\nB. java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改\nC. 运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空\nD. Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值', 'C', '解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (171, '关于Java NIO网络编程说法错误的是？', 'A. NIO中的ServerSocketChannel可以同时监听TCP链接，每一个新来的链接都会创建一个SocketChannel\nB. Java NIO中的一个选择器只能注册一个通道\nC. NIO各种流是非阻塞的，如果没有数据可用也不会阻塞线程\nD. Java普通IO是面向流的，NIO是面向缓冲区的', 'B', '解析：\n一个选择器最多可以同时被63个通道一起注册使用。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (172, '关于Linux的IO模型，说法错误的是', 'A. Linux的IO模型分为五种，阻塞IO，非阻塞IO，多路复用IO，信号驱动，异步IO\nB. 大部分高性能的IO中间件，如nignx，都是使用多路复用IO\nC. 多路复用IO没有一个线程需要被阻塞\nD. 多路复用IO依赖操作系统的能力，具体而言就是select/poll/epoll', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (173, 'Socket哪些操作可能会进入阻塞状态', 'A. server socket的accpet()监听客户端连接\nB. 执行socket的输出流写数据\nC. 执行socket的输入流读取数据\nD. Socket的getOutputStream()，getInputStream()', 'ABC', '解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (174, '如果一个对象存入Hash集合后hashcode随即发生变化，会导致什么结果？', 'A. 内存泄漏\nB. 无任何问题\nC. 内存溢出\nD. 抛出异常', 'A', '解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (175, '下列运算不会溢出的是', 'A. Math.abs\nB. num++\nC. num%num1\nD. num/num1', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (176, '下面哪些可以编译成功？', 'A. float f = 10f;\nB. char c = 10.0;\nC. byte b = 10b;\nD. double d = 10;\nE. float f = 10.0;\nF. double d = 10.0;', 'ADF', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (177, '下面哪个是对的？', 'A. float f1 = 3.123\nB. char c1 = 1;\nC. int x = 1.0', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (178, '求平方根方法public static double sqrt(double a) 可以传递的参数类型有哪些？', 'A. byte\nB. float\nC. String\nD. long', 'ABD', 'short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 4, 4, 1);
INSERT INTO `question` VALUES (179, '下列说法错误的是', 'A. ConcurrentHashMap不允许有null的key、value\nB. TreeMap可以有null的key、value\nC. ConcurrentHashMap是线程安全的\nD. HashMap线程不安全，但效率高', 'B', '解析：\nTreeMap键可以为\'null\'，值不允许', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (180, '下面描述正确的是', 'A. 多线程环境下使用CourrentHashMap和Collections. synchronizedMap实现同步效率差别不大\nB. Collections. synchronizedMap不是线程安全的\nC. 多线程环境下使用HashTable和Collections. synchronizedMap实现同步效率差别不大\nD. ConcurrentHashMap的锁粒度较大', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (181, '以下对Java集合说法正确的是', 'A. 往一个ArrayList或者Vector里插入一个元素时，如果内部数组空间不够，ArrayList或Vector会扩展它的大小。Vector在默认情况下增长一倍的大小，而ArrayList增加50%的大小\nB. ArrayList、Vector、HashMap、StringBuilder和StringBuffer都是线程不安全的\nC. Vector类实现了一个动态数组，默认不传参数时，构造容量为16的大小，也可以传参指定容量大小；ArrayList就是动态的数组，默认不传参数时，构造容量为10的大小，也可以传参指定容量大小\nD. ConcurrentHashMap、HashMap、HashSet都不支持key为null，且遍历使用的都是Iterator迭代器，其中只有HashTable是线程安全的', 'A', '解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (182, '针对Map选型，描述正确的是：', 'A. HashMap键、值均可以为null值\nB. HashMap中的数据是无序的\nC. TreeMap中的键是自动排序的，不允许为null值\nD. LinkedHashMap插入元素是有序的', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 2, 1);
INSERT INTO `question` VALUES (183, 'PreparedStatement.setInt(int parameterIndex, int x)参数的含义', 'A. 把第parameterIndex-1的参数值设置为x\nB. 把第parameterIndex的参数值设置为x\nC. 把第x-1的参数值设置为parameterIndex\nD. 把第x的参数值设置为parameterIndex', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (184, '有关数据库drop delete truncate的区别，说法正确的是', 'A. 保留表而删除所有数据的时候建议使用truncate\nB. 删除部分数据行时，可以使用delete，并且带上where子句\nC. drop delete truncate只删除表的数据，不会删除表的结构\nD. truncate drop是dll，操作立即生效，原始数据不放到rollback segment中，不能回滚', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (185, '关于DataSource的说法错误的是', 'A. DataSource是用于获取数据库链接的接口\nB. DataSource对象的属性不可以修改\nC. DataSource主要有三种类型实现：基本实现、连接池实现、分布式事务实现\nD. 通过DataSource对象访问的驱动程序本身不会向DriverManager注册', 'B', '解析：\nDataSource对象的属性在必要时可以修改。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 4, 1);
INSERT INTO `question` VALUES (186, '属于不可信数据列表的有：', 'A. 命令行\nB. 用户输入\nC. 环境变量\nD. 网络数据', 'ABCD', '解析：\n不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (187, '根据华为Java编程规范，这段代码违反了哪个条目？\npublic static List<String> decorate(String[] personDescs) {\nif (personDescs == null || personDescs.length == 0) {\nreturn null;\n}\nList<String> personNames = new ArrayList<>(personDescs.length);\nfor (String personDesc : personDescs) {\nString personName = getPersonName(personDesc);\nif (personName != null && personName.length() != 0) {\npersonNames.add(personName);\n}\n}\nreturn personNames;\n}\npublic static void main (String[] args) {\n// Do something here.\nList<String> personNames = decorate(personDescs);\nif (personNames == null) {\nreturn;\n}\nfor (String personName : personNames) {\n// Do something here.\n}\n}', 'A. 使用类名调用静态方法，而不要使用实例或表达式来调用\nB. 方法的代码块不要嵌套过深，不能超过4层\nC. 当返回类型为数组或者容器时，应返回长度为0的数组或者容器\nD. personName变量需要判断是否为null', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 6, 1);
INSERT INTO `question` VALUES (188, '根据华为Java编程规范，下列选项中变量声明错误的有哪些？', 'A. int a,b;\nB. int replacementLen = replacement.length();\nString string = sequence.toString();\nint pos = indexIn(string);\nif (replacementLen == 0) {\nreturn removeFrom(sequence);\n}\nif (replacementLen == 1) {\nreturn replaceFrom(sequence, replacement.charAt(0));\n}\nif (pos == -1) {\nreturn string;\n}\nC. String args[];\nD. public boolean matchs (char c) {\nswitch (c) {\ncase \'\\t\':\ncase \'\\n\':\ncase \'\\u205f\':\ncase \'\\u3000\':\nreturn true;\ncase \'\\u2007\':\nreturn false;\ndefault:\nreturn false;\n}\n}', 'ABCD', '解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 4, 0);
INSERT INTO `question` VALUES (189, '在使用java中的套接字（socket）时，下列代码实现中，哪些选项可能会导致主线程长时间阻塞？', 'A.\nSocket s = new Socket(\"10.116.123.112\", 6526);\nInputStream stream = s.getInputStream();\n// use thread read data\nB.\nSocket s = new Socket(\"10.116.123.112\", 6526);\ns.setSoTimeout(2000)\nInputStream stream = s.getInputStream();\n// use thread read data\nC.\nSocket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526), 1000);\nInputStream stream = s.getInputStream();\n// use thread read data\nD.\nSocket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526));\nInputStream stream = s.getInputStream();\n// use thread read data', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 2, 4, 0);
INSERT INTO `question` VALUES (190, '若一个实现了Serializable的类的构造器方法、内部状态获取与修改方法中都涉及安全管理器检查，那么这些安全管理器检查操作也需要应用到这个类的下列哪些方法中', 'A. equals()\nB. writeObject()\nC. readObject()\nD. hashCode()', 'BC', '解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (191, 'java的安全管理器SecurityManager的policy文件配置如下：\ngrant {\n......\npermission java.util.PropertyPermission \"java.version\", \"read\";\n......\n};\npublic static void main(String... args) {\nSystem.setSecurityManager(new SecurityManager());\nSystem.setProperty(\"java.version\", \"1.7.0_45\");\nString javaNewVersion = System.getProperty(\"java.version\");\nSystem.err.println(javaNewVersion)\n}\n注：sdk的版本是1.8.0_45\n程序输出的结果为：', 'A. 1.8.0_45\nB. 不确定\nC. java.security.AccessControlException.access denied\nD. 1.7.0_45', 'C', '解析：\npolicy文件里面java.version的权限是read，程序去write权限不足', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (192, '关于序列化说法不正确的是', 'A. 序列化只能保存对象的非静态成员交量，不能保存任何的成员方法和静态的成员变量\nB. transient关键字的作用是：阻止实例中那些用此关键字声明的变量持久化\nC. 当一个父类实现序列化，子类若要实现序列化，需要显式实现Serializable接口\nD. 一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口', 'C', '解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (193, '关于JAVA序列化与反序列化错误的是', 'A. 对象的序列化结果是可以在网络中进行传输的字节序列\nB. 反序列化的输入数据可以由外部输入指定\nC. transient关键字可以阻止变量被序列化到文件中\nD. 不要序列化未经加密的敏感数据', 'B', '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 1);
INSERT INTO `question` VALUES (194, '关于try-with-resources说法正确的是：', 'A. 不能加finally\nB. 按照创建的资源顺序关闭\nC. try中创建的变量在catch和finally可见\nD. 资源关闭在catch和finally中语句执行之前', 'D', '解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (195, '需要关闭资源，下面哪个写法更好？', 'A.\nInputStream in = ...;\nException ex = null;\ntry {\ntry {\n//code that might throw exceptions\n} catch (Exception e) {\nex = e;\nthrow e;\n}\n} finally {\ntry {\nin.close();\n} catch (Exception e) {\nif (ex == null) throw e;\n}\n}\nB.\ntry (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}\nC.\nInputStream in = ...\ntry {\n//code that might throw exceptions\n} finally {\nin.close();\n}', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (196, '推荐使用的数字签名算法有', 'A. DSA\nB. ECDSA\nC. RSA\nD. RC4', 'AB', '解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 5, 4, 2);
INSERT INTO `question` VALUES (197, '下面对zip文件的安全解压缩描述，错误的是', 'A. zip文件解压时，可以使用entry.getSize()对解压缩文件进行文件大小判断\nB. zip文件解压缩时，需判断文件名称中是否存在../这样的返回上层路径的情况\nC. zip文件解压时，需对解压缩的文件数量进行限制检查\nD. zip文件解压时，需通过边阅读文件内容边统计文件实际大小，对文件大小进行限制检查', 'A', '解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (198, '下面异常声明不推荐的是', 'A. public Image loadImage(String path) throws FileNotFoundException, EOFException\nB. public Image loadImage(String path) throws IOException\nC. public void drawImage(int num) throws ArrayIndexOutOfBoundsException', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 4, 1);
INSERT INTO `question` VALUES (199, '如下代码片段中，假设SomeObject是一个暴露给非信任代码交互的类，则[1]处可以加入下面哪项代码：\npublic class SomeObject {\n[1]\npublic void changeValue() {\nsynchronized (lock) {\n// Locks on the private Object\n// ...\n}\n}\n}', 'A. private final Object lock = SomeObject.class;\n\n \n\nB. private final Object lock = new Object();\n\n \n\nC. public final Object lock = new Object();\n\n \n\nD. transient final Object lock = new Object();', 'B', '解析：\nA. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。\n\nC. 非信任域内，锁不能用public\n\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (200, '下列代码示例中，加锁范围可能为全局而非当前类示例内的有哪些？', 'A.\nprivate final String lock = new String(\"LOCK\").intern();\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}\nB.\nprivate final String lock = \"lock\"\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}\nC.\nprivate final String lock = new String(\"LOCK\");\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}\nD.\nprivate final Boolean = Boolean.TRUE;\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}', 'ABD', '解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 4, 0);
INSERT INTO `question` VALUES (201, '关于volatile关键字说法正确的是', 'A. volatile修饰的变量会优先读写线程工作内存\nB. 使用volatile可以解决原子性问题\nC. 使用volatile修改的变量，可以直接读取，不会有并发问题\nD. volatile可以解决数据可见性问题，即对volatile变量的变更，可以直接写入主内存', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (202, 'atomic包下提供的能原子更新数组中元素的类不包括', 'A. AtomicReferenceArray\nB. AtomicIntegerArray\nC. AtomicReference\nD. AtomicLongArray', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (203, '使用javac编译时，包含以下哪几个过程？', 'A. 语义分析及生成字节码\nB. 词法分析及填充符号表\nC. Server Compiler\nD. 注解处理\nE. Client Compiler', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 4, 3, 1);
INSERT INTO `question` VALUES (204, '关于Java中的ClassLoader下面的哪些描述是错误的：', 'A. 默认情况下，Java应用启动过程涉及三个ClassLoader：Boostrap, Extension, System\nB. 一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的\nC. 类装载器需要保证类装载过程的线程安全\nD. ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null\nE. ClassLoader的父子结构中，默认装载采用了父优先\nF. 所有ClassLoader装载的类都来自CLASSPATH环境指定的路径', 'BDF', '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 4, 6, 2);
INSERT INTO `question` VALUES (205, '关于类的卸载机制，表述正确的是', 'A. 一个类被首次加载后，会长期驻留JVM，直到JVM退出\nB. 由用户自定义的类加载器加载的类是可以被卸载的\nC. 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载\nD. 所有的java类都有一个静态属性class，它代表这个类的class对象', 'BCD', '解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 3, 0);
INSERT INTO `question` VALUES (206, '在JAVA中关于抽象类的描述正确的是', 'A. 抽象类必须包含一个抽象方法\nB. 抽象类的方法必须是抽象的\nC. 声明抽象类必须带有abstract\nD. 抽象类可以被实例化', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 4, 5, 0);
INSERT INTO `question` VALUES (207, '下面选项中的泛型代码片段哪些是正确的？', 'A.\nstatic class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<? super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}\nB.\nstatic class Fruit{}\nstatic class Apple extends Fruit{}\npublic static void main(String[] args) {\nList<? extends Fruit> list = new ArrayList<>();\nlist.add(new Apple());\n}\nC.\npublic class ShowTest<T> {\npublic static void show(T t) {\nSystem.out.println(t.toString());\n}\n}\nD.\nstatic class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}', 'AD', '解析：\n泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<? super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<? extends T>。\n- 2. 经常往里插入的，适合用<? super T>。\n<? extends T> = <subClass extends T> = T以及T的子类\n<? super T> = <superClass super T> = T以及T的父类', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (208, '以下代码输出什么\npublic class Point {\nprivate int x;\nprivate int y;\npublic Point(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\npublic void setLocation(int x, int y) {\nthis.x = x;\nthis.y = y;\n}\npublic static void main(String[] args) {\nPoint p1 = new Point(0, 0);\nPoint p2 = new Point(0, 0);\nmodifyPoint(p1, p2);\nSystem.out.println(\"[\" + p1.x + \",\" + p1.y + \"],[\" + p2.x + \",\" + p2.y + \"]\");\n}\nprivate static void modifyPoint(Point p1, Point p2) {\nPoint tmpPoint = p1;\np1 = p2;\np2 = tmpPoint;\np1.setLocation(5, 5);\np2 = new Point(5, 5);\n}\n}', 'A. [0,0],[0,0]\nB. [5,5],[0,0]\nC. [0,0],[5,5]\nD. [5,5],[5,5]', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (209, '以下代码输出？\nclass Parent {\nint a = 100;\npublic int f() {\nreturn 10;\n}\n}\nclass Son extends Parent {\nint a = 200;\npublic int f() {\nreturn 20;\n}\npublic static void main(String[] args) {\nParent parent = new Son();\nSystem.out.println(parent.f() + \" \" + parent.a);\n}\n}', 'A. 20 100\nB. 20 200\nC. 10 200\nD. 10 100', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (210, '以下说法正确的是：\nclass Base {\npublic Base(int i) {\nSystem.out.println(\"Base(int i)\");\n}\n}\nclass MyOver extends Base {\npublic MyOver(int i) {\n}\npublic static void main(String[] args) {\nMyOver m = new MyOver(10);\n}\n}', 'A. 输出Base()\nB. 输出Base(int i)\nC. 什么都不输出\nD. 编译错误', 'D', '解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (211, '生产环境不应该打印什么级别日志？', 'A. debug\nB. warn\nC. error\nD. trace', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (212, '需要对对象密封和数字签名来保证数据安全的场景有：', 'A. 序列化敏感数据\nB. 传输敏感数据\nC. 没有使用类似于SSL传输通道\nD. 敏感数据需要长久保存（比如在硬盘驱动器上）', 'ABCD', '解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (213, '敏感数据传输的正确处理：', 'A. 仅加密\nB. 仅签名\nC. 先加密后签名\nD. 先签名后加密', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 2);
INSERT INTO `question` VALUES (214, '有整数溢出风险的符号', 'A. ++\nB. %\nC. +=\nD. Java.lang.math.abs()', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 4, 1);
INSERT INTO `question` VALUES (215, '以下有关Thread异常处理说法正确的是\n\n', 'A．子线程自身不必捕获异常，而是由主线程捕获即可\nB．对于运行时异常可调用Thread.setUncaughtExceptionHandler()方法设置运行时异常处理器来进行处理\nC．默认情况下，运行时异常从线程抛出时，会在控制台输出堆栈记录\nD．子线程须自己捕获异常处理', 'BCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 3, 6, 1);
INSERT INTO `question` VALUES (216, '下面关于字符流和字节流说法正确的是', 'A. 字符向字节转换时，需要注意编码问题\nB. 字节流继承于InputStream OutputStream，字符流继承于InputSteamReader OutputStreamWriter\nC. 字符流使用了缓冲区(Buffer)，而字节流没有使用缓冲区\nD. 字符是字节通过不同编码的包装，相同的字节代表相同的字符', 'ABC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 7, 3, 0);
INSERT INTO `question` VALUES (217, '集合描述错误的是', 'A. ArrayList的默认长度值16\nB. HashMap的默认长度值16\nC. HashSet的默认长度值16\nD. StringBuﬀer的默认长度值16', 'A', '解析：ArrayList默认是10', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 2);
INSERT INTO `question` VALUES (218, '禁止将系统内部使用的锁对象暴露给不可信代码', 'A. private final Boolean lock1 = Boolean.FALSE;\nB. private final Integer lock2 = 0;\nC. private final String lock3 = \"lock\";\nD. private final Integer lock4 = new Integer(0);', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (219, '容易被利用Dos攻击的异常', 'A. Java.lang.OutOfMemoryError\nB. Java.lang.StackOverflowError\nC. JarException\nD. InSufficientResourceException', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 5, 1);
INSERT INTO `question` VALUES (220, 'Sytem.exit()调用方式符合安全编程规范的', 'A. JAVA进程出现OOM，主动调用System.exit()，结束进程\nB. 服务出现不能自愈的异常，直接调用System.exit()，终止进程\nC. 允许外部传入的命令中有System.exit()\nD. 命令行工具使用System.exit()\n', 'D', '例外场景：\n在命令行应用中调用System.exit()函数是允许的。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (221, '以下说法正确的是', 'A. 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符\nB. 编码时尽量依赖平台默认的字符编码方式\nC. String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换\nD. 使用java.nio.charset中的类编码解码字符集', 'AD', '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (222, '关于敏感异常，说法不正确的是', 'A. 如果在传递异常的时候未对其中的敏感信息进行过滤，常常会导致信息泄露\nB. 重点关注异常中的文本消息，异常本身的类型不会泄露敏感信息\nC. 对出于问题定位目的，可将敏感异常信息记录到日志中，但必须做好日志的访问控制，防止日志被任意访问，导致敏感信息泄露给非授权用户。\nD. 可以通过限制输入. 安全策略方式过滤掉异常中的敏感信息', 'B', '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (223, '以下代码输出结果是\nString srcTxt = \"123\\\\d\";\nString rst1 = srcTxt.replaceAll(\"\\\\d\", \"456\");\nString rst2 = srcTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\nString rst3 = srcTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(rst1);\nSystem.out.println(rst2);\nSystem.out.println(rst3);', 'A.\n456456456\\d\n123456\n456456456\\d\nB.\n456456456\\d\n123456\n123456\nC.\n123456\n123456\n123456\nD\n123456\n123456\n45623\\d', 'B', '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 2, 3, 0);
INSERT INTO `question` VALUES (224, '动态代理扩展类是在什么阶段执行的？', 'A. 初始化\nB. 准备\nC. 解析\nD. 加载', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 4, 2);
INSERT INTO `question` VALUES (225, '业务处理日志用', 'A. error\nB. debug\nC. warn\nD. info', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (226, 'JVM GC性能指标吞吐量是指', 'A. CPU运行时间内GC运行的次数\nB. CPU运行用户代码的时间与CPU总消耗时间的比值\nC. CPU运行时间内GC运行次数与所有运行线程次数的比值\nD. CPU运行GC线程的时间与用户代码的时间的比值', 'B', '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 5, 3, 4);
INSERT INTO `question` VALUES (227, '下面代码片段描述正确的是\npublic static int cardinality(Object obj, final Collection<?> col) {\nint count = 0;\nif (col == null) {\nreturn count;\n}\nIterator<?> it = col.iterator();\nwhile (it.hasNext()) {\nObject elt = it.next();\nif ((null == obj && null == elt) || obj.equals(elt)) {\ncount++;\n}\n}\nreturn count;\n}', 'A. 存在空指针异常风险\nB. 存在数组越界风险\nC. 代码编译报错\nD. 代码无异常风险', 'A', '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (228, '哪些语句在编译时不会出现编译警告', 'A. float f = 1.3;\nB. byte b = 257;\nC. boolean b = \"isStoped\";\nD. char i = 1;', 'D', '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (229, '定义本地方法正确的是', 'A. public void native XXX();\nB. public native void XXX();\nC. public native void XXX() {}\nD. public void static native XXX();', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (230, '方法过长意味着：', 'A. 方法需要抽象\nB. 功能不单一\nC. 过于复杂\nD. 不便于他人阅读和修改代码', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (231, '包装类可以用于下面那些：', 'A. 反射方法\nB. 泛型\nC. 集合中类型\nD. POJO RPC某些不需要设置默认值的类型', 'ABCD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (232, '下面是字节流的是：', 'A. writer\nB. inputstream\nC. outputstream\nD. reader', 'BC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (233, '非安全的口令加密算法有：', 'A. DES\nB. RSA\nC. SKIPJACK\nD. ECDSA', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 1);
INSERT INTO `question` VALUES (234, 'String sql = \"select * from product where id =\" + Integer.parseInt(request.getParameter(\"id\"))该代码存在什么样的安全问题?', 'A. XSS\nB. 无安全风险\nC. 无SQL注入风险，但是将String转化为int型变量时可能会有NumberFormatException抛出\nD. SQL注入', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (235, '下列代码存在什么安全风险：\npublic static int cardinality(Object obj, final Collection<?> col) {\nint count = 0;\nif (col == null) {\nreturn count;\n}\nIterator<?> it = col.iterator();\nwhile (it.hasNext()) {\nObject elt = it.next();\nif ((null == obj && null == elt) || obj.equals(elt)) {\ncount++;\n}\n}\nreturn count;\n}', 'A. 内存溢出\nB. 内存泄露\nC. 空指针引用\nD. 无安全风险', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (236, '下面哪种操作是编程规范推荐的写法?', 'A. System.out.print(\"Hello, world!\\n\");\nB. System.out.print(\"Hello, world!\\n\\r\");\nC. stringBuilder.append(System.lineSeparator());', 'C', '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (237, '下边这段代码的输出结果为\nint fst = 5;\nint snd = 2;\nwhile (snd < fst--) {\nsnd++;\n}\nSystem.out.print(snd);', 'A. 5\nB. 2\nC. 3\nD. 4', 'D', 'fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (238, '下列程序的输出结果为\nint num = 2;\nswitch (num) {\ncase 1:\nSystem.out.println(\"The input is 1\");\ncase 2:\nSystem.out.println(\"The input is 2\");\ncase 3:\nSystem.out.println(\"The input is 3\");\ndefault:\nSystem.out.println(\"Bad input\");\n}', 'A.\nThe input is 2\nThe input is 3\nB.\nThe input is 1\nC.\nThe input is 2\nD.\nThe input is 2\nThe input is 3\nBad input', 'D', 'switch没有break会执行完后面的如果\nint num = 2;\nswitch (num) {\n    case 2:\n        System.out.println(\"The input is 2\");\n    case 1:\n        System.out.println(\"The input is 1\");\n    case 3:\n        System.out.println(\"The input is 3\");\n    default:\n        System.out.println(\"Bad input\");\n}\n会输出 213 Bad input', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (239, '下列对于Stream的操作错误的是', 'A.\nfinal Stream<String> stream = Steam.of(\"Red\", \"Blue\", \"Green\");\nList<String> colors = stream.collection(Collector.toList());\nB.\nIntStream stream = IntStream.of(10, 20, 30, 40, 50);\nC.\nlong count = Stream.of().count();\nD.\nfinal Stream<String> stream = Stream.of(\"Red\", \"Blue\", \"Green\");\nSet<String> colors = Stream.toSet();', 'D', '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (240, 'Java的基本类型int在不同的操作系统平台的字长是', 'A. 32位\nB. 64位\nC. 16位\nD. 在32位系统上是32位，在64位系统上是64位', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 3, 0);
INSERT INTO `question` VALUES (241, '如下代码片段，s2的结果是哪项\nString str = \"123\";\nString s2 = str + 456;', 'A. 编译错误\nB. 123456\nC. 运行时抛异常\nD. 579', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (242, '编译并运行如下Java程序，将输出\npublic static void main(String[] args) {\ntry {\nint num1 = 2;\nint num2 = 0;\nint result = num1 / num2;\nSystem.out.println(result);\n} catch (ArrayIndexOutOfBoundsException e) {\nSystem.out.println(\"1\");\n} catch (NumberFormatException e) {\nSystem.out.println(\"2\");\n} catch (Exception e) {\nSystem.out.println(\"3\");\n} finally {\nSystem.out.println(\"4\");\n}\nSystem.out.println(\"5\");\n}', 'A. 345\nB. 134\nC. 2345\nD. 1345', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (243, '以下代码片断输出的结果是：\npublic class Demo {\npublic static void main(String[] args) {\nInteger fst = 1;\nInteger snd = new Integer(1);\nSystem.out.println(fst == snd);\nSystem.out.println(new Integer(1) == snd);\nSystem.out.println(fst == Integer.valueOf(1));\nInteger trd = 256;\nSystem.out.println(trd == Integer.valueOf(256));\n}\n}', 'A. false,false,true,false\nB. false,false,true,true\nC. false,false,false,false\nD. true,false,false,false', 'A', '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (244, '关于遮掩，说法不正确的是', 'A. 如果一个类或者一个包被遮掩了，那么不能通过其简单名引用到它，除非是这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字\nB. 遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式\nC. 一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内\nD. 如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上', 'C', '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 1);
INSERT INTO `question` VALUES (245, '以下描述错误的是：', 'A. 禁止使用主动GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中\nB. 将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作\nC. 进行IO操作时，应该在try-with-resource或者finally里关闭资源\nD. 可以在循环之外的节点主动GC', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (246, '执行如下语句，最终会运行什么文件？\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\");', 'A. 仅运行test.bat，并将notepad.exe作为test.bat的参数\nB. 仅运行notepad.exe\nC. 仅运行test.bat\nD. 运行test.bat和notepad.exe', 'D', '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (247, '以下Stream用法不正确的是', 'A. long test = Stream.of(\"1\",\"2\").count()\nB. List testList = Stream.of(\"1\",\"2\").collect(Collectors.toList())\nC. IntStream t = IntStream.of(10,20,30);\nD. Stream.of(\"1\",\"2\").toSet()', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (248, '可转换为double的数据类型有哪些？', 'A. byte\nB. String\nC. float\nD. long', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 4, 0);
INSERT INTO `question` VALUES (249, 'interface不能被哪些修饰词修饰?', 'A. protected\nB. final\nC. public\nD. private', 'ABD', '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 2, 4, 1);
INSERT INTO `question` VALUES (250, '以下关于抽象类的描述正确的是', 'A. 必须定义前缀为abstract\nB. 所有方法必须定义为抽象\nC. 抽象类可以实例化\nD. 抽象类必须包含一个抽象方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (251, '字节流、字符流区别描述正确的是：', 'A. 字节流关注流，不关注内容，字符流按行读取，关注文本\nB. 字节流的基类InputStream/OutputStream，字符流是Reader/Writer\nC. 字符流是对字节流的装饰，释放时反向逐一关闭\nD. 字符流最终都会按照字节流处理', 'BD', 'A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 0, 0, 0, 10, 4, 0);
INSERT INTO `question` VALUES (252, '关于方法返回值描述错误的是：', 'A. 方法的返回值必须被正确解析或者使用\nB. 方法可以没有返回值\nC. 返回值可以没有被用到\nD. 方法的返回值可被忽略', 'D', '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (253, '下列接口描述正确的是：', 'A. 类可以多重继承，接口可以多重继承\nB. 类可以多重继承，接口可以单重继承\nC. 类可以单重继承，接口可以多重继承\nD. 类可以单重继承，接口可以单重继承', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 4, 0);
INSERT INTO `question` VALUES (254, '接口ableA，ableB下面正确的是：', 'A. class Test implements ableA, ableB\nB. class Test implements ableA, implements ableB\nC. interface Test implements ableA, implements ableB\nD. interface Test implements ableA, ableB\nE. interface Test extends ableA, ableB', 'AE', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 4, 0);
INSERT INTO `question` VALUES (255, 'JDBC数据库连接的对象类型是：', 'A. Statement\nB. Connection\nC. DriverManager\nD. PreparedStatement', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (256, '关于Java8 Stream的描述正确的是', 'A. Stream跟迭代器类似，再次遍历需要重新生成\nB. Stream执行方式跟之前代码处理方式类似，中间操作立即执行\nC. 对Stream修改体现到数据源上\nD. Stream数据源只能是数组、容器或I/O', 'A', '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (257, '根据安全编程规范，Java类加载表述正确的是：', 'A. URLClassLoader的默认签名检查依赖jar包中的公钥，因此不能仅依赖该机制对jar包进行合法性检查\nB. 开发者不可以自定义类加载器\nC. 在JVM中，将不同ClassLoader实例加载的同一个类视为相同类\nD. 当自定义一个类加载器时，为了保证赋予权限的完整，应该直接覆写getPermissions()方法，无需调用基类的getPermission()方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 1);
INSERT INTO `question` VALUES (258, '如下哪些是immutable的？', 'A. char\nB. String\nC. short\nD. Integer', 'BD', '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 1);
INSERT INTO `question` VALUES (259, '关于类加载器以下说法正确的是：', 'A. ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包\nB. AppClassLoader负责加载当前应用classpath下的所有jar包和类\nC. BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类\nD. BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader', 'ABC', '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 3, 1);
INSERT INTO `question` VALUES (260, 'String str = \"a\" + \"b\" + \"c\" + \"d\";总共会创建几个对象？', 'A. 1\nB. 2\nC. 3\nD. 4\nE. 5', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 4, 0);
INSERT INTO `question` VALUES (261, '下面程序的输出是：\nint count1 = 0;\nfor (int rowNum = 0; rowNum < 3; rowNum++) {\n    for (int colNum = 0; colNum < 4; colNum++) {\n        if (colNum % 2 == 1) {\n            continue;\n        }\n        count1++;\n    }\n}\nint count2 = 0;\nfor (int rowNum = 0; rowNum < 3; rowNum++) {\n    for (int colNum = 0; colNum < 4; colNum++) {\n        if (colNum % 2 == 1) {\n            break;\n        }\n        count2++;\n    }\n}\nSystem.out.println(count1 + \",\" + count2);', 'A. 6, 6\nB. 9, 6\nC. 3, 3\nD. 6, 3', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 0, 1, 0);
INSERT INTO `question` VALUES (262, '下列说法错误的是：', 'A. TreeMap可以有\'null\'的key和value\nB. HashTable不允许有\'null\'的key和value\nC. HashMap线程不安全，但效率高\nD. HashTable是线程安全的，推荐使用', 'A', '解析：\nTreeMap键可以为\'null\'，值不允许\nD:也很牵强，HashTable 不如ConcurentMap好呀', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 0, 0, 0, 1, 4, 0);
INSERT INTO `question` VALUES (263, '关于HashMap的描述，以下说法错误的是：', 'A. HashMap能够保证其中元素的顺序\nB. HashMap允许将\'null\'作为值\nC. HashMap允许将\'null\'用作键\nD. HashMap使用键值的形式保存数据', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 0, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (264, 'Java NIO Channel通道和IO流的区别，说法正确的是：', 'A. 通道可以异步读写，流是同步读写\nB. 通道和流都可以支持Selector选择器多路复用\nC. 通道可以读也可以写，流一般来说是单向的\nD. 通道是面向缓冲区的，流是面向流的', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 2, 3, 0);
INSERT INTO `question` VALUES (265, '以下哪些关键字是与线程安全相关的', 'A. const\nB. synchronized\nC. protected\nD. volatile', 'BD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (266, '关于CountDownLatch的描述，正确的是', 'A. CountDownLatch.countDown()计数为0就会释放所有线程\nB. CountDownLatch计数为0后，无法重置\nC. CountDownLatch.countdown()为计数减控制\nD. CountDownLatch.await()只能触发阻塞等待，计数不会-1', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 3, 4, 1);
INSERT INTO `question` VALUES (267, '在java中，使用JDBC时，使用PreparedStatement执行sql语句有哪些好处', 'A. 使用PreparedStatement进行sql注入防护是优选方案\nB. 使用PreparedStatement多次执行同一条sql语句可以提升执行的效率\nC. 使用PreparedStatement可以有效解决所有的sql注入问题\nD. 正确使用PreparedStatement，可以有效防止sql注入的发生', 'ABD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 2, 0);
INSERT INTO `question` VALUES (268, '如果在构造复杂sql语句查询时，预编译的sql语句生成方法不够灵活，需要开发者手动拼接sql，现在输入参数已将 \' 、 \" 符号转义，请问如下针对mysql数据库的查询中，哪条是有可能受到sql注入攻击的？', 'A. \"select * from users where id=\" + request.getParameter(\"id\");\nB. \"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";\nC. \"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";\nD. \"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");', 'AD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (269, '以下路径属于标准化路径（Canonical Path）的是：', 'A. ~/test\nB. /opt/oss/log\nC. $ROOT/etc/conf\nD. /opt/oss/../../etc', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (270, '正则表达式/a+(bab)?(caac)*/，下列选项中是该正则表达式的子集是?', 'A. /(bab)(caca)/\nB. /a(bab){2}(caac)*/\nC. /a{2}/(*)\nD. /a+(bab){0,1}(ca)+(ca)/\nE. /a(^bab)+(caac){1,}/\nF. /a+(babc){2,}(acc){1,}/', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (271, '将含敏感数据的对象跨信任域传递前应该', 'A. 先签名再加密后传输\nB. 加密传输\nC. 先加密再签名后传输\nD. 签名传输', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 1);
INSERT INTO `question` VALUES (272, '对于下面的代码片段，假设PasswordManager的实例可以被非信任代码所访问，且changePassword()方法调用属于敏感操作，则下列说法中不正确的是：\npublic class PasswordManager\n{\npublic final Object lock = new Object();\npublic void changePassport() throws FileNotFoundException\n{\nsynchronized(lock)\n{\n// ...\n}\n}\n}', 'A. 可以省去changePasword()方法中的同步块，直接将changePasword()方法声明为synchronized修饰的同步方法\nB. changePassport()方法中应该包含安全管理器检查，以确认调用代码是否具有该操作权限\nC. 将该lock成员变量的可见性声明为private\nD. changePassport()方法不应该抛出FileNotFoundException异常', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (273, '若程序中需要获取操作系统登录用户名，应采取下列哪种方法来获取：', 'A. 提示用户输入\nB. 由环境变量获取:System.getenv(\"USER\")\nC. 由JVM属性获取:System.getProperty(\"user.name\")\nD. 启动程序的时候由程序参数传入', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (274, '下列有关Map的操作错误的是：', 'A.\nMap<Integer, String> cityMap = new HashMap<>() {\n{\nput(1, \"Nanjing\");\nput(2, \"Beijing\");\nput(3, \"Shanghai\");\n}\n}\nB.\nfor (Map.Entry<Integer, String> city : cityMap.entrySet()) {\nSystem.out.println(city.getValue());\n}\nC.\nMap<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4, null);\nD.\nMap<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 'D', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (275, 'Java中如何释放掉一个指定占据的内存空间', 'A. 程序员无法明确强制垃圾回收器运行\nB. 调用free()方法\nC. 赋值给该对象的引用为null\nD. 调用System.gc()方法', 'A', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (276, '以下描述错误的是', 'A.\npublic String getProductSummary(int index) {\nreturn products[index];\n}\n//该代码中index未校验，可能相起数组越界访问\nB.\nString userName = \"name\";\nResultSet rs = st.executeQuery(\"select * from user where name = \'\" + userName + \"\'\");\n//该代码可能会产生SQL注入漏洞\nC.\nRuntime.getRuntime().exec(\"cmd.exe /c dir \" + args[0]);\n//该代码可能会引起命令注入\nD.\nString command = System.getProPerty(\"command\");\nRuntime.getRuntime().exec(\"command\");\n//该代码可能会引起OS命令注入', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (277, 'Java IO Buffer状态变量不包括', 'A. capacity：最大容量\nB. flag：读写状态位\nC. position：当前已经读到的字节数\nD. limit：剩下的字节数', 'B', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (278, '关于sleep()和wait()，以下描述错误的是', 'A. sleep不释放对象锁，wait放弃对象锁\nB. sleep暂停线程，但监控状态仍然保持，结束后会自动恢复\nC. wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态\nD. sleep是线程类（Thread）的方法，wait是Object类的方法', 'C', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 3, 4, 0);
INSERT INTO `question` VALUES (279, 'Runtime.exec()方法与相关联的ProcessBuilder.start()方法可以用来调用外部程序进程，这些外部程序运行时Process对象会产生哪些流', 'A. 错误流\nB. 监控流\nC. 输出流\nD. 输入流', 'ACD', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (280, '下列哪些是线程同步的？', 'A. TreeSet\nB. HashTable\nC. Vector\nD. LinkedList', 'BC', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (281, 'Java语言中，下面哪个语句是创建数组的正确语句？', 'A. float f[][] = new float[6][6];\nB. float []f[] = new float[6][6];\nC. float f[][] = new float[][6];\nD. float[][] f = new float[6][6];\nE. float[][] f = new float[6][];', 'DE', NULL, '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (282, '哪些数据类型能直接输出？', 'A. int[] test = {1, 2, 3, 4, 5};\nB. List list = new LinkedList<>();\nC. Map<Integer, Integer> map = new HashMap<>();\nD. List list = new ArrayList<>();', 'BCD', '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (283, '有一个模拟赛跑游戏，运动员有跑得快的也有跑得慢的，运动员听到枪声后开始起跑，而最后一个运动员到达终点后，标志着比赛的结束。当前场景下，适合采用哪种线程同步机制?', 'A. CountDownLatch\nB. CyclicBarrier\nC. Semaphore\nD. BlockingQueue', 'A', '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (284, '20个人去银行存款，但是该银行只有两个办公柜台，有空位则上去存钱，没有空位则只能去排队等待，适合采用哪种线程同步机制', 'A. Semaphore信号量\nB. CountDownLatch\nC. CyclicBarrier\nD. BlockingQueue', 'A', '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 4, 0);
INSERT INTO `question` VALUES (285, '下列哪种情况可以终止当前线程的运行？', 'A. 当一个优先级高的线程进入就绪状态时\nB. 当该线程调用sleep()方法时\nC. 当创建一个新线程时\nD. 抛出一个异常时', 'D', '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 0, 1, 0);
INSERT INTO `question` VALUES (286, '下面字段声明中哪一个在interface主体内是合法的?', 'A. private final static int answer = 42;\nB. public static int answer = 42;\nC. final static answer = 42;\nD. int answer;', 'B', '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (287, '如下描述错误的是：', 'A. StackOverflowError是堆栈内存溢出\nB. OutOfMemoryError：Perm Gen是老年代内存溢出\nC. Java Heap Space溢出时，会导致所有线程暂停工作', 'B', '解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 0, 1, 3, 0);
INSERT INTO `question` VALUES (288, '107. 按照编程规范，下列哪些信息时禁止输入到日志中的', 'A．事件发生的时间、事件类型\nB．密钥\nC．明文口令\nD．密文口令', 'BCD', '', '科目二来着熊绒的博客', NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 1, 3, 0);
INSERT INTO `question` VALUES (289, '108. 有关类加载器的双亲委派模型说法错误的是', 'A. 类加载器之间是有层次结构的\nB. 加载不到类，会抛出ClassNotFoundException();\nC. 如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；\nD. 如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载', 'C', '', '科目二来着熊绒的博客', NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 1, 0);
INSERT INTO `question` VALUES (290, '两个对象 HashCode相同，equals不同，将其依次插入HashMap,正确的是()\n\n', 'A. 后者能成功存储，且会覆盖前面的值\nB. 其他选项都不行\nC. 会抛出异常\nD. 不能成功存储，但是也不抛异常', 'B', 'hashMap底层是先判断hash是否相同，相同在判断equals方法\neg：\nclass Temp {\n    public static void main(String[] args) {\n        HashMap<Temp, Integer> map = new HashMap<>();\n        // 看hash相同，equals不同map的存储情况\n        Temp hash1 = new Temp(1, 2);\n        Temp hash2 = new Temp(1, 3);\n        map.put(hash1, 100);\n        map.put(hash2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash不同map的存储情况\n        Temp equals1 = new Temp(0, 1);\n        Temp equals2 = new Temp(1, 1);\n        map.put(equals1, 100);\n        map.put(equals2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash相同 map的存储情况\n        Temp hasAndEquals1 = new Temp(0, 0);\n        Temp hasAndEquals2 = new Temp(0, 0);\n        map.put(hasAndEquals1, 100);\n        map.put(hasAndEquals2, 200);\n        System.out.println(map);\n    }\n    private int code;\n    private int equals;\n    @Override\n    public String toString() {\n        return \"Temp{\" +\n            \"code=\" + code +\n            \", equals=\" + equals +\n            \'}\';\n    }\n    public Temp(int code, int equals) {\n        this.code = code;\n        this.equals = equals;\n    }\n    @Override\n    public int hashCode() {\n        System.out.println(\"调用了hash\");\n        return this.code;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"调用了equals\");\n        if (obj instanceof Temp) {\n            return ((Temp) obj).equals == this.equals;\n        }\n        return false;\n    }\n}', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (291, '在使用UDP套接字通信时，通常使用什么类把要发送的信息打包 （）\n', 'A. DatagramPacket\nB. DatagramSocket\nC. String\nD. MulticastSocket\n', 'A', 'http://3ms.huawei.com/km/groups/2032581/blogs/details/1829183', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (292, '以下代码可以有效预防sql注入的是（）', 'A.\nStatement stmt = null;\nResultSet rs = null;\ntry {\n    String userName = ctx.getAuthenticatedUserName(); // this is a constant\n    String sqlString = \"SELECT * FROM t_item WHERE owner=\'\" + userName + \"\' AND itemName=\'\"\n        + request.getParameter(\n        \"itemName\") + \"\'\";\n    stmt = connection.createStatement();\n    rs = stmt.executeQuery(sqlString);\n    // ... result set handling\n} catch (\n    SQLException se) {\n    // ... logging and error handling\n}\n\nB.\nPreparedStatement stmt = null;\nResultSet rs = null;\ntry {\n    String userName = ctx.getAuthenticatedUserName(); // this is a constant\n    String itemName = request.getParameter(\"itemName\");\n    // ...Ensure that the length of userName and itemName is legitimate\n    // ...\n    String sqlString = \"SELECT * FROM t_item WHERE owner=? AND itemName=?\";\n    stmt = connection.prepareStatement(sqlString);\n    stmt.setString(1, userName);\n    stmt.setString(2, itemName);\n    rs = stmt.executeQuery();\n    // ... result set handling\n} catch (\n    SQLException se) {\n    // ... logging and error handling\n}\n\nC.\nCREATE PROCEDURE\nsp_queryItem @userName varchar(50),\n    @itemName\n        varchar(50)\nAS\n    BEGIN\nDECLARE\n@sql nvarchar(500);\nSET\n@sql =\'SELECT * FROM t_item\nWHERE owner = \'\'\' + @userName + \'\'\'\nAND itemName = \'\'\' + @itemName + \'\'\'\';\nEXEC(@sql);\nEND\nGO\nCallableStatement = null;\nResultSet results = null;\ntry {\n    String userName = ctx.getAuthenticatedUserName(); // this is a constant\n    String itemName = request.getParameter(\"itemName\");\n    cs = connection.prepareCall(\"{call sp_queryItem(?,?)}\");\n    cs.setString(1, userName);\n    cs.setString(2, itemName);\n    results = cs.executeQuery();\n    // ... result set handling\n} catch (\n    SQLException se) {\n    // ... logging and error handling\n}\n\nD.使用mybatis文件\n<select id = \"getItems\" parameterClass=\"MyClass\"resultClass=\"items\">\n    SELECT * FROM t_item WHERE owner = #{username} AND itemName = \'${itemName}\'\n</select>', 'B', 'A:拼接sql很明显sql注入\nB：使用的prepareStatement而且没有拼接安全\nC：有一说一，没看懂这段java程序，但是感觉也是拼接导致\nD：#{}表示占位符同?  而${}就算直接替换同拼接', NULL, NULL, '科目2', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (293, '关于hashCode和equals说法正确的是', 'A. 同一次运行中，同一个对象如果equals方法中用到的信息没有改变，多次调用hashCode方法返回值必须相同；\nB. 如果两个对象调用equals方法时相等，则这两个对象的hashCode方法返回也相同；两个对象的hashCode方法返回值相等，则两个对象的equals也相等\nC. 如果两个对象调用equals方法时不相等，则这两个对象的hashCode方法，可以相同，也可以返回不同的值\nD. 覆写equals的时候，应同时覆写hashCode方法\n', 'ACD', 'B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (294, '父类的哪些方法不能被子类重写', 'A. private\nB. final\nC. static\nD. public', 'ABC', '（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (295, '以下使用的断言语句中哪些有副作用 ()', 'A. assert names.isEmpty();\nB. assert names.remove(null);\nC. assert names.add(null);\nD. Boolean nullsRemoved = names.remove(null);\n   Assert nullsRemoved\n', 'BC', '这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;', NULL, NULL, '科目2', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (297, '某开源软件迭代块，版本更新频繁（如代码增长、社区开发人源、版本发布呈上升趋势）。则可以判断为此软件属于：', 'A 成长期\nB 成熟期\nC 衰退期\nD 导入期', 'A', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (298, '可靠性测试FIT的定义是', 'A 通过向系统注入在实际应用中可能发生的故障，观察系统功能性性能变化，故障检测、定位、隔离以及故障恢复清空，发现产品缺陷、评估系统可靠性的测试方法\nB 通过设置逐级递增的加严的环境应力，来加速暴露试验样品的缺陷和薄弱点的一种测试方法\nC 通过注入故障，对业务质量指标及系统可靠性指标进行测试，多维度进行可靠性评价，反应处系统的综合可靠性水平\nD 通过采用温度循环加振动的应力来筛选生产阶段产品，剔除产品中有早期缺陷产品的测试方法', 'A', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (299, '以下对敏捷宣言理解错误的是哪一项：', 'A 注重人而不是过程，开发团队的技能应当被成分认识和利用\nB 要拥抱变化，期待系统需求变化，对系统进行设计以更好地融入这些变化\nC 所有过程活动均事先计划，按照计划衡量进度\nD 注重客户协作，客户应当在整个开发过程中紧密参与', 'C', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (300, '以下关于第三方软件生命周期说法不正确的是？', 'A 第三方软件版本EOSS时间是华为根据华为软件版本的TR5时间来定义的\nB 产品在第三方软件首次引入时，当第三方软件的生命周期无法匹配产品生命周期要求时，产品需提前规划第三方软件的升级替代策略\nC 第三方软件生命周期关键管控点包含：EOSS、EOES\nD 产品软件版本TR5/RR前需完成所有下层软件组件的配套关系验证，其中，第三方软件版EOSS时间不早于产品软件版本EOS时间', 'A', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (301, '以下哪一种开发方法集中体现了计划驱动的开发过程的思想：', 'A 瀑布模型\nB 极限编程\nC Scrum\nD 持续集成', 'A', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (302, '在冗余设计中，以下描述错误的是?', 'A 系统配置类数据和动态业务的备份应有所区分，保证不同类数据的备份优先级顺序\nB 采用数据平滑消除备份数据中的错误，不是软件可靠性设计的关键技术，不用投入精力进行设计\nC 心跳检测定时器超时时长在资源允许的情况下 要尽可能短，以缩短故障检测时间，提高倒换速度\nD 心跳检测的握手需要提供多条通道，以保证通道的可靠性', 'B', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (303, '关于开源软件使用，下面说法不正确的是？', 'A 开发阶段，配置开源片段引用门禁扫描，将MR中的增量代码使用fossbot检测，若引用了开源代码，可以提醒用户，进行拦截\nB 产品在系统设计阶段需要在架构层面上实现开源与自研解耦\nC 开源软件使用声明包括：软件名称、软件版本、权利人声明、员工工号、许可证（license）\nD 产品若对apache 2.0许可的开源软件进行了修改，建议在修改的源码文件头附上修改声明，说明修改人、修改时间、修改内容', 'C', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (304, '客户对XX版本进行网上问题投诉，通过代码合入记录查询到引起该网上问题的代码修改是小明合入的。但经小明回忆，N天前，小红利用小明账号将修改提交合入至版本库。下列说法错误的是？', 'A 因小红尚未离职，通过小明的回忆已经找到真实的修改人，所以没有违背配置管理原则，不存在网络安全风险\nB 小红利用小明的账号进行代码合入存在代码修改无法追溯到真实的修改人的风险\nC 存在植入恶意代码的风险，完整性保护无法得到保障\nD 违背了网络安全红线关于禁止借用他人账号访问配置库的要求', 'A', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (305, 'A产品团队首次引入一款第三方软件，因准入测试不严格，遗漏后门问题未发现，在现网运行过程中，此第三方软件定期收集用户数据向远程服务器发送，引发安全事件，此案例体现了什么？', 'A 分析客户需求的重要性\nB 安全编码的重要性\nC 应急响应的重要性\nD 在研发过程中有效测试第三方组件安全性的重要性', 'D', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (306, '架构威胁建模采用的方法是下面哪一种方法？', 'A 安全架构设计\nB PIA（隐私影响分析）\nC STRIDE SD威胁建模\nD ASTRIDE Low Level威胁建模', 'C', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (307, '以下哪一个活动将软件组件、外部库、配置文件等编译和链接成一个完整的可执行程序', 'A 系统构建\nB 变更管理\nC 版本管理\nD 发布管理', 'A', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (308, '201X年X月，客户指出VMP（研发版本管理平台）平台缺乏完整性保护能力，没有完整的配置管理功能，存在软件包被篡改、调包的风险。基于该背景，研发开始逐步采用自研二进制仓替代原有的VMP平台管理二进制软件包。下列关于自研二进制仓的描述正确的是？', 'A 自研二进制仓无权限控制\nB 归档在自研二进制仓的软件包在版本发布后可以变更\nC 自研二进制仓取消了VMP采用的Windows share共享方式，不容易存留漏洞后门，确保了二进制完整性保护能力\nD 自研二进制仓不是公司级的版本存储空间', 'C', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (309, '关于原型开发，下列描述错误的是？', 'A 客户澄清需求，可以使用原型开发\nB 原型开发必须时间短、费用低\nC 所有的原型都是抛弃式\nD 搞清楚一个功能或方案是否可行，可以使用原型开发', 'C', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (310, '下面哪些做法符合《开源软件使用规范》要求的？', 'A 对于片段引用进行整改，可自研重写，或采取申请整包使用、部分编译的方法，或其他软件替代方案\nB 可通过修改函数名或变量名的方式规避fossbot扫描出片段代码\nC 对产品全量代码进行分析，确保所有使用的开源软件是整包使用，对片段引用情况可借助fossbot扫描工具辅助分析\nD fossbot扫描自研代码未匹配相似的开源代码，则说明自研代码中无片段引用\nE 将开源软件部分函数拷贝到产品自研代码中使用', 'AC', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (311, '以下数据结构中哪些是非线性结构？', 'A 栈\nB 二叉树\nC 线性表\nD 队列\nE 二维数组', 'BE', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (312, '密钥的安全管理对于整个系统的安全性至关重要，如果使用不恰当的密钥管理方式，即使采用强密码算法也无法保证系统的安全。下面关于密码算法中密钥管理的说法正确的有哪些？', 'A 密钥用途单一化，即一个密钥应只用于一种用途\nB 工作密钥在本地存储时需提供机密性保护\nC 口令、默认设置的可见字符等，均不能直接作为密钥使用\nD 不再使用的密钥，应当立即删除\nE 为方便密钥的管理，应将密钥硬编码在代码中', 'ABCD', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (313, '配置管理是网络安全的基础，某认证机构对华为进行网络安全认证时，首先关注的是配置管理。制定CMP（配置管理计划）是配置管理活动的开始，为了有效执行配置管理的基础活动，按照华为配置管理规范定义来看，CMP应该包含但不限于哪些内容?', 'A 基线与变更管理策略\nB 版本管理策略\nC 配置库策略\nD 分支策略\nE 配置项识别策略', 'ABCE', NULL, '可信科目三-真题 - 梁飞的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (315, '20XX年XX月，客户指出华为平台向产品发布的版本存在被篡改，调包的风险，那么关于平台版本的完整性保护的说法错误的是', 'A. 产品在使用平台发布的文件前，应进行数字签名校验，确保产品使用的文件与平台发布的文件是一致的\nB. 平台版本不需要实施数字签名\nC. 平台版本通过正式的发布渠道发布\nD. 平台软件包在发布时，对软件包实施数字签名', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (316, '某开发人员在提交代码时收到了冲突提示，在本地工作空间打开冲突的文件时间，内容如下…对上述提示，描述错误的是', 'A. 该开发人员需要解决冲突，本例中开发人员可以通过和冲突文件的修改人共同确认函数类型以及返回结果，确保冲突解除\nB. 提交成功，提示的是需要更新配置库上的最新版本后再进行提交\nC. 该开发人员的修改再提交时与另一提交的修改内容产生了冲突\nD. 撤销本次修改，也是改开发解决本地冲突的方式之一', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (317, '工程师老张将写作好的模块设计文档保存在工作电脑的磁盘中，而且有多篇设计文档命名类似，徒弟小李进入项目组熟悉模块架构时，老张却无法确认哪一篇是最新的设计文档，关于这个现象，老张应该怎么做', 'A. 为了进行高效共享，老张应该在本地磁盘修改后，将架构设计文档的最新版本及时共享给项目组成员，而不需要提交到统一的配置库\nB. 老张应该将架构设计文档提交评审流程，评审通过后进行基线\nC. 架构设计文档是关键的配置项，老张应该对架构设计文档进行配置项识别，按照配置项管理要求归档在统一的配置库中\nD. 老张要按照配置项命名规范对架构设计文档进行规范化命名，而不能随意命名为相似的名称', 'BCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (318, '小张是某产品的CME (配置管理工程师)，在产品的TR2评审会上，小张汇报了本阶段配置项的基线情况，请问小张的工作属于配置管理的哪个活动', 'A. 版本管理\nB. 分支管理\nC. 配置状态发布\nD. 管理配置库', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (319, '20XX年XX月，某认证机构对华为产品软件版本的二进制一致性提出质疑，且该认证机构对华为产品软件的版本的二进制一致性结论为“不一致”。为解决该问题，公司成立BEP (二进制一致性)项目组，关于BEP下列说法错误的是', 'A. Bepkit工具是为了提升二进制一致性差异消除的效率而开发的辅助工具\nB. BEP的目标是基于相同源码，相同环境，实现同一版本可重复构建，且构建结果完全一致\nC. 直接比较产品源代码编译构建的最终结果 (产品软件版本)，一般无法解析所产生的差异，需要从源代码，编译过程，直到最终发布得二进制包逐层分析产生二进制一致性差异的因\nD. 差异识别即基于相同环境，相同源代码编译两次，使用编译结果通过beyond compare进行比较，不完全一致即存在差异，由于时间戳引起的二进制一致性差异可以忽略', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (320, '按故障的持续时间分类，故障可以分为', 'A. 永久故障\nB. 瞬时故障\nC. 间歇故障\nD. 突发性故障', 'ABC', '解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (321, '下列选项中，属于故障检测技术的是', 'A. 单板重启\nB. 软件复位\nC. 时间检查 (如：心跳检测)\nD. 隔离仓设计', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (322, '为保证业务的正常运行，提高产品的解决方案的安全和韧性，可以从以下哪些方面进行设计', 'A. 降低攻击成功可能性\nB. 不利情况发生后恢复业务\nC. 限制不利情况发生时的损害\nD. 不利情况下维持核心业务', 'ABCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (323, '为了有效支撑事后审计，并向内部，外部客户证明研发过程风险是可控的…需要跟踪和记录的研发过程阶段有', 'A. 软件编码与构建\nB. 需求分析与设计\nC. 现网部署\nD. 验证发布', 'ABD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (324, '()与 ()需求时产品的质量属性之一，也是客户的基本诉求，产品需结合合规，准入及现网安全风险将其构筑在研发过程中', 'A. 隐私保护\nB. 网络安全\nC. 最优惠的价格\nD. 设备平稳运行', 'AB', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (325, 'GDPR关于个人数据处理的合法性以及个人主体权利的要求，以下描述正确的是', 'A. 只要注册时已对收集的数据获取了用户同意，后续可以直接新增收集和处理其他类型的个人数据\nB. 如果将用户个人数据转移给第三方，公司应获得用户同意或满足其他合法性基础\nC. 公司可以将用户个人数据转移给合作的第三方 (供应商，商业合作伙伴)，不需要告知客户\nD. 在经用户同意收集个人数据之后，用户无权干涉公司对这些个人数据的使用比如要求公司删除其个人数据', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (326, 'GDPR针对数据跨境转移有一定要求，如必须满足特定规则后才可传输，以下哪个场景不属于跨境转移场景', 'A. 作为数据处理者的法国供应商，基于成本考虑将数据转移到德国处理\nB. 在中国的维护终端上，远程查看和分析德国服务器上的个人数据\nC. 德国子公司的个人数据传输到俄罗斯处理\nD. 德国子公司个人数据传输到美国处理', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (327, '关于故障管理设计原则，下列说法错误的是', 'A. 冗余系统中，主备用模块的故障都需要检测，避免静默故障\nB. 对于不引起系统故障只导致系统或服务KPI下降的亚健康异常不需要检测\nC. 故障定时检测的周期，需综合考虑对CPU占用率的影响和检测延迟对业务恢复速度的影响\nD. 应及时监控有特殊寿命 (如Flash有擦写次数限制等)要求的器件健康状态，通过提前预警采取维护措施', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (328, '产品在代码实现过程中，会存在因为对外部输入参数校验不严格而导致堆栈溢出的漏洞，给产品带来风险，下列关于输入校验说法错误的是', 'A. 软件最为普通的缺陷就是来自客户端或者外部环境的数据没有进行正确的合法性校验，这种缺陷可以导致几乎所有的程序弱点\nB. 直接使用任意用户输入来构造格式化字符串会带来安全风险\nC. 当程序需要用户上传文件时，只需要校验用户上传的文件后缀名即可有效防止可执行文件上传漏洞\nD. 输入校验中如果没有特殊要求应该首先考虑采用“白名单”校验形式', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (329, '根据《华为隐私保护总体政策》要求，在业务活动中构筑隐私保护时，如下哪些不是收集数据的原则', 'A. 最小限度\nB. 机密性\nC. 必要性\nD. 目的相关性', 'B', '解析：收集数据原则： 合法、正当、透明 + 目的限制 + 数据最小化 + 准确性 + 存储期限最小化 + 完整性与保密性 + 可归责】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (330, '在网络安全中关于纵深防御的防御机制，下面说法正确的是', 'A. 需要从系统架构层面来关注整个系统级别的安全防御机制\nB. 不能只依赖单一安全机制\nC. 采用多点，多重的安全校验机制\nD. 纵深防御就是对外部数据使用前必须校验', 'ABC', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (331, '按照二进制文件的差异现象，可以将差异 分为时间戳差异和随机差异，时间戳差异表现为各种形式的时间信息，下面哪些场景属于时间戳差异', 'A. “Nov 1,2016,21:04:16”字符串\nB. 构建时刻距离1970/01/01秒数\nC. “2017030418056”字符串\nD. 其他自定义格式：1990+月-日-天-小时-分-秒的偏移量', 'ABCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (332, '下列产品的做法，正确的是', 'A. 某云服务应该对涉及的个人数据处理场景进行隐私风险评估，针对风险制定消减措施并闭环\nB. 某网站在设计时，在重定向到第三方网页前，告知用户将会发生跳转\nC. 某云服务收集了个人数据入IMEI，IMSI，没有在隐私声明中列出\nD. 某云服务收集个人数据前，明确提示用户，并获得用户的同意', 'ABD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (333, '系统中禁止存在未公开接口，以下哪些属于未公开接口', 'A. 可以进入系统的隐藏快捷键\nB. 隐藏命令或参数\nC. 可绕过系统认证的访问接口\nD. 隐藏账号', 'ABCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (334, '常见的安全编码问题不包括', 'A. 认证绕过\nB. 缓冲区溢出\nC. 命令注入\nD. 整数溢出', 'A', '解析：常见安全编码问题包括：缓冲区溢出、跨站脚本攻击、SQL注入和其他等等】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (335, '安全风险评估就是从风险管理角度，运用科学的方法和手段，系统地分析网络与信息系统所面临的威胁及其存在的脆弱性，评估安全风险等级主要依赖于', 'A. 资产的购买价值\nB. 已有的风险消减措施\nC. 社会工程\nD. 安全风险发生可能性和业务影响性', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (336, 'CSF (Cybersecurity Framework)核心框架包含5个功能IPDRR，其中P代表保护功能 (Protect Function)，保护功能可以限制或抑制网络安全事件的潜在影响，以下哪一组全部属于核心框架中的保护功能项', 'A. 身份管理和访问控制，数据安全，信息保护流程和步骤，安全运维\nB. 身份管理和访问控制，数据安全，信息保护流程和步骤，安全连续监控\nC. 身份管理和访问控制，数据安全，安全运维，风险评估\nD. 身份管理和访问控制，数据安全，安全运维，安全连续监控', 'A', '解析：CSF：http://3ms.huawei.com/km/blogs/details/6437325】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (337, 'A公司只负责开发并销售软件给客户，且A公司及其员工不接触也不参与客户系统的运营和运维，但是该软件会处理个人数据，因此A公司的角色是', 'A. 数据处理者\nB. 既不是数据控制者也不是数据处理者\nC. 数据主体\nD. 数据控制者', 'B', '解析：只开发软件卖给客户，则买软件的客户是数据处理者，A公司什么也不是，只是个开发工具的人，不接触数据】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (338, '开展PIA (Privacy Impact Assessment)时，区分数据控制者与数据处理者的关键原则是', 'A. 决定个人数据处理的目的及方式\nB. 管理数据分配时间\nC. 管理访问数据权限\nD. 决定数据存储方式', 'A', '解析：区分数据控制者与数据处理者的关键原则】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (339, 'FMEA是一种可靠性分析方法，FMEA分析过程中，我们常说的补偿措施，不包括以下哪个选项', 'A. 通过负荷分担保护业务\nB. 自动复位单板\nC. 现场更换单板\nD. 主备单板倒换', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (340, 'FMEA是一种可靠性分析方法，可以用于产品的设计阶段，下列哪个选项不是设计阶段FMEA分析的输出', 'A. FMEA分析表\nB. 软件故障管理需求\nC. 硬件故障管理需求\nD. 软件功能需求', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (341, '过载控制是指确保设备在业务过载场景下仍能保持较高业务处理能力的一种设计方法。下列选项中，哪个是常用的过载控制方案', 'A. 拒绝所有业务\nB. 接入所有业务\nC. 服务降级\nD. 复位系统', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (342, '某公司在决定量产和投放某产品之前，为了减少市场返修率，进行了反复的可靠性和性能等测试，这属于哪项风险应对措施', 'A. 减轻\nB. 接受\nC. 规避\nD. 转移', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (343, '从浴盆曲线来看，电子产品的失效包括以下哪几个阶段', 'A. 偶然失效期\nB. 早期失效期\nC. 生产失效期\nD. 损耗失效期\nE. 市场失效期', 'ABD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (344, '程序在处理外部数据时必须经过严格的合法性校验，编程人员在处理外部数据过程中必须时刻保持这种思维意识，不能做出任何外部数据符合预期的假设，外部数据必须经过严格判断后才能使用，下列选项中属于外部数据的是', 'A. 进程间通信 (包括管道，消息，共享内存，socket，RPC等)\nB. 函数参数 (对于API)，全局变量 (在本函数内，其他线程会修改全局变量)\nC. 用户输入 (包括命令行，界面)，用户动态数据 (对于内核程序)\nD. 文件 (包括程序的配置文件)，注册表，网络，环境变量', 'ABCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (345, '在移动设备上，用户可以通过应用权限设置开启或关闭应用对敏感信息的访问，该功能满足隐私保护的', 'A. 不可关联性\nB. 可干预性\nC. 透明性\nD. 机密性', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (346, '以下描述关于网络韧性工程的架构/技术的描述错误的是', 'A. 非持久性是在有限时间内保留信息，服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会\nB. 分割可以根据系统的重要级别进行划分，以限制成功攻击的传播和损害\nC. 权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配用户和网络实体的权限，以最大限度地减少对手活动潜在的后果\nD. 多样性使用异构技术 (例如，硬件，软件，固件，协议)，这样增加了网络建设的成本，运维的难度，是不可取的', '', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (347, '下面选项中，不属于故障隔离设计方法是', 'A. 重试设计\nB. 故障域划分设计\nC. 隔离舱设计\nD. 断路器隔离设计', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (348, '故障预测预防设计，可采用哪些方法\nA：基于故障机理模型的故障预测\nB：基于数据驱动的故障预测\nC：基于代码的故障预测\nD：基于文档的故障预测\n1  关于GPL V2 License的规避产品开源方式，以下做法正确的是 (AD)', 'A. 若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程 (需开源)，通过隔离层进行交互\nB. 在内核态中对Linux kernel进行调用，以避免GPL串扰\nC. 以动态链接的方式使用GPL软件，使产品代码不会被GPL传染\nD. 可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互', 'AB', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (349, '关于开源使用，如下选项描述错误的是', 'A. 原则上，为区分自研与开源代码，确保使用和修改可追溯，开源修改的patch文件需要独立存放管理\nB. 要求产品无代码片段引用，可借助FOSSID扫描工具辅助分析代码片段使用情况并进行整改\nC. 整包使用开源软件，版本名称可以根据产品版本定制命名\nD. 开源及第三方软件与自研代码独立存放，目录隔离，从产品代码目录结构区分出open_source目录，vendor目录，code自研目录', 'C', '解析：\n【规则】整包使用开源软件，版本名称与官网保持一致\n【规则】涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理\n【规则】开源修改的patch独立存放可管理\n【规则】禁止片段引用开源软件代码', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (350, '有关第三方软件引入的评估标准，正确的是', 'A. 供应商发布的软件正式版本，可以引入\nB. 已EOSS/即将停止销售的第三方软件不建议引入\nC. 未签署供应商网络安全协议的软件禁止引入\nD. 业务无替代的第三方软件，可能存在供应风险，不建议引入', 'BCD', '解析：供应商发布的软件正式版本，需要评估才能引入】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (351, '针对FOSSID上扫描出来的，和开源相似的代码，是否可以确认为自研，判断原则是什么', 'A. 判断原则是基于相似度，如果相似度很低，如低于5%可以判断为自研\nB. 判断原则是基于事实，编码前没阅读过开源代码写出的代码可以判定为自研，其他形式直接参考开源写的代码都属于开源\nC. 判断原则是基于工具，如果FOSSID无法扫描出来，则都是自研代码\nD. 判断原则是基于目录结构，自研目录下的都是自研代码，open_source目录下都是开源软件', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (352, '产品计划引入选型OpenSSL软件，下列说法正确的是', 'A. 修改的OpenSSL软件源码如果得到做着的认可，产品可以不用回馈社区直接引入选型OpenSSL\nB. openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入\nC. 从官网下载OpenSSL源码太麻烦，可以直接使用git命令下载github上而的openssl源码\nD. 可以从任意网址下载OpenSSL源码包，只要不扫描出病毒', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (353, '产品在开源软件使用过程中，下面哪项对开源软件的使用描述是不恰当的', 'A. 代码库中的开源原始包需和开源社区原始包一致\nB. 经评审不得随意修改开开开元源生代码，但基于开源定制的代码规模无限制\nC. 涉及源代码交付，对开源源生代码进行修改的代码，使用Patch方式管理\nD. 禁止片段引用开源软件', 'B', '解析：使用Patch方式管理—>正确】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (354, '片段引用开源，带来的风险是', 'A. 法务层面来看，产品无法正确且完整地履行开源软件义务，导致引起法务诉讼\nB. 网络安全层面来看，产品无法完整地回合社区对应补丁或漏洞无法追溯\nC. 产品拷贝的来源可能是不可靠的\nD. 维护工作量来看，开源片段会大量地分布在产品的各个模块或特性中，网络安全的攻击面会增大，漏洞修复的投入成本也增大，且容易遗漏', 'ABCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (355, '关于开源软件常见license的解读正确的是', 'A. LGPL软件本身必须开源，且具有传染性，与其动态链接部分的代码也必须以LGPL许可开源；静态链接则不被传染\nB. BSD类license，如Apache/BSD/MIT等，原则上没有对外开源要求\nC. GPL软件本身必须开源，且具有传染性，与该软件在同一进程中运行的代码都必须对外开源\nD. MPL类软件若无修改，则无需对外开源', 'BCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (356, '以下关于开源软件patch管理说法不正确的是', 'A. 原则上，为区分自研与开源代码，确保使用和修改可追溯，开源修改的patch文件需要独立存放管理\nB. 华为修改开源软件的patch代码量，必须严格控制，修改代码建议不超过5%\nC. 基于开源软件修改的自研Patch中可以包含开源权利人声明\nD. 开源软件社区发布的补丁要和自研修改的补丁做成一个patch进行统一管理', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (357, '小李负责某版本产品自研代码里片段引用开源的整改，有几处片段引用他经过整改转成了自研代码，SE抽检了他的几处整改，其中不符合整改要求的有', 'A. 通过修改变量名，宏名，使得FOSSID扫描不出来\nB. 通过修改函数名，使得FOSSID扫描不出来\nC. 不参考源代码，通过代码重构重新实现业务代码\nD. 通过删除注释，将宏替换为魔鬼数字等方式规避FOSSID扫描', 'ABD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (358, '某需要对外商用发布的产品使用了开源软件，对于该产品，以下描述正确的是', 'A. LGPL允许静态链接使用，但要履行对应代码开源义务\nB. 产品不链接GPL软件，而是将所需功能函数拷贝嵌入产品代码，则无需履行代码开源义务\nC. 若是独立进程使用GPL软件，则无需履行代码开源义务\nD. 若该产品使用了GPL软件，根据GPL license规定，该产品不得静态链接使用GPL软件', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (359, '下面关于开源软件代码修改说法正确的是', 'A. 产品P引入XX开源软件，工程师小A分析&应用后认为将XX软件的其中几个接口再重新封装形成新接口，可以更好支撑业务，于是小A在XX软件代码文件中新增一个功能接口，并且归档到开源软件目录支撑产品编译发布\nB. 产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，将开源软件归档到开源代码目录，并通过部分编译的形式，仅编译需要的特性进行打包发布\nC. 产品P引入XX开源软件，工程师小A分析&应用后认为需要对开源代码进行少量修改才能满足产品需求，通过团队架构评审等确认后，将修改代码以Patch的 方式进行管理\nD. 产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，于是将其他特性代码删除后，归档到开源目录支撑产品编译发布', 'BC', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (360, '有关第三方软件引入的评估标准，正确的是\nA：已EOSS/即将停止销售的第三方软件不建议引入 【禁止引入，不是不建议】\nB：业界无替代的第三方软件，可能存在供应风险，不建议引入\nC：未签署供应商网络安全协议的软件禁止引入\nD：供应商发布的软件正式版本，可以引入\n1  关于Devops以下哪种描述更为恰当____。 (C)', 'A. 一种新的角色，同时具备开发和运维技能\nB. 一个专门的团队，同时具备开发和运维能力\nC. 是指开发和运维一起参与到整个软件生命周期的过程中，事件从开发、测试、部署上线到维护\nD. 和传统运维区别不大，只是使用了一些新的工具去实现自动化', 'BCD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (361, '以下哪一种开发方法集中体现了计划驱动的开发过程的思想？', 'A. 极限编程\nB. 瀑布模型\nC. 持续集成\nD. Scrum', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (362, '下列对软件复用的理解正确的是？', 'A. 软件复用一定要复用代码，否则意义不大\nB. 软件复用一定能降低研发成本和风险，所以要尽可能地考虑复用\nC. 可复用的构件标准有利于复用\nD. 规划复用的时候要考虑很多因素，包括开发进度，所期望的软件生命周期，开发团队的经验等，所以是否复用经常是一个管理问题而非技术问题', 'CD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (363, '在软件实现过程中，需求管理贯穿整个过程，需求管理最基本的要求是明确需求，使项目和用户达成共识，建立____。', 'A. 需求跟踪说明书\nB. 需求变更管理文档\nC. 需求分析计划\nD. 需求基线', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (364, '软件需求是软件项目开发过程中开展和维持约定的活动，包括版本控制、需求控制、需求状态、跟踪状态等活动外，还包括___。', 'A. 需求发现\nB. 需求变更\nC. 需求排序\nD. 需求评估', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (365, '对需求分析的理解，下面描述正确的是___。', 'A. 需求分析中对不明确的功能需求要进行细致调查后进行具体化\nB. 需求分析是对项目目标和场景涉及的问题都要考虑\nC. 需求分析过程中需要将需求转换为形式化的功能规约，如需求规格说明书\nD. 在敏捷流程中，需求分析后可以不用输出形式化的功能规约', 'ABC', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (366, '下列需求分析的结果和描述不满足需求分析的质量要求___。', 'A. 对特殊的场景不做分析\nB. 特性的可交付性和服务代码要求的不一致\nC. 对性能的描述：整体系统的响应时间不小于2s\nD. 需求的来源对开发阶段的影响，通过IR/SR/AR进行了关联', 'ABC', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (367, '某大学图书馆需要建立一个新的管理系统，下列需求属于功能性需求', 'A. 用户可以根据图书名搜索到该图书\nB. 系统可以查询用户当前已经借到的图书\nC. 系统应该24H可用，宕机时间不超过5s\nD. 用户输入书名后。2s内查询到该书的信息\nE. 管理员再培训1H后可以使用该系统的管理功能\nF. 应将每个学生的学生编号作为该学生的唯一标识', 'ABD', '解析：产品需求：CE、组织需求：F】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (368, '一个项目中群中骨干员工离职，组织正在努力重新物色人选，在新人确定之前，项目经理和团队成员应该怎么做', 'A. 更新风险清单并分析风险影响\nB. 更新项目管理计划\nC. 不采取任何措施\nD. 更新风险管理计划', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (369, '以下哪一种现象不属于软件开发危机的一部分', 'A. 客户对于软件产品的需求持续下降\nB. 软件产品质量无法保证\nC. 软件开发进度难以预测\nD. 软件开发成本难以预测', 'A', '解析：软件危机详解：http://3ms.huawei.com/hi/group/2025905/wiki_4400291.html】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (370, '进行FMEA分析时，重大故障的严酷度等级包括', 'A. 严酷度为 III 类的故障\nB. 严酷度为 I 类的故障\nC. 严酷度为 II 类的故障\nD. 严酷度为I类和 II 类的故障', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (371, '常见的风险计划应对策略包括', 'A. 采用规避策略降低风险出现的概率\nB. 采用忽略策略应对具体风险概率\nC. 采用应急计划处置风险转变为具体问题的事件\nD. 采用最小化策略降低风险的影响', 'BCD', '解析：风险规避 + 转移 + 减轻；但是风险不能忽略】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (372, '下面属于Scrum Master的职责是', 'A. 保护开发团队免受外部干扰\nB. 引导团队正确应用敏捷实践\nC. 定义产品需求\nD. 促进团队紧密协作', 'ABD', '解析：定义产品需求不属于Scrum Master的职责】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (373, '关于软件开发和维护工作，以下说法错误的是', 'A. 用户培训是帮助用户理解产品并掌握系统的使用和操作\nB. 软件交付的主要工作是将程序代码和相关文档交给用户\nC. 持续集成是频繁持续地将团队成员的工作进行集成\nD. 软件部署是通过配置，安装和激活等活动保证软件系统的正常运行', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (374, '下面的', 'A. 提供的软件产品速度比同类产品快10%\nB. 公司的服务必须满足所有租车服务行业监管条例\nC. 提供叫车与车辆信息服务来满足司机车辆服务与乘客出行的要求\nD. 让客户将品牌与低价格联系在一起', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (375, '关于软件工程，以下说法错误的是', 'A. 软件工程的目的是支持专业化的软件开发，而不仅仅是个人数据\nB. 软件工程发展的目的就是希望找到合适的方法和即使适用于软件系统\nC. 软件工程仅指实现软件生产开发的活动序列\nD. 软件工程是一门研究用工程化方法构建和维护有效的，实用的和高质量的软件的学科，它涉及程序设计语言，数据库，软件开发工具，系统平台，标准，设计模式等方面', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (376, '下面哪一条是软件选课系统的质量要求，并且满足原子性要求', 'A. 系统应该在2018年9月1日之前上线部署运行\nB. 系统可按照院系统计学生选课情况，指定统计范围后1s内返回统计结果\nC. 用户规模不超过5000人时，登陆密码验证时间不超过2秒，用户规模不超过2万人时，登陆密码验证不超过5秒\nD. 课程属性与学生专业属性不符时不允许选课', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (377, '启动 java 程序进程时，输入以下哪个参数可以实现年轻代的堆大小为50M', 'A. –Xmn50M\nB. –Xms50M\nC. –Xmx50M\nD. –Xss50M', 'A', '解析：-Xmn、-Xms、-Xmx、-Xss都是JVM对内存的配置参数：】\n-Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小\n-Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn\n-Xss设置每个线程可使用的内存大小', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (378, '关于jvisualvm，以下说法正确的是\nA．jvisualvm可以在java程序运行起来以后再运行，通过某些协议连接到Java进程中\nB．运行jvisualvm，需要配置环境，设置Java程序工程以及虚拟机参数等【不需要】\nC．jvisualvm无法开监控远程服务器的运行状态【错误，是可以的】\n5  以下可用于分析线程死锁问题的命令是 (C)', 'A. jmap [options]\nB. jhat [options]\nC. jstack [options]\nD. jstat [options]', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (379, '下列哪些情况可能出现死锁', 'A. 多个进程竞争资源出现了循环等待\nB. 一个进程进入死循环\nC. 进程资源释放\nD. 多个进程竞争使用共享的设备', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (380, '下面关于jmap说法不正确的是', 'A. 使用jmap可以查看堆中对象的统计信息，包括类名，对象数量和内存大小\nB. 使用jmap可以把java堆中的对象dump到本地文件\nC. 使用jmap可以定位线程死锁的问题\nD. 使用jmap可以打印java堆的配置情况和使用情况，还有使用的GC算法', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (381, '一次分配所有资源的方式可以预防死锁发生，它破坏死锁的四个必要条件中的', 'A. 互斥\nB. 占有并请求\nC. 循环等待\nD. 非剥夺', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (382, '以下哪个JVM工具可以查看堆内存使用情况', 'A. jps\nB. javah\nC. jmap\nD. jstack', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (383, '-Xrunjdwp:transport=dt_socket,server=y,address=5432,suspend=n,onthrow=java.io.IOException,launch=/sbin/echo，这段jvm参数说明正确的是', 'A. suspend指明是否支持断点\nB. 使用-Xrunjdwp后，将以调试模式启动java进程\nC. transport类型可以是dt_socket和dt_shmem，其中dt_shmem只适用于window平台\nD. onthrow指明是否在发生指定异常时中断执行，进行调试', 'BCD', '解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (384, '自发性上下文切换指线程由于自身因素导致的切出，下面哪些调用会导致自发性上下文切换', 'A. Thread.join()\nB. Object.wait()\nC. Thread.yeild()\nD. Thread.start()\nE. Thread.sleep()', 'ABCE', '解析：start()方法不会引起切换】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (385, '关于jinfo的用法，下面说法不正确的是', 'A. 可以查看某个JVM参数\nB. 可以查看java系统参数\nC. 可以调整JVM参数\nD. 可以查看java程序的内存使用情况', 'D', '解析：可以查看/修改JVM参数，java系统参数】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (386, '某测试环境发现部署的java进程 (pid=17212)经常Full GC，长期内存占用很高，疑似内存泄漏，现在想要确定是哪些类的实例占用内存较多，那么应该用下列选项中的哪个命令', 'A. jmap –histo 17212\nB. top –Hp 1721\nC. jstat –gcutil 17212\nD. jstack 17212', 'A', '解析：jmap：查看内存占用情况】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (387, '关于Java虚拟机的参数，哪些说法是错误的', 'A. 相比server模式，JVM client模式可以获得更好的性能\nB．通过-Xms和-Xmx可以设置Java堆的大小\nC．通过-XX:ThreadStackSize可以设置线程堆栈的大小\nD．通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize可以设置元数据区(Metaspace)的大小\nserver模式性能更好，cleint模式更适合GUI界面的交互应用', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (388, '“过大的测试用例”是指', 'A. 参数混乱导致测试失效时难以定位实际错误\nB. 测试用例执行永不失败\nC. 信息分散导致测试意图不清晰\nD. 单个测试用例体现了多个功能点测试', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (389, '下面关于静态测试和动态测试区别的描述，正确的是', 'A. 静态测试是由开发人员执行的，而动态测试是由专门的测试人员完成的\nB. 静态测试需要借助于专门的测试工具，而动态测试不需要\nC. 静态测试并没有真正运行软件，而动态测试需要真正运行软件\nD. 静态测试主要是为了增加测试人员对软件的理解，而动态测试是为了发现缺陷', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (390, '使用等价类方法设计测试用例，针对有效等价类，一个好的用例应该覆盖()有效等价类', 'A. 尽可能多的\nB. 尽可能少的\nC. 一半的\nD．1个', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (391, '关于测试用例，以下说法正确的是', 'A. 测试用例发现过多的系统缺陷，说明测试用例设计的质量较差\nB. 测试用例越多越好，意味着测试越完善\nC. 测试数据属于测试用例的组成部分\nD．单个测试用例覆盖的测试点越多越好', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (392, '以下关于软件测试的说法哪一项是不正确的', 'A. 因为执行频率高，因此回归测试需要尽可能的自动化，甚至纳入持续集成\nB. 开发者具有熟悉系统的优势，因此应该尽量让开发者完成整个IPD测试过程\nC. 测试应当从基本的软件组件开始，然后主键想向外直到整个软件系统都完成了集成\nD．从理论上讲，测试永远不可能完备', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (393, '重新执行已经进行的一些测试，以确保所做的修改没有导致非预测的副作用是指以下哪种测试', 'A. 集成测试\nB. 系统测试\nC. 回归测试\nD. 单元测试', 'D', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (394, '如入栈序列为1,2,3,4,5,则可能得到的出栈序列为', 'A. 1,2,5,3,4\nB. 3,1,2,5,4\nC. 3,2,5,4,1\nD. 1,4,2,3,5', 'C', '解析：注意栈后进先出的特点即可，每个选项带入栈推导下)', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (395, '如果数据是正整数，并且数据的范围和数据个数差不多，哪个排序算法最有效', 'A. 计数排序\nB. 冒泡排序\nC. 插入排序\nD. 选择排序', 'A ', '解析：数组几乎有序/短数组时，插入排序效率高，因为此场景下每个元素离它最终排定的位置都不会太远】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (396, '给定输入和输出两个字符串，给出能实现该输入输出的栈最小深度\n比如输入 ABCDE，输出BAEDC。栈最少深度为3\n【即入栈出栈过程中，栈内所存元素的最大数量：AB先进又出，再进CDE再出，最大元素数=3】\n元素a,b,c,d,e,f,g依次放入一个初始为空的栈中，若元素进栈后可以立即出栈，也可停留，直到所有元素都出栈，出栈顺序为b,d,c,f,e,a,g，则栈容量最小为多少 ()', 'A. 2\nB. 1\nC. 3\nD. 6', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (397, '在对n个元素进行快速排序的过程中，最坏情况下需要进行多少趟排序', 'A. n/2\nB. n-1\nC. n\nD. logn', 'A', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (398, '(顺序表)以下哪个说法是正确', 'A. 顺序表插入变动的时间复杂度为O (n)\nB. 顺序表按下标查找的时间复杂度是O (1)\nC. 顺序表在使用时，长度可随意变动\nD. 顺序表存储空间连续，即允许元素的随机访问', 'ABD', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (399, '关于算法的安全强度的说法错误的是', 'A. 密码算法的安全强度由算法本身和使用的密钥长度决定\nB. 现阶段在选择对称密码算法时推荐安全强度至少为128位\nC. 安全强度就是密钥长度\nD. 安全强度是对称破解密码算法或者系统所需要的工作量的一个数值度量，用来衡量密码算法或者密码系统的安全性', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (400, '计算机算法是指', 'A. 排序算法\nB. 对计算机上执行的计算过程得具体描述\nC. 方法调度\nD. 计算方法', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (401, '设一个堆栈的入栈顺序是1,2,3,4,5，若第一个出栈元素是4，则最后一个出栈的元素必定是', 'A. 5\nB. 3\nC. 1或者5\nD. 1', 'C', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (402, '对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是', 'A. 92,20,91,34,88,35\nB. 12,25,71,68,33,34\nC. 21,89,77,29,36,38\nD. 95,22,91,24,94,71', 'D', '解析：对于当前节点，它要么比后面的节点都大，要么比后面的节点都小】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (403, '在任意一颗非空二叉排序树T1中，删除某结点v之后形成二叉排序树T2，再将v插入T2形成二叉排序树T3，下列关于T1与T3的叙述中，正确的是', 'A. 若v不是T1的叶节点，则T1与T3相同\nB. 若v是T1的叶节点，则T1与T3相同\nC. 若v不是T1的叶节点，则T1与T3可能不同\nD. 若v是T1的叶节点，则T1与T3可能不同', 'BC', '解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (404, '输入字符串abcde，必须包含字符a,b,c,d,e，所能排列出来的所有不同字符串个数为', 'A. 108\nB. 96\nC. 64\nD. 120', 'D', '解析：5个位置放5个字符= 54321=120】', '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (405, '二叉树的第k层 (根为第一层)的节点数最多为', 'A. 2的k次方-1\nB. 2的(k-1)次方\nC. 2k-1\nD. 2k+1', 'B', NULL, '可信认证考试科目三整理（Java，工作级） - 张克的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (407, '为了促进开源回馈被社区接纳，下述哪个行为不值得推荐', 'A.在社区邮件列表/issue列表里充分交流提交的方案，并根据意见反复修改\nB.在社区线下会议上介绍自己的方案，赢得社区的认可\nC.和社区维护者进行沟通，理解对方的规划思路\nD.由于社区一直未采纳提交补丁，自己在社区中fork一个新项目出来维护', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (408, '某产品在引入编译工具时，发现该编译工具中有调用Linux内核shadow加密功能，导致编译出的二进制有时间戳差异，应该如何消除这种差异', 'A.差异不解决，内核引起差异，不需要与认证机构、客户说明原因\nB.通过修改源代码方式解决\nC.使用辅助工具BepKit消除\nD.无需确认，直接删除该功能', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (409, '欺骗(Deception)是使用混淆和舞蹈手段干扰攻击者，比如部署蜜罐系统，以下哪个目录是通过欺骗无法达成的', 'A.将系统进行划分，以限制成功攻击的传播和损害\nB.消耗攻击者的攻击能力和时间，为联动防御或反制等提供时间差\nC.发现正在进行的攻击和潜在实施的攻击\nD.为反击取证和提供支撑', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (410, '二叉树的第k层（根为第一层）的节点数最多为()', 'A.2的k次方-1\nB.2k-1\nC.2的k-1次方\nD.2k+1', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (411, '以下几种不同的隐私保护技术中，对数据进行加躁处理，用于匿名数据收集和统计分析方法是()', 'A.差分隐私\nB.枚举\nC.截断\nD.掩码', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (412, '给定一颗含有N个节点的红黑树，在最坏的情况下，红黑树的删除节点操作的时间复杂度是()', 'A.O(N^1/2)\nB.O(N)\nC.O(N^2)\nD.O(logN)', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (413, '关于软件工程，以下说法错误的是', 'A.软件工程发展的目的就是希望找到合适的方法和技术适用软件系统\nB.软件工程仅指实现软件生产开发的活动序列\nC.软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科，它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式灯方面\nD.软件工程的目的是支持专业化的软件开发、而不仅仅是个人编程', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (414, '已知一颗7层完全二叉树的第6层（设根为第1层）有7个叶节点，则该完全二叉树的节点个数最多是()', 'A.113\nB.120\nC.51\nD.38', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (415, '下面关于系统之系统描述错误的是', 'A.系统之系统中的系统的不同部分可分别对应不同的管理和控制策略和规则\nB.系统之系统中并不存在一个对系统各个部分进行管理的管理者\nC.系统之系统是两个或以上独立管理和治理的系统的集合\nD.系统之系统不可能是最小规模系统，如包含不同提供商提供的服务的较小的系统，大规模系统经常是系统之系统', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (416, '关于过载控制设计原则，下列说法错误的是', 'A.自保恢复原则：负荷下降到设计能力范围之内后，网元可以立即恢复处理能力\nB.业务保证原则：确保在出现大流量冲击时所有业务不被丢弃\nC.及早控制原则：应尽可能在业务流程处理前端或业务处理较早的处理单元（网元/单板/芯片等）或底层协议层次上控制业务接入\nD.优先级保证原则：系统过载时保证高优先级的业务能够优先获得资源，优先得到处理', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (417, 'gcc编译器中，动态链接的ELF二进制程序使用称为全局偏移表(GOT)的查找表去动态编译位于共享库中的函数，那么GOT表全局保护选项的正确写法是？', 'A. -relro,-z,now\nB.-Wl,-z,relro\nC,-Wl,-z,relro,-z,now\nD.-Wl,-z,now', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (418, '故障隔离技术的核心思想是降低故障影响范围，防止产生（）', 'A.级联故障\nB.随机故障\nC.间歇性故障\nD.单点故障', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (419, '以下描述关于网络韧性工程的架构/技术的描述错误的是', 'A.非持久性是在有限的时间内保留信息、服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会\nB.权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配给用户和网络实体的权限，以最大限度的减少对手活动的潜在后果\nC.多样性使用异构技术（例如 硬件、软件、固件、协议），这样增加了网络建设的成本，运维的难度，是不可取的\nD.分割可以根据系统的重要级别进行划分，以限制成功攻击的传播或损害', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (420, '有如下一个类似调表的数据结构，每层都是已经排好序的链表，level1层的链表有所有元素，levelN层的链表只有level N-1的一般元素，level N层的节点指向levelN-1层中相同的节点，现在要查找32，需要经过的比较次数是\nhttp://image.huawei.com/tiny-lts/v1/images/2ff0026cc77e30a82cd3_554x297.jpg@900-0-90-f.jpg', 'A.6\nB.5\nC.4\nD.3', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (421, '关于冗余设计，下面说法错误的是', 'A.主用单元和备用单元的故障检测率都直接影响冗余系统可用度\nB.系统的冗余设计是硬件独立完成的，与软件关系不大\nC.电信产品要求具备高可用性，但同时也需要考虑成本等多方面的因素，所有冗余设计并不是使用的越多越好\nD.资源池冗余设计中要考虑负载均衡', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (422, '以下哪个选项开启后，编译器会将编译告警视为错误？', 'A.-Wextra\nB.-Wall\nC.-Werror\nD.-Wformat', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (423, '在开源软件引入选型中，以下哪项符合候选软件的引入要求？', 'A.ADAPDX master\nB.Apache Struts 1.1rc2\nC.cryptojs 3.19\nD.Apache ZooKeeper 3.5.4-beta', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (424, '某特性设计文档已经在DBOX（文档管理系统）完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理', 'A.20\nB.25\nC.15\nD.10', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (425, '对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是()', 'A.92,20,91,34,88,35\nB.12,25,71,68,33,34\nC.21,89,77,29,36,38\nD.95,22,91,24,94,71', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (426, '关于每日站立会议，下面的()说法是错误的', 'A.站会的要求是高效，并且让每个人都集中精力\nB.Scrum Master应该对成员所描述的任务内容进行评价\nC.它是一个简短的团队会议，由所有团队成员在每天固定的时间和地点进行\nD.它不是一个汇报会议，而是开发团队内部的沟通会议，以便快速发现问题', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (427, '针对FOSSID上扫描出来的，和开源相似的代码，是否可以确认为自研，判断原则是什么？', 'A.判断原则是基于事实，编码前没阅读过开源代码编写出的代码可判定为自研，其他任何形式直接参考开源写的代码是属于开源\nB.判断原则是基于工具，如果FOSSID无法扫描出来，则都是自研代码\nC.判断原则是相似度，如果相似度很低，如低于5%可以判断为自研\nD.判断原则是基于目录结构，自研目录下的都是自研代码，open_source目录下都是开源软件', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (428, '20XX年XX月，某认证机构对华为产品软件版本的二进制一致性提出质疑，且该认证机构对华为产品软件的二进制一致性验证结论为不一致，未解决该问题，公司成立BEP（二进制一致性）项目组，关于BEP，下列说法错误的是', 'A.BepKit工具是为了提升二进制一致性差异消除的效率而开发的辅助工具\nB.BEP的目标是基于相同的源码、相同的环境，实现同一版本可重复构建，且构建结果完全一致\nC.差异识别即基于相同的环境、相同的源代码编译两次，对两次编译结果通过beyond compare进行比较，不完全一致即存在差异，由于时间戳引起的二进制一致性差异可以忽略\nD.直接比较产品软件源代码统一构建的最终结果（产品软件版本），一般无法解释所产生的差异，需要从源代码、编译过程，直到最终发布的二进制包逐层分析产生二进制一致性差异的原因', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (429, '工程师小A在工作中对开源软件进行了特性修改，他知道这个修改未来会成为负债，因此决定贡献给社区，以下哪个做法是提倡的做法？', 'A.遵循社区规则，及时提交社区讨论互动\nB.为了避免暴露公司员工的身份，用个人邮箱提交给社区\nC.若华为规范与社区规范冲突，认为华为的规范更加合理，提交过程保留了华为的规范要求\nD.为了抓紧特性修改被社区合入，未经评审往社区提交', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (430, '无向图G有12条边，6个3度定点，其余定点的度均小于3，则G中可以有()个顶点', 'A.9\nB.10\nC.11\nD.8', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (431, '某产品在进行源码交付时被认证机构认定为所集成的A平台源码无法溯源，经过确认发现了根源，产品经理小强通过文件夹共享方式获取到A平台的联调版本并集成了该版本，A平台二进制对应的源码信息未做基线，产品在正式发布版本仍然使用A平台该联调版本，源码交付后，认证机构经过验证发现A平台源码缺失，上述行为违背了哪些配置管理原则', 'A.A平台二进制及源码没有进行配置标识及基线，导致源码缺失\nB.产品正式发布的版本应配套使用A平台的正式发布版本，不应使用A平台的联调版本\nC.联调版本没有通过联调版本发布流程发布，而是通过文件共享方式私下进行传递\nD.具备在任意时刻都能交付二进制对应的准确源代码的能力', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (432, '()与()需求是产品的质量属性之一，也是客户的基本诉求，产品需结合合规、准入及现网安全风险将其构筑在研发过程中', 'A.最优惠的价格\nB.设备平稳运行\nC.网络安全\nD.隐私保护', 'CD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (433, '关于开源使用，下列说法错误的是', 'A.某产品开发一款仅给内部一线行销员工使用的APP，并上架华为手机应用市场开放下载（但必须华为员工账号产能登录使用），该AAPP通过静态编译方式使用了一款AGPL开源软件，由于只是内部一线行销员工才能登录使用，可以不需要履行开源义务\nB.公有云服务产品A通过静态链接的方式集成使用了license为GPL V2.0的开源软件，服务产品A可以不履行代码开源义务\nC.某员工在业余时间以个人名义，在github开源了X项目，该员工在公司办公环境下载该X项目代码集成到产品A中使用，产品A不需要履行开源义务\nD.产品A自研开发且对外开源XXComb软件，并捐献到Apache基金会成为顶级项目，产品B选用社区XXComb软件，仍应认定XXComb软件为自研软件', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (434, '已知一颗完全二叉树的第8层（设根为第1层）有10个叶节点，则该完全二叉树的节点个数可能有（）', 'A.329\nB.137\nC.201\nD.491', 'BD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (435, '为了有效支撑事后审计，并向内部、外部客户证明研发过程风险是可控的，须准确记录所有参与软件研发环节的相关人员的信息和其交付件的信息，保证获取的上下游信息准确，需跟踪和记录的研发过程阶段有（）', 'A.验证发布\nB.现网部署\nC.需求分析与设计\nD.软件编码与构建', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (436, '下面关于-fPIChe -fPIE -pie选项描述正确的是', 'A.-fPIE -pie用于可执行程序\nB.两者作用相似可以互相替换\nC.-fPIC用于静态库\nD.-fPIC是编译选项', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (437, '有关第三方软件引入的评估标准，正确的是（）', 'A. 已EOSS/即将停止销售的第三方软件不建议引入\nB. 业界无替代的第三方软件，可能存在供应风险\nC. 未签署供应商网络安全协议的软件禁止引入\nD. 供应商发布的软件正式版本，可以引入', 'BC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (438, '以下关于开源选型的说法，哪些是正确的', 'A.铲平A使用一款tinyxml软件，内存分配和解析速度均可满足产品要求，且现网已稳定运行10+年，社区近期发布了tinyxml2，且社区也表示后续主要在tinyxml2上进行维护，其解析速度为tinyxml的5倍，但综合考虑升级成本及新版本的影响，产品确定继续使用tinyxml\nB.Json-lib软件社区2013年后社区已无人贡献，建议产品独臂Jackson、fastJson、Gson等同类软件，结合产品使用场景，选择生态、license较友好的开源软件\nC.XML解析开源软件SAX性能比Dom4j快10倍，SAX 2004年发布最后一个稳定版本，当前平均每周下载量34+次，对性能要求较高，且使用场景为只读不写（文件）的产品可以考虑选择此软件\nD.Log4j日志组件的作者2015年发布log4j2.X和logback；性能比log4j1.X高10倍，建议使用log4j1.X的产品考虑切换到log2.X或logback', 'BD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (439, '某电商公司的网站（单体应用，约100W行Java代码）的部署周期（需求提出到部署产品环境的时间）为4周（工作日20天），其中需求分析3天，开发时间为5天，测试人员手动进行功能测试时间为6天，环境准备和部署时间为4天，该公司为了提升自身竞争力，目标在半年内将部署周期降低到2周，以下哪些DevOps时间可以帮助该公司实现目标', 'A.功能测试自动化\nB.自动化部署\nC.软件开发过程引入敏捷、精益思维，最小化需求范围(MVP)\nD.微服务拆分', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (440, '为保证业务的正常运行，提高产品和解决方案的安全和韧性，可以从以下哪些方面进行设计？', 'A.不利情况发生后恢复业务\nB.不利情况下维持核心业务\nC.限制不利情况发生时的损害\nD.降低攻击成功可能性', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (441, '下面的（）不是敏捷开发的基本原则', 'A.坚持不懈的追求技术卓越和良好设计\nB.严格遵循计划和流程\nC.尽早和持续的交付有价值软件\nD.要面对面进行交流', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (442, '一个软件通过柱状图、地图等多种方式显示铁路实时订票情况，该功能使用观察者模式实现的话，其中的观察者对象和被观察者（即主题）对象分别是什么', 'A.观察者是各个不同的显示视图，被观察者是铁路实时订票数据\nB.观察者是铁路实时订票数据，被观察者是各个不同的显示视图\nC.观察者是整个实时监控界面，被观察者是铁路实时订票数据\nD.观察者是铁路实时订票数据，被观察者是整个实时监控界面', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (443, '运维人员在对某电商网站进行手动升级后第二天发生线上事故，影响了整个西安地区的所有用户。接到用户投诉后，运维人员进行手动回滚，约1小时恢复正常。事后分析发现，事故的根本原因是代码逻辑存在问题，在特定数据（西安地区用户）的场景下，会出现错误，以下哪些实践可以有效减少或者防止类似问题出现', 'A.为增强团队对产品的敬畏心，防止类似事故出现，引发事故的产品经理，开发，测试已经实施变更运维人员全年绩效不得超过B+\nB.引入灰度发布，功能先对小范围用户开放，然后增量开放给其他用户\nC.引入自动化测试，减少测试人员手工测试可能导致的错误\nD.自动化产品的部署和回滚，降低失败对用户的影响时间\nE.预生产环境数据准备要接近生产环境，可以更好的针对生产环境数据进行验证', 'BDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (444, '以下哪一条是软件选课系统的质量需求，并且满足原子性要求？', 'A.用户规模不超过5千人时，登录密码验证时间不超过2秒，用户规模不超过2万人时，登录密码验证不超过5秒\nB.课程属性与学生专业属性不符时不允许选课\nC.系统应当在2018年9月1日之前上线部署运行\nD.系统可按照院系统计学生选课请款个，指定统计范围后1秒内返回统计结果', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (445, '故障预测预防设计，可采用哪些方法', 'A.基于故障机理模型的故障预测\nB.基于代码的故障预测\nC.基于文档的故障预测\nD.基于数据驱动的故障预测', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (446, '某公司产品开发人员，功能实现时预留后门，在特定场景下可以绕过支付机制获利，并成功在商用版本中发布，可以通过哪项活动避免该问题出现', 'A.威胁建模\nB.软件包完整性保护\nC.设计架构审查\nD.代码检视', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (447, '对于个人数据保护，系统更应该提供一些技术机制，如下哪些属于匿名化技术', 'A.截断：舍弃属性值的后几位信息来保证数据的模糊性\nB.置换：在表中某字段各记录的数据随机进行打乱(shuffling)\nC.掩码：将属性值的部分字符替换为固定的特殊字符（例如*）\nD.加噪：对原始数据增加一个随机值', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (448, '关于开源义务履行，下列说法错误的是', 'A.修改声明是指公司做出的对修改过的开源软件就修改时间，修改的代码以及修改过的文件做出的声明，但建议产品在修改GPL/LGPL类开源软件时，履行该义务\nB.不同该许可证的开源代码不存在兼容性问题（如GPL License与BDS License），只要申请后即可按规范使用\nC.代码对外开源义务是指按照开源许可证要求将一定范围内的代码对外开源，开源范围视具体许可证的要求和产品具体使用方式而定\nD.原则上只要使用了开源软件，就需要履行开源使用声明义务', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (449, '面向服务的方法的好处：', 'A.服务提供商会公开服务的信息，任何获得授权的用户都可以使用相应服务\nB.组织内部或外部的服务提供商都可以提供服务\nC.服务的用户能根据使用而不是提供商提供的服务来付费\nD.应用能够延迟服务绑定直到这些服务被部署或执行', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (450, '基于威胁建模的测试设计方法需要在安全测试活动中哪个阶段使用？', 'A.动态分析和Fuzz测试\nB.测试方案设计\nC.总体测试策略\nD.静态分析', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (451, '假设每个三元组代表有向图中的一条边，其中元素分别表示边的起点、终点、权重，对于如下有向图：(1,2,1),(1,3,3),(1,4,5),(2,5,7),(4,5,4)，则节点1到节点5的最短路径权重之和为（）', 'A.7\nB.8\nC.10\nD.5', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (452, '下面的（）不是Scrum主管的职责', 'A.组织每日站立会议\nB.引导团队正确应用敏捷实践\nC.定义产品需求\nD.促进团队紧密协作', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (453, 'FMEA(Failure Mode and Effects Analysis)是一种可靠性分析方法，FMEA分析过程中，我们常说的补偿措施，不包括以下哪个选项（）', 'A.通过负荷分担保护业务\nB.主备单板倒换\nC.现场更换单板\nD.自动复位单板', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (454, '关于“开放设计安全原则”，下面描述不正确的是（）', 'A.涉及加密算法选择时，多使用业界公开标准的成熟算法，而不要设计私有的，自以为安全可靠的算法\nB.设计不应该是秘密的，不应依赖对设计和实现的保密，以及攻击者的无知\nC.加密秘钥要公开开放\nD.密钥禁止硬编码', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (455, '来源可靠是开源及第三方软件管理的要求之一，如下软件来源一定可靠的是（）', 'A.Maven、npm、Pypi\nB.开源软件发布的官方网站，或官方指定的获取渠道\nC.GitHub\nD.华军软件园', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (456, '产品计划引入选型OpenSSL软件，下列说法正确的是', 'A.可以从任意网址下载OpenSSL源码包，只要扫描不出病毒\nB.修改的OpenSSL软件源码如果得到作者的认可，产品可以不用回馈社区直接引入选型OpenSSL\nC.从官网下载OpenSSL源码太麻烦，可以直接使用git命令下载github上的openssl源码\nD.openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (457, '关于开源使用，如下描述错误的是', 'A.原则上，为区分自研与开源代码，确保使用和修改可追溯，开源修改的patch文件需要独立存放管理\nB.开源及第三方软件与自研代码独立存放，目录隔离，从该产品代码目录结构区分出open_source目录、vendor目录、code自研目录\nC.要求产品无代码片段引用，可借助FOSSID扫描工具辅助分析代码片段使用情况，并进行整改\nD.整包使用开源软件，版本名称可以根据产品版本定制命名', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (458, '小张是某产品的CME（配置管理工程），在产品的TR2评审会上，小张汇报了本阶段的配置项的基线情况，请问小张的工作属于配置管理的哪个活动', 'A.分支管理\nB.版本管理\nC.配置状态发布\nD.管理配置库', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (459, '在进行二进制文件差异消除时，需要根据不同的差异引入原因拟定差异消除方案进行业务功能性能测试，确保差异消除不影响业务功能和性能，下列差异消除方案哪一个是不合适的？', 'A.通过BepKit辅助消除python编译pyc文件时引入的时间差异\nB.为消除自验代码中时间宏引入的二进制差异，可以选择删除DATE/TIME宏，并测试删除后是否影响业务功能\nC.对于arj等压缩引入二进制差异的情况，可以通过反解的方式辅助进行差异消除\nD.gcc lto优化引入二进制差异，直接删除lto优化选项消除差异，无需对业务性能进行测试', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (460, '关于故障预测预防技术，以下说法错误的是（）', 'A.通过故障预测预防，用户可以根据故障出现的概率以及出现的位置，采取相应的手段提前避免这些有可能出现的故障\nB.故障预测预防是一种被动故障处理技术\nC.故障预测预防技术是一种有效的主动故障处理技术\nD.故障预测可以在系统故障出现之前，通过分析系统的状态得到故障可能出现的概率以及出现的故障种类', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (461, '某CT产品3年前从供应商购买的一款第三方软件X，并在产品V1R1C00软件版本中配套A01单板使用。目前现网V1R1C01版本存量大，客户反馈较稳定，产品准备新立项V1R4C00版本，发现第三方软件X存在新版本，并且新版本也兼容A01单板，但切换测试成本较大，同时该软件版本标准维保即将到期，但供应商表示可以为华为单独提供延长维保服务，根据第三方软件生命周期规则，产品应该采取的策略是：', 'A.切换第三方版本X的新版本，确保能享受供应商完整的保障能力\nB.由于不是新产品，不考虑升级第三方软件X新版本\nC.考虑测试成本，通过购买供应商延长维保服务，继续使用X的老版本\nD.由于架构未调整，不考虑升级第三方软件X新版本', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (462, '当一个企业不得不支持许多相似但不完全相同的系统时，最有效的一种复用方法是（）', 'A.软件产品工程SPLE\nB.分布式系统\nC.应用框架\nD.应用系统复用', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (463, '关于GPL V2 License的规避产品开源方式，以下做法正确的是', 'A.若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程（需开源），通过隔离层进行交互\nB.在内核态中对Linux kernel进行调用，以避免GPL传染\nC.可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互\nD.以动态链接的方式使用GPL软件，使产品代码不会被GPL传染', 'AC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (464, '以下属于代码安全检视方法的是', 'A.静态工具扫描\nB.关键字扫描\nC.根因分析法\nD.自上而下分析法', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (465, '安全合规成为政府持续关注的焦点，业界在持续探索安全应对策略，平衡好监管和创新之间的关系，业界对业务风险本身的关注点从封闭网络的互联网出口延伸到系统内部模块，从业务结果风险可控，延伸到研发过程风险控制及可视化。针对以上变化点，下列说法正确的是（）', 'A.在研发过程中对各个环节的关键基础设施落地严格的风险应对措施，如对代码仓尽心更严格的访问、完整性方案设计，保障产品软件开发过程的完整性，一致性，不因恶意篡改导致最终的功能特性与客户预期不相符，设置损害客户利益\nB.产品要做到结果风险可控，须通过有效执行研发过程的安全活动控制项要求。\nC.产品要做到具备威胁无处不在的视角，通过有效的基础设施及环境保护应对研发过程恶意篡改风险。\nD.通过后端测试保证产品质量即可，研发过程风险无须过多关注', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (466, '选用开源软件时，需考虑以下哪些方面', 'A.合法合规\nB.网络安全风险\nC.生命周期情况\nD.开源软件的技术生态', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (467, '在软件需求工程中，需求管理贯穿整个过程，需求管理最基本的任务是明确需求，使项目团队和用户达成共识，建立', 'A.      需求跟踪说明\nB.      需求变更管理文档\nC.      需求分析设计\nD.      需求基线', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (468, '软件需求管理是软件项目开发过程中控制和维持需求约定的活动，包括版本控制、需求跟踪、需求状态跟踪等活动外，还包括', 'A.需求发现\nB.需求变更控制\nC.需求排序\nD.需求评估', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (469, '对需求分析的理解，下面描述正确的是', 'A.需求分析中，对不明确的功能需求，要进行细致调查后进行具体化。\nB.需求分析时，对项目目标，涉及的问题和场景，都需要考虑。\nC.需求分析过程中，需要将需求转化成形式化的功能规约，如需求规格说明书。\nD.采用敏捷流程后，需求分析完成后，可以不用输出形式化的功能规约。', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (470, '下面需求分析的结果和描述示例，哪些不满足需求分析的质量要求？', 'A.对特殊的异常场景，不做分析。\nB.特性的可交付性和服务代表要求不一致。\nC.对性能的描述：整体系统的响应时间不小于2秒。\nD.需求的来源和开发阶段的影响，通过IR/SR/AR进行了关联。', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (471, '某大学图书馆需要新建一个管理系统，下列需求哪些属于功能性需求', 'A.用户可以根据图书名搜索到该图书\nB.系统可以查询到某用户当前已借的图书\nC.系统应该24小时可用，宕机时间不超过5秒\nD.用户输入书名后应在2秒内查询到该书信息\nE.管理员应该在1H培训后可以使用该系统的管理功能\nF.应将每个学生的学生编号作为该学生的唯一标识', 'AB', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (472, '使用UML对系统进行动态建模，不能使用以下哪种图？', 'A.顺序图\nB.类图\nC.状态图\nD.活动图', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (473, '某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用一下哪个设计模式最为恰当？', 'A.适配器模式(ADAPTER)\nB.迭代器模式(ITERATOR)\nC.访问者模式(VISITOR)\nD.观察者模式(OBSERVER)', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (474, '以下关于结构型模式说法正确的是', 'A.结构型模式可以在不破坏类封装性的基础上，实现新的功能。\nB.结构型模式主要用于创建一组对象。\nC.结构型模式可以创建一组类的统一访问接口。\nD.结构型模式可以在不破坏类封装性的基础上，使得类可以同不曾估计到的系统进行交互。', 'ACD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (475, '当应用工厂方法模式时要考虑下面哪些问题？', 'A.必须提供工厂方法的默认实现\nB.参数化工厂方法\nC.所有语言的特点\nD.使用模板以避免创建子类', 'BCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (476, '函数搬移是代码重构的一个重要方法，下列重构使用了函数搬移方法的是', 'A.从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。\nB.将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。\nC.当发现类A某个函数不仅仅适用于当前类，还适用于其他的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。\nD.类A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及相关操作。', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (477, '在拆解一个大函数时，对拆解出来的小函数，通常我们如何为其命名？', 'A.根据函数处理流程方法，即怎么做。\nB.根据函数所要达到的目的，即做什么。\nC.根据函数的使用场景，即何时用。\nD.根据函数的输入参数决定，即对哪些。', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (478, '针对重构方法，下列说法错误的是', 'A.提取接口(Extract Interface)和提取超类(Extract Superclass)本质上是一回事，均可提取通用代码。\nB.隐藏委托关系会使代码层次更清晰，因此委托类的功能越多越好。\nC.当发现某个子类并未带来该有的派生价值时，就需要考虑把他和父类合并(折叠)起来。\nD.将值域上移到父类会有效减少子类的成员变量，只需要做搬移值域，不需要搬移对该值域的操作方法。', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (479, '关于重构，下列说法错误的是', 'A.重构尽量以微小的步伐修改程序，直接重构一个模块是非常冒险的行为，需要谨慎应对。\nB.程序\"如果没有坏(功能可用)，就不要去修复它\"，是代码是否需要选择重构的必要条件。\nC.重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。\nD.重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。\nE.使用各种有利于解耦的设计模式常常会导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。', 'BCDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (480, '从数据组织重构的角度看，下面描述不合理的是', 'A.开发初期如果类中有一个字段location标识位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。\nB.对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。\nC.对于数据结构，要求封装出增删改查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (481, '当我们做简单业务，通过数据连接池，获得一个数据库连接Connection，执行一个Statement，获得一个ResultSet后，就结束业务了，那么下面错误的是？', 'A.我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显示地关闭ResultSet和Statement，保持代码简单和简洁。\nB.我们需要先关闭Connection，接着显示地关闭ResultSet和Statement。\nC.我们需要先关闭Connection，接着显示地关闭Statement和ResultSet。\nD.我们需要先关闭ResultSet和Statement，然后Connection就自动关闭了，不需要显示地关闭Connection。', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (482, '违反秘钥用途单一规则的有', 'A.      同一个预共享秘钥，既可以用于认证，又可以用于完整性保护。\nB.      一个秘钥可以通过算法派生两个秘钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。\nC.      分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务\nD.      数字签名可以同时提供身份认证，数据完整性以及抗抵赖服务', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (483, '为保证数据在存储和传输过程中不被篡改，需要提供哪种密码学服务', 'A.      机密性\nB.      完整性\nC.      真实性\nD.      不可抵赖性', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (484, '下面哪些涉及是符合权限最小化原则的？', 'A.      一个帐号或帐号组只能拥有必需的角色和必需的权限，一个角色只能拥有必需的权限，不分配不必要的权限。\nB.      权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则\nC.      不使用“administrator”、 “Root”、”sa”、“sysman”、“Supervisor”和其他特权帐号来运行应用程序或连接Web服务接口、数据库和其它中间件。\nD.      根据运行所需的操作系统权限的不同以及暴露给用户的访问权限的不同，对其进行划分和授权，采用不同权限的帐号运行。', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (485, '针对目前开源的二进制一致性改进项目(BEP)发现的差异中，截止19年底，引起差异的原因比例最高的是', 'A.      时间宏引起的差异\nB.      编译脚本中引入绝对路径\nC.      开源第三方引入差异\nD.      加密引起的差异', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (486, 'public class JITTEST {\nprivate static final long NUM = 20000;\npublic static long doubleIndex(long i) {\nreturn 2*i;\n}\npublic static long sum(long arg) {\nlong sum = 0;\nfor (long i = 1; i <= arg; i++) {\nsum += doubleIndex(i);\n}\nreturn sum;\n}\npublic static void main(String[] args) {\nList<Long> result = new LinkedList<>();\nfor (long i = NUM; i >= 0; i--) {\nresult.add(sum(i));\n}\n}\n以上代码默认jvm参数运行时，会做哪些优化？', 'A.JITTest.doubleIndex被内联\nB.JITTest.doubleIndex会被编译成机器码执行\nC.JITTest.sum会被编译成机器码执行\nD.拆箱和装箱', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (487, '以下关于Full GC和Minor GC描述正确的有', 'A.Full GC不对MetaSpace进行GC\nB.GC调优是追求消除Major GC和Minor GC\nC.性能优化的三个指标：吞吐量、延迟、内存占用\nD.JVM垃圾收集三个基本原则：\nMinor GC最多原则、GC内存最大化原则、GC调优(吞吐量、延迟、内存占用)的3选2原则。', 'CD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (488, '-Xdebug–Xrunjdwp:transport=dt_socket,server=y,address=5432,suspend=n,nothrow=java.io.IOException,launch=/sbin/echo这段jvm参数说明正确的是：', 'A. 在java8中，-Xdebug可有可无\nB．transport类型可以是dt_socket和dt_shmem，其中dt_shmem只适用于windows平台\nC. 使用-Xrunjdwp后，将以调试模式启动java进程\nD. suspend指明是否支持断点   --- 调试客户端建立连接之后启动VM，调试启动问题\nE．onthrow指明是否在发生指定异常时中断执行，进行调试', 'ABCE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (489, '使用javac编译时，包含以下哪几个过程：', 'A.语义分析及生成字节码\nB.词法分析及填充符号表\nC.Server Compiler\nD.注解处理\nE.Client Compiler', 'ABD', '解析：词法分析 语法分析 填充符号表 语义分析 字节码生成', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (490, '关于构建脚本如Makefile、maven pom文件等，如下说法错误的是', 'A.构建脚本是源代码的一部分，要和源代码一起配置管理。\nB.构建脚本在提交入库的时候，一样要进行规范检查。\nC.Committer在处理MR的时候，也要对构建脚本的正确性、简洁性、是否高效等进行把关。\nD.为了提供开发和维护效率，各个子系统和模块可以自由选择最熟悉的脚本来编写构建脚本，可以多种脚本语言并存。\nE.为了提供可移植性，不应该使用与OS强相关的脚本语言或者命令(如shell或bat脚本)，而是尽量选择maven,cmake,gradle这样的构建工具和对应的而语言。', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (491, '关于构建过程中文件路径的使用，如下说法那个是错误的', 'A.  构建脚本中必须使用相对路径，禁止使用绝对路径。\nB.  构建工程中禁止依赖特定的安装路径。\nC.  禁止在构建的时候使用网络共享驱动器\nD.  构建工程和脚本应该对工具安装路径做明确的要求，明确写在脚本中，比如工具必须安装在/usr/build/tools目录下，这样方便对构建环境进行规范化和溯源。', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (492, '关于maven中依赖范围说法正确的是？', 'A.compile：默认的依赖范围，编译、测试、运行期都需要\nB.provided：表示在编译和测试期需要，但是运行期不需要\nC.test：表示在测试期需要，编译和运行时都不需要\nD.system：表示非maven仓库引入的jar，使用时需要显式的用systemPath元素提供一个本地系统中jar文件的路径\nE.runtime：表示在测试和运行期需要，但在编译的时候不需要', 'ABCDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (493, '某测试环境发现部署的java进程(pid=17212)经常Full GC，长期内存占用很高，疑似内存泄露。现在想要确定是哪些类的实例占用内存较多，那么应该用下列选项中的哪个命令？', 'A. jmap –histo 17212\nB. top –Hp 17212\nC. jstack 17212\nD. jstat –gcutil 17212', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (494, '关于java虚拟机的参数，那些说法是错误的？', 'A. 通过-XX:ThreadStackSize可以设置线程堆栈大小\nB. 相比server模式，JVM client模式可以获得更好的性能\nC. 通过-Xms和-Xmx可以设置Java堆的大小\nD. 通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize可以设置元数据区(Metaspace)的大小', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (495, '如下两个测试用例，违法了测试实现的什么原则\n@Test\npublic void testMethod1() {\n...\n}\n@Test\npublic void testMethod2() {\ntestMethod1()；\n...\n}', 'A.自动化\nB.可重复\nC.运行稳定\nD.独立性', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (496, '以下程序如果采用路径覆盖法进行测试，则至少需要()个测试用例\nif (result = null || result.getRowCount() == 0) {\nfound = false;\nSystem.out.println(\"没有结果!!!\");\n} else if (type == 1) {\nfound = true;\n} else {\nfound = false;\n}', 'A.2\nB.3\nC.4\nD.5', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (497, '给定如下代码\npublic class Person {\nprivate int age;\npublic Person(int age) {\nthis.age = age;\n}\npublic boolean canVote() {\nif (age <= 0) {\nthrow new IllegalArgumentException(\"age error\");\n}\nif (age <= 18) {\nreturn false;\n} else {\nreturn true;\n}\n}\n}\n93、下列单元测试用例能通过的有(BC)', 'A. @Test\npublic void canVote_throwIllegalArgumentExceptionForZeroAge0() {\nPerson person = new Person(0);\nperson.canVote();\n}\nB. @Test(expected = IllegalArgumentException.class)\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nperson.canVote();\n}\nC. @Rule\npublic ExpecetedException thrown = ExpecetedException.none();\n@Test\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nthrown.expect(IllegalArgumentException.class);\nperson.canVote();\n}\nD. @Rule\npublic ExpecetedException thrown = ExpecetedException.none();\n@Test(expected = IllegalArgumentException.class)\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nthrown.expect(IllegalArgumentException.class);\nthrown.expectMessage(\"age error\");\nperson.canVote();\n}', 'BC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (498, '在对代码配置库进行分支合并时经常会遇到修改冲突，下列场景中不会引起冲突的是', 'A.两个分支均修改了同一个文件的同一行，并且修改结果不同。\nB.同一个文件在两个分支上被重命名为不同的文件名。\nC.同一个文件在一个分支上被删除，在另一个分支上该文件被修改。\nD.两个分支分别修改了不同文件的内容。', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (499, '代码库中可能会用到配置文件来记录数据或者配置信息，如下说法错的是', 'A.可以使用Excel文件来作为配置文件。\nB.可以使用文本格式的ini文件座位配置文件。\nC.可以使用yaml作为配置文件。\nD.可以使用json格式的文件作为配置文件。\nE.可以使用xml文件作为配置文件。', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (500, '软件的可追溯需要具备的能力有', 'A.对单个软件项目的软件生产过程中产生业务对象的过程及对象间的关系的准确记录。\nB.开发过程中软件跨项目的需求以及配套依赖的关系的准确记录。\nC.产品支持不同业务平面的网络流量安全隔离。\nD.敏感数据需要具备加密保存能力。', 'AB', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (501, '关于开源使用，以下描述或做法不正确的是（）', 'A. 客户要求使用开源软件新版本，产品A集成使用的开源软件B近3年无人维护且无可替代软件，产品A将开源软件B及修改的代码在github以新项目C开源并且自行维护，再将开源软件C集成到产品A中进行使用。\nB. 开源软件的选用，是产品在需求分析和架构设计时决定的；产品需基于全量全视角管理产品和平台使用的开源及第三方软件，确保使用的开源及三方版本归一和满足生命周期要求。\nC. 产品A软件开发在编写代码时，拷贝Apache license 2.1、 的 XXC++ 开源代码中的排序算法实现代码，已提升开发效率。\nD. 产品A 使用的开源软件被爆出存在严重漏洞（CVSS>7）,产品A的安全SE分析发现该漏洞涉及的代码A未调用，可以不需要对产品A的现网版本打补丁。\nE. 某产品共130K行代码，其中仅10行代码与开源代码相似度较高; 该10行代码可以确认为自研代码。', 'ACDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (502, '在业务版本发布前，对于版本中的开源及第三方软件的网络安全要求，以下描述正确的有', 'A.为保证来源可靠，业务版本使用的开源及第三方软件必须来自保存在华为PDM库中的软件副本\nB.非A/B类红线安全问题，如果是高风险(CVSS评分>=7)的安全问题则在版本发布前解决或规避，如果是中低风险(CVSS评分<7)的安全问题则可待供应商/合作方修复后再同步其修复版本\nC.在业务版本的研发过程中，开源及第三方软件需随产品代码一起开展产品网络安全测试\nD.A类红线和高风险(CVSS评分>=7)的B类红线问题在版本发布前解决或规避，中低风险(CVSS评分<7)的B类红线问题则可待供应商/合作方修复后再同步修复版本', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (503, '关于DevOps，如下哪种描述更为恰当？', 'A.一种新的角色，同时具备开发和运维技能。\nB.一个专门的团队，同时具备开发和运维能力。\nC.是指开发和运维一起参与到整个软件生命周期过程的实践-从开发、测试、部署上线到维护。\nD.和传统的运维区别不大，只是使用了一些新的工具去实现自动化。', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (504, '已知一棵二叉树，如果先序遍历的节点顺序是：KDCEFGHB，中序遍历是：CDEFGHKB，则后序遍历结果为', 'A.CFHGEBDK\nB.CDFEGHBK\nC.FGHCDEBK\nD.CFHGEDBK', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (505, '以下代码会产生编译错误的语句是\npublic Class Something {\npublic static void main(String[] args){\nfinal Other o = new Other();\nnew Something().addOne(o); //1\n}\npublic void addOne(Other o) {\no.increase(); //2\no = new Other(); //3\n}\n}', 'A.1\nB.2\nC.3\nD.没有错误', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (506, '需要关闭资源，下面哪个写法更好？', 'A. InputStream in = ...;\nException ex = null;\ntry {\ntry {\n//code that might throw exceptions\n} catch (Exception e) {\nex = e;\nthrow e;\n}\n} finally {\ntry {\nin.close();\n} catch (Exception e) {\nif (ex == null) throw e;\n}\n}\nB. try (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}\nC. InputStream in = ...\ntry {\n//code that might throw exceptions\n} finally {\nin.close();\n}', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (507, '假设整数数组A[n]中的数都介于1到n^6之间，下述什么排序算法有O(n)的时间复杂度？', 'A.没有任何算法\nB.基数排序\nC.计数排序\nD.快速排序', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (508, '如果数据是正整数，并且数据的范围和数据个数差不多，哪个排序算法最有效？', 'A. 插入排序\nB. 冒泡排序\nC. 计数排序\nD. 选择排序', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (509, '如下代码片断都是意图实现判断容器中是否存在指定的字符串，其中哪种做法的平均时间复杂度最低？', 'A. ArrayList<String> list = ...;\nif (list.contains(\"Martin\")) {\n...\n}\nB.  LinkedList<String> list = ...;\nfor (String value : list) {\nif (value.contains(\"Martin\")) {\n...\n}\n}\nC. HashSet<String> set = ...;\nif (set.contains(\"Martin\")) {\n...\n}\nD. Vector<String> vec = ...;\nif (vec.contains(\"Martin\")) {\n...\n}', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (510, '以下单例实现正确的是', 'A. public final class Sinleton {\nprivate static Sinleton instance;\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nif (instance = null) {\nsynchronized (Sinleton.class) {\nif (instance == null) {\ninstance = new Sinleton();\n}\n}\n}\nreturn instance;\n}\n}\nB. public final class Sinleton {\nprivate static class Sinleton {\nprivate static Sinleton instance = new Sinleton();\n}\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nreturn SinletonHolder.instance;\n}\n}\nC. public final class Sinleton {\nprivate static volatile Sinleton instance;\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nif (instance == null) {\nsynchronized (Sinleton.class) {\nif (instance == null) {\ninstance = new Sinleton();\n}\n}\n}\nreturn instance;\n}\n}\nD. public final class Sinleton {\nprivate static Sinleton instance = new Sinleton();\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nreturn instance;\n}\n}', 'BCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (511, '下面选项中的泛型代码片段哪些是正确的？', 'A. static class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<? super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}\nB. static class Fruit{}\nstatic class Apple extends Fruit{}\npublic static void main(String[] args) {\nList<? extends Fruit> list = new ArrayList<>();\nlist.add(new Apple());\n}\nC. public class ShowTest<T> {\npublic static void show(T t) {\nSystem.out.println(t.toString());\n}\n}\nD.  static class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (512, '如下线程堆栈，说法正确的是？\n\"DEADLOCK_TEST-1\" daemon prio=6 tid=0x000000000690f800 nid=0x1820 waiting for monitor entry [0x000000000805f000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)\n- waiting to lock <0x00000007d58f5e60> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)\n- locked <0x00000007d58f5e48> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)\nLocked ownable synchronizers:\n- None\n\"DEADLOCK_TEST-2\" daemon prio=6 tid=0x0000000006858800 nid=0x17b8 waiting for monitor entry [0x000000000815f000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)\n- waiting to lock <0x00000007d58f5e78> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)\n- locked <0x00000007d58f5e60> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)\nLocked ownable synchronizers:\n- None\n\"DEADLOCK_TEST-3\" daemon prio=6 tid=0x0000000006859000 nid=0x25dc waiting for monitor entry [0x000000000825f000]\njava.lang.Thread.State: BLOCKED (on object monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.goMonitorDeadlock(ThreadDeadLockState.java:197)\n- waiting to lock <0x00000007d58f5e48> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.monitorOurLock(ThreadDeadLockState.java:182)\n- locked <0x00000007d58f5e78> (a com.nbp.theplatform.threaddump.ThreadDeadLockState$Monitor)\nat com.nbp.theplatform.threaddump.ThreadDeadLockState$DeadlockThread.run(ThreadDeadLockState.java:135)', 'A.线程DEADLOCK_TEST-1处于死锁状态\nB.线程DEADLOCK_TEST-2处于死锁状态\nC.线程DEADLOCK_TEST-3处于死锁状态\nD.DEADLOCK_TEST-1、DEADLOCK_TEST-2、DEADLOCK_TEST-3均没有处于死锁状态', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (513, '以下可能造成死锁的代码是', 'A. public class LeftRightLock {\nprivate final Object left = new Object();\nprivate final Object right = new Object();\npublic void functionA() {\nsynchronized (left) {\nsynchronized (right) {\ndoSomething();\n}\n}\n}\npublic void functionB() {\nsynchronized (right) {\nsynchronized(left) {\ndoSomething();\n}\n}\n}\n}\n......\nB. public void transferMony(Account fromAccount, Account toAccount, int amount) {\nsynchronized (fromAccount) {\nsynchronized(toAccount) {\nfromAccount.debit(amount);\ntoAccount.credit(amount);\n}\n}\n}\nC. public class Taxi {\nprivate Point location;\nprivate Point destinztion;\nprivate final Dispatcher dispatcher;\npublic Taxi(Dispatcher dispatcher) {\nthis.dispatcher = dispatcher;\n}\npublic synchronized Point getLocation() {\nreturn location;\n}\npublic synchronized void setLocation(Point location) {\nthis.location = location;\nif (this.location.equals(destinztion)) {\ndispatcher.notifyAvailable(this);\n}\n}\n......\n}\npublic class Dispatcher {\nprivate final Set<Taxi> taxis = new HashSet<>();\nprivate final Set<Taxi> availableTaxis = new HashSet<>();\npublic synchronized void notifyAvailable(Taxi taxi) {\navailableTaxis.add(taxi);\n}\npublic synchronized Image getImage() {\nfinal Image image = new Image();\nfor (final Taxi taxi : taxis) {\nimage.drawMarket(taxi.getLocation());\n}\nreturn image;\n}\n......\n}\nD. private final ExecutorService executor = Executors.newSingleThreadExecutor();\npublic void renderPage() throws InterruptedException, ExecutionException {\nFuture<String> page = executor.submit(new RenderPageTask());\nframe.set(page.get());\n}\npublic class RenderPageTask implements Callable<String> {\n@Override\npublic String call() throws Exception {\nfinal Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));\nfinal Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));\nreturn header.get() + \"page\" + foot.get();\n}\n}', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (514, '20XX年XX月，客户指出华为平台向产品发布的版本存在被篡改、调包的风险，那么关于平台版本的完整性保护的说法错误的是：', 'A.平台软件包再发布时，对软件包实施数字签名\nB.产品在使用平台发布的文件前，应进行数字签名校验，确保产品使用的文件与平台发布的文件是一致的。\nC.平台版本通过正式的发布渠道发布\nD.平台版本不需要实施数字签名', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (515, '某产品在向认证机构进行该产品软件版本11.1的源码交付时，开发工程师小王提取代码后完成了传递。由于小王操作失误，提取的代码并不是需要交付的11.1版本，而是10.1版本，小王重新提取产品软件版本11.1对应的源代码并重新向认证机构传递，并告知该认证机构应使用第二次传递的源代码。对于这一现象，下列说法正确的是', 'A. 版本在GA前已经达到了源码交付能力，所以源码加交付前直接提取即可，无需验证，小王没有错。\nB. 源代码与二进制版本的对应关系应该通过配置库、产品软件全量信息树等手段进行管理，不能靠人的责任心保障正确性。\nC. 源码交付时，小王及时发现所传递的源代码存在的问题并纠正，说明人工确认可以保障源码交付的准确性。\nD. 小王没有使用已基线的配套的源码标签进行提取导致源码提取错误是个人问题，流程保障、系统管理没有问题。', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (516, '如下哪些编译参数会导致编译告警被关闭？', 'A.-werror\nB.-nowarn\nC.-Xlint:none\nD.-X', 'BC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (517, '下列选项中，不属于故障隔离设计方法是\nA．隔离舱设计\nB．故障域划分设计\nC．断路器隔离设计\nD．重试设计\n解析：故障隔离设计：隔离仓 断路器 组合切片 可靠性沙箱 有限重试\n113、下列选项中，属于故障检测技术的是（）(B)\nA．隔离仓设计\nB．时间检查（如：心跳检测）\nC．软件复位\nD．单板重启\n解析： 故障检测的常用方法1、数值范围检查 2、数据完整性检查 3、比较测试 4、时间检测\n114、关于jinfo的用法，下面说法不正确的是？(A)', 'A. 可以查看java进程的内存使用情况\nB. 可以查看java系统参数\nC. 可以调整JVM参数\nD. 可以查看某个JVM参数', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (518, '以下关于开源软件patch式管理说法不正确的是？', 'A. 原则上，为区分自研与开源代码、确保使用和修改可追溯，开源修改的patch文件需要独立存放管理。\nB. 华为修改开源软件的patch代码量，必须严格控制，修改代码建议不超过5%。\nC. 开源软件社区发布的补丁要和自研修改的补丁做成一个patch进行统一管理。\nD. 基于开源软件修改的自研Patch中可以包含开源权利人声明', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (519, '元素a、b、c、d、e、f、g依次放入一个初始为空的栈中，若元素进栈后可以立即出栈、也可停留，直到所有元素都出栈，出栈顺序为b、d、c、f、e、a、g，则栈容量最小为多少？', 'A. 3\nB. 1\nC. 6\nD. 2', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (520, 'Symfony是一个开源软件，当前的社区有稳定的路标规划，代码稳定增长，开发人员保持稳定。当前该项目主要存在以下几个版本\n1.开发过程版本4.3-DEV\n2.最新在维护期内的LTS（Long-term Support）版本3.4.26\n3.最新版本4.2.7\n4.社区当前已知漏洞最少但非LTS的版本4.0\n产品如要选用该软件，应该选择哪个版本最为合适：\nA．4.0\nB．4.3-DEV\nC．4.2.7\nD．3.4.26\n118、下面哪些做法，不符合持续交付的理念。(D)\nA． 只要有环节失败，就停止整个流水线\nB． 构建失败后不要提交新代码\nC． 每次修改都能经过一次编译、测试、验证的过程\nD． 将失败的测试用例注释掉，以提高构建成功率\n119、下述哪段代码正确实现了升序排列的冒泡排序算法（）(A)\nA． for (int j = arr.length - 1; j >= 0; j--) {\nfor (int k = 0; k < j; k++) {\nif (arr[k] > arr[k+1]) {\nint tmp = arr[k];\narr[k] = arr[k + 1];\narr[k + 1] = tmp;\n}\n}\n}\nB．全都不是\nC． for (int j = arr.length - 1; j >= 0; j--) {\nfor (int k = 0; k < j; k++) {\nif (arr[k] < arr[k+1]) {\nint tmp = arr[k];\narr[k] = arr[k + 1];\narr[k + 1] = tmp;\n}\n}\n}\nD． for (int j = arr.length; j >= 0; j--) {\nfor (int k = 0; k < j; k++) {\nif (arr[k] > arr[k+1]) {\nint tmp = arr[k];\narr[k] = arr[k + 1];\narr[k + 1] = tmp;\n}\n}\n}\n120、使用jstat -gcutil {pid} 2000命令对进程id分别为10001,20001，30001的三个JVM进程做内存使用状态检查，输出结果如下，下列说法最准确的是：(D)\nA：相比另外两个进程，进程20001有更大的风险发生OutOfMemoryError\nB：10001，20001,30001三个进程都没有发生OutOfMemoryError的风险\nC：相比另外两个进程，进程10001有更大的风险发生OutOfMemoryError\nD：相比另外两个进程，进程30001有更大的风险发生OutOfMemoryError\n121、下列关于Maven命令的用法中，哪一个是错误的？(A)\nA．使用mvn install构建出的jar包，团队中其他人也可以直接使用。\nB．使用mvn test来运行该项目的所有maven module的单元测试。\nC．使用mvn clean清理掉上一次Maven构建出的所有文件。\nD．可以使用mvn dependency:tree命令分析项目依赖关系。\n122、使用数组作为队列时，最实用的方式是循环队列，即在达到数组结尾时，重复利用数组头的剩余空间。假定用长度为N的数组长来存储一个循环队列，队列头用front表示，队列尾用rear表示。当队列初始化为空时front=rear=0，每一次成功入队时rear++，每一次成功出队时front++，在front和rear永远不会溢出（溢出是指front或rear达到数据类型允许的最大值之后翻转为最小值。）的情况下，关于队列存放的最大元素数目正确的是参考(B)\nA：队列最大只能存放N-2个元素\nB：队列最大只能存放N-1个元素\nC：队列最多只能存放N+1个元素\nD：队列最多只能存放N个元素\n123、在移动设备上，用户可以通过应用权限设置开启或关闭应用对敏感信息访问。该功能满足隐私保护的（）属性要求？(A)\nA．可干预性\nB．机密性\nC．透明性\nD．不可关联性\n124、关于冗余系统的可用度 ，下面说法错误的是：(B)\nA．故障修复能力越差，则冗余系统可用度越低。\nB．倒换成功率越高，则冗余系统可用度越低。\nC．每个单元的失效率越高，则冗余系统可用度越低。\nD．备用单元故障检测率越高，则冗余系统可用度越高。\n125、Maven 项目配置文件的<dependency> 中引入的<scope>, 主要管理依赖的部署。对scope的取值描述有误的是：(D)', 'A. runtime：只在运行时使用\nB. test：只在测试时使用，用于编译和运行测试代码。不会随项目发布\nC. provided：期望JDK,容器或使用者会提供这个依赖。如servlet.jar 。\nD. system：适用于所有阶段，会随着项目一起发布。', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (521, '工程师老张将写作好的模块设计文档保存在工作电脑的磁盘中，而且有多篇设计文档命名类似，徒弟小李进入项目组熟悉模块架构时，老张却无法确认哪一篇是最新的设计文档。关于这个现象，老张应该怎么做？', 'A.为了进行高效共享，老张应该在本地磁盘修改后，将架构设计文档的最新版本及时共享给项目组成员，而不需要提交统一的配置库\nB.老张应该将该架构设计文档提交评审流程，评审通过后进行基线\nC.架构设计文档是关键的配置项，老张应该对架构设计文档进行配置项识别，按照配置项管理要求归档在统一的配置中\nD.老张要按照配置项命名规范对架构设计文档进行规范化命名，而不能随意命名为相似的名称', 'BCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (522, '对升序数组，下述哪段代码实现的二分查找算法是有问题的？参考', 'A.\nstatic int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid, high, key);\n} else {\nreturn recursive(arr, low, mid - 1, key);\n}\n}\nB.\nstatic int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high + low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid - 1, high, key);\n} else {\nreturn recursive(arr, low, mid + 1, key);\n}\n}\nC.\nstatic int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid + 1, high, key);\n} else {\nreturn recursive(arr, low, mid - 1, key);\n}\n}\nD.\nstatic int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, low, mid - 1, key);\n} else {\nreturn recursive(arr, mid + 1, high, key);\n}\n}', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (523, '有以下一段代码参考\nimport java.util.ArrayList;\nimport java.util.List;\npublic class ItemContainer {\nprivate List items = new ArrayList(10);   //Line 1\npublic void addItems(String item) {\nitems.add(item);               //Line 2\n}\npublic void print() {\nitems.forEach(System.out::println);  //Line 3\n}\npublic static void main(String[] args) {\nItemContainer container = new ItemContainer();  //Line 4\ncontainer.addItems(\"hello \");                 //Line 5\ncontainer.addItems(\"world!\");                //Line 6\ncontainer.print();                          //Line 7\n}\n}\n使用如下命令进行编译时，\njavac -source 1.8 -Xlint:all ItemContainer.java\n会在哪几行产生编译告警？', 'A.line 1\nB.line 4\nC.line 7\nD.line 6\nE.line 2\nF.line 5\nG.line 3', 'AEG', '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (524, '关于Maven构建依赖，下列选项中描述正确的是：()\nA：mvn dependency:tree指令可以用于分析解决依赖冲突\nB：A,B和C的依赖关系定义为A->B->C->D 2.0和A->E->D 1.0，则构建A时将使用D2.0，因为2.0的版本更高\nC：dependency的scope的取值范围有：compile, privided, runtime, test, system, import, 其中import只能应用于dependencyManagement下的配置\nD：通过dependencies->dependency节点配置依赖\nE：通过dependencyManagement->dependencies->dependency节点配置依赖\n130、以下哪个说法是正确的：()(BCD)\nA：顺序表在使用时，长度可随意变动\nB：顺序表查找的时间复杂度为O(1)\nC：顺序表存储空间连续，即允许元素的随机访问\nD：顺序表插入变动的时间复杂度为O(n)\n134、一个二叉树的前序遍历：abdefgc，中序遍历：debgfac， 后序遍历为：(C)\nA egdfbca\nB cgefdba\nC edfgbca\nD cegdfba\n135、重新执行已经进行过的一些测试，以确保所做修改没有导致非预期的副作用，指哪一种测试(C)\nA集成测试\nB单元测试\nC回归测试\nD系统测试\n136、Pom中定义使用maven-dependency-plugin插件的位置：（）(B)\nA．<parent>\nmaven-dependency-plugin\n</parent>\nB <build>\n<plugins>\nmaven-dependency-plugin\n</plugins>\n</build>\nC <dependencies>\n< dependency>\nmaven-dependency-plugin\n</ dependency>\n</ dependencies>\nD <modules>\nmaven-dependency-plugin\n</modules>\n137、用有序的双向链表存储一个支持“增”、“删”、“改”三个功能的赋值系统，这三个功能中有几个功能能做到时间复杂度为O(1)?(D)', 'A. 3\nB. 2\nC. 0\nD. 1', 'ACD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (525, '项目A使用maven工具构建，现在有这样的依赖关系,A->B->Y(2.0)，A->E->Y(1.0)，Y是A的传递依赖，并且在A的pom文件中，E的声明顺序在B之前，那么最终项目A会依赖Y的哪个版本？', 'A. 1.0\nB. 1.0和2.0都会被引入\nC. 无法确定\nD. 2.0', 'A', '解析：Maven依赖冲突解决原则是 1) 最短路径优先 2）同路径先声明优先', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (526, '以下可用于分析线程死锁问题的命令是（）\nA jstat [options] <pid>\nB jstack [options] <pid>\nC jmap [options] <pid>\nD jhat [options] <pid>\n解析：\n(jstat,令行的监控，包括了对Heap size和垃圾回收状况的监控。可见，Jstat是轻量级的、专门针对JVM的工具)\n(jstack是java虚拟机自带的一种堆栈跟踪工具。 jstack用于生成java虚拟机当前时刻的线程快照。)\n( Jmap是一个可以输出所有内存中对象的工具)\n(jhat是用来分析dump文件的一个微型的HTTP/HTML服务器)\nJinfo的作用是实时查看虚拟机的各项参数信息jps –v可以查看虚拟机在启动时被显式指定的参数信息，但是如果你想知道默认的一些参数信息呢？除了去查询对应的资料以外，jinfo就显得很重要了\njps是参照Unix系统的取名规则命名的，而他的功能和ps的功能类似，可以列举正在运行的饿虚拟机进程并显示虚拟机执行的主类以及这些进程的唯一ID\n140、以下哪个说法是错误的：(D)\nA 链表在使用时，长度可以随意变动\nB 链表查找的时间复杂度为 O(n)\nC 链表插入变动的时间复杂度为 O(1)\nD 链表存储空间全都连续，即允许元素的随机访问\n141、可靠性测试FIT（Fault Insertion Test） 的定义是（）(B)\nA通过向系统注入代码bug，观察系统功能性能变化，故障检测、定位、隔离以及故障恢复情况，发现产品缺陷、评估系统可靠性的测试方法\nB通过向系统注入在实际应用中可能发生的故障，观察系统功能性能变化，故障检测、定位、隔离以及故障恢复情况，发现产品缺陷、评估系统可靠性的测试方法\nC采用温度循环加振动的应力来筛选生产阶段产品，剔除产品中有早期缺陷产品的测试方法。\nD 通过设置逐级递增的加严的环境应力，来加速暴露试验样品的缺陷和薄弱点的一种测试方法。\n142、源码到发布交付构建流程是怎样的？\n1.制定交付计划\n2.启动发布&一致性验证\n3.代码合入代码库\n4.封版\n5.版本自动归档\n6.CI构建\n7.启动转测试\n8.自验(B)\nA 31465728\nB 13465872\nC 31456287\nD 13645728\n143、以下哪个JVM工具可以查看堆内存的使用情况？(B)\nA jstack\nB jmap\nC jps\nD javah\n144、以下关于-Wl,-z,noexecstack选项描述正确的是(AC)', 'A.可以保护堆的不可执行\nB.只能保护栈的不可执行\nC.可有效提高缓冲区溢出的难度，但仍可以被ret2lib、rop等攻击绕过\nD.不能保护段的不可执行', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (527, '当拆解一个大函数时，对拆解出来的小函数，通常我们如何为其命名？', 'A.      根据函数处理流程方法，即怎么做。\nB.      根据函数所要达到的目的，即做什么\nC.      根据函数的使用场景，即何时用\nD.      根据函数的输入参数决定，即对哪些', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (528, '关于重构，下列说法错误的是', 'A.      重构尽量以微小的步伐修改程序，直接重构一个模块是非常冒险的行为，需要谨慎应对。\nB.      程序“如果没有坏（功能可用），就不要去修复它”，是代码是否需要选择重构的必要条件。\nC.      重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。\nD.      重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。\nE.       使用各种有利于解耦的设计模式常常回导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。', 'BCDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (529, '从数据组织的角度看，下面描述不合理的是', 'A.      开发初期如果一个类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。\nB.      对象取代数据值，就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。\nC.      对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (530, '下面哪种操作是编程规范推荐的写法？', 'A.      使用类名调用静态方法，而不要使用实例或表达式来调用\nB.      方法的代码块嵌套过深，超过4层\nC.      对于返回数组或者容器的方法，应返回长度为0的数组或容器\nD.      Person Name变量没有判断是否为null', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (531, '下面命名中适合小驼峰的有哪些', 'A.      类的字段\nB.      方法参数\nC.      方法\nD.      局部变量', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (532, '对快速排序算法，在最差情况下，它的时间复杂度的递归公式和时间复杂度是（）\nA T(n) = T(n-2) + O(n) 和 O(n^2)\nB T(n) = T(n-1) + O(n) 和 O(n^2)\nC T(n) = 2T(n/2) + O(n) 和 O(nLogn)\nD T(n) = T(n/10) + T(9n/10) + O(n) 和 O(nLogn)\n152、产品在开源软件使用的过程中，下面哪项对开源软件的使用描述是不恰当的？(C)\nA 涉及源代码交付，对开源源生代码进行修改的代码，使用Patch方式管理\nB 禁止片段引用开源软件\nC 经评审不得随意修改开源源生代码，但基于开源定制的代码规模无限制\nD 代码库中的开源原始包需和开源社区原始包一致\n151、 若一个栈的入栈顺序为1,2,3，……，N，在入栈过程中随机出栈随机序列，若第一个元素是i，则第j个出栈元素是（）(D)\nA 不确定\nB j-i-1\nC i-j\nD i-j+1\n151、 下面哪些情况可能出现死锁 （）(D)\nA 一个进程进入死循环\nB 多个进程竞争使用共享的设备\nC 进程资源释放\nD 多个进程竞争资源出现了循环等待\n151、 某二叉树节点的中序遍历为 abcdefg ，后序遍历为 bdcafge，则其左子树中节点数目为（）(C)\nA 2\nB 3\nC 4\nD 5\n151、 假设有一个栈，元素一次进栈的顺序是A，B，C，D，E。 下列不可能的出栈顺序有？（）(c)\nA B,C,D,E,A\nB A,B,C,D,E\nC E,A,B,C,D\nD E,D,C,B,A\n解析：出栈的第一个元素是在原来的次序中是第几个，那么他的前面的元素必然都还在栈中\n151、 下列选项中，不属于故障恢复方法的是（）(D)\nA 倒换\nB 重建\nC 软件复位\nD 告警\n151、 某局“A”设备的“B”板异常挂死，所有B单板上的业务全部中断，维护人员插拔单板后业务恢复，但是该问题后来在网上多次出现，造成业务多次长时间中断。研发人员首先提供软件补丁，在“B”单板该死后可自动复位，尽快恢复运行。经过长时间分析，最后定位原因是设备对“0”字节包处理不当，导致设备异常，版本升级后问题解决。上述网上事故案例，从可靠性设计角度考虑，下面说法正确的是（）(BC)\nA 维护人员水平低，不应该只插拔单板，而应该进行系统复位，完全恢复业务。\nB系统设计方案缺少对B单板业务的自动故障检测和故障恢复功能，是造成业务长时间中断\nC原设计方案缺少对异常报文的容错能力，是导致B单板业务全部中断的主要原因。\nD “0”字节报文属于异常报文，应要求局方改善网络质量，而不是对A设备打补丁或升级软件。\n161、 产品A计划选择一款加密算法软件，实现主控板从上电到启动过程中对比加载文件和芯片中保存的文件是否一致，当不一致时禁止单板启动，并发告警给用户。以下选型不建议的是(ABE)\nA 整包引入业界主流软件OpenSSL，并采用部分编译的方式，仅编译其使用的5%左右的代码\nB 拷贝OpenSSL软件中密码算法功能相关的部分文件\nC 向其配置的底层平台提需求，由其实现此功能，并对上层提供统一接口。\nD 对比、测试、分析 &应用业界主流的加密算法软件，权衡性能和占用的单板空间\nE 参考OpenSSL中密码算法的实现，调增代码逻辑，对部分代码实现进行封装后作为自研代码使用\n1、 配置管理改进总体思路：基于产品（），拉通研发和配置管理活动(A)', 'A. 全量全视角的软件信息树设计\nB. 软件架构设计\nC. 配置识别和配置控制', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (533, '小张是某产品的CME（配置管理工程师），在产品的TR2评审会上，小张汇报了本阶段配置项的基线情况，请问小张的工作属于配置管理的哪个活动', 'A. 版本管理\nB. 分支管理\nC. 配置状态发布\nD. 管理配置库', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (534, '配置管理可保证交付产品的什么特征', 'A. 完整性\nB. 正确性\nC. 一致性\nD. 可追溯性', 'ACD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (535, '某特性设计文档已经在DBOX完成基线，由于特性接口需要变更，那么该特性设计文档应如何处理', 'A. 根据实际的特性接口变更规则，通过便跟过流程更新已基线的特性设计文档\nB. 更新特性设计文档，更新后的设计文档归档在小名工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考\nC. 由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新\nD. 由于该特性设计文档已经基线，所以不能更新', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (536, '运维人员在对某电商网站进行手动升级后第二天发生线上事故，影响了整个西安地区的所有用户。接到用户投诉后，运维人员进行手动回滚，约1小时恢复正常。事后分析发现，事故的根本原因是代码逻辑存在问题，在特定数据（西安地区用户）的场景下，会出现错误，以下哪些实践可以有效减少或者防止类似问题出现', 'A. 为增强团队对产品的敬畏心，防止类似事故出现，引发事故的产品经理开发测试以及实施变更运维人员全年绩效不得超过B+\nB. 引入灰度发布，功能先对小范围用户开放，然后增量开放给其他用户\nC. 引入自动化测试，减少测试人员手工测试可能导致的错误\nD. 自动化产品的部署和回滚，降低失败对用户的影响时间\nE. 预生产环境数据准备要接近生产环境，可以更好的针对生产环境数据进行验证', 'BCDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (537, '某局”A“设备的”B“板异常挂死，所有B单板上业务全部中断，维护人员插拔单板后业务恢复。但该问题后来在网上多次出现，造成业务多次长时间中断，研发人员首先提供软件补丁，在”B“单板挂死后可以自动复位，尽快恢复业务；经过长时间分析，最后定位根本原因是设备对”0“字节包处理不当，导致设备异常，版本升级后问题解决。上述网上事故案例，从可靠性设计角度考虑，下面说法正确的是', 'A. 系统设计方案缺少对B单板业务的自动故障检测和故障恢复功能，是造成业务长时间中断的主要原因\nB. 原设计方案缺少对异常报文的容器处理能力，是导致B单板业务全部中断的主要原因\nC. “0”字节报文属于异常报文，应要求局方改善网络质量，而不是对A设备打补丁或升级软件\nD. 维护人员水平低，不应该只拔插单板，而应进行系统复位，完全恢复业务', 'AB', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (538, '产品的安全属性，一般是指', 'A. 机密性\nB. 完整性\nC. 可用性\nD. 可靠性', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (539, '系统的可信目标可以通过如下哪些方式被确定的', 'A. 通过分析利益相关人的可信诉求而确定\nB. 客户需求就是可信目标\nC. 参考相关行业共识而确定\nD. 参考相关国际标准而确定\nE. 参考产品相关可信认证要求而确定\nF. 根据产品开发的安全部测试用例而确定', 'ACDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (540, '威胁分析和建模流程STRIDE包含哪些关键元素', 'A. 仿冒\nB. 篡改\nC. 抵赖\nD. 信息泄露\nE. 拒绝服务\nF. 权限提升\nG. 隐私', 'ABCDEF', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (541, 'STRIDE High level威胁分析基于数据流图中各元素进行S、T、R、I、D、E多个维度的分析，而ASTRIDE High Level威胁分析是基于架构视图中的什么进行S、T、R、I、D、E多个维度的分析', 'A. 组件\nB. 接口\nC. 报文\nD. 参数', 'AB', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (542, '关于ASTRIDE High Level威胁分析，说法正确的有', 'A. 基于产品架构视图进行威胁分析\nB. 重点分析业务组件和接口\nC. 基于产品数据流进行威胁分析\nD. 重点识别产品特性安全威胁', 'AB', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (543, '风险管理的秩序体现在：基于全面的、结构化的信息模型包括清晰的风险评价准则、影响准则、风险接受准则；基于授权和问责机制，在以下()实施一致的风险管理', 'A. 战略级(strategy level)\nB. 组织级(organization level)\nC. 业务级(business level)\nD. 技术级(system level)', 'BCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (544, '华为可信框架中可信任特征包括', 'A. 韧性(Resilience)\nB. 安全(Security)\nC. 隐私(Privacy)\nD. 安全(Safety)\nE. 可靠(Reliability)\nF. 可用(Availability)\nG. 完整性(Integrity)\nH. 可维护(Maintainability)', 'ABCDEF', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (545, '可靠/可用性设计的目的，是预测和预防产品所有可能发生的故障，通过设计预防和设计改进，有效地消除隐患和薄弱环节，使产品达到规定的可靠/可用性要求。故障管理是可靠/可用性设计的重要内容，包括', 'A. 故障检测\nB. 故障诊断\nC. 故障隔离\nD. 故障恢复', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (546, '移动设备上用户可以通过应用权限设置开启或关闭应用对敏感信息的访问，该功能满足隐私保护的()属性要求', 'A. 不可关联性\nB. 可干预性\nC. 透明性\nD. 机密性', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (547, '描述关于网络韧性工程的架构/技术的描述错误的是', 'A. 非持久性是在有限时间内保留信息，服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会\nB. 分割可以根据系统的重要级别进行划分，以限制成功攻击的传播和损害\nC. 权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配用户和网络实体的权限，以最大限度地减少对手活动潜在的后果。\nD. 多样性使用异构技术（例如，硬件，软件，固件，协议），这样增加了网络建设的成本，运维的难度，是不可取的', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (548, '违反密钥用途单一规则的有', 'A. 同一个预共享密钥，既可以用于认证，又可以用于完整性保护\nB. 一个密钥可以通过算法派生两个密钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性\nC. 分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务\nD. 数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (549, '代码安全检视有哪些分析方法', 'A. 身份管理和访问控制、数据安全、信息保护流程和步骤、安全运维', 'ABD', '解析：Half of the people think the answer is ABD and the other half think the answer is ABCD(source)\n15 CSF(Cybersecurity Framework)核心框架包含5个功能IPDRR，其中P代表保护功能（Protect Function），保护功能可以限制或抑制网络安全事件的潜在影响。以下哪一组全部属于核心架构中的保护功能项(A)\nB. 身份管理和访问控制、数据安全、安全运维、安全连续监控\nC. 身份管理和访问控制、数据安全、安全运维、风险评估\nD. 身份管理和访问控制、数据安全、信息保护流程和步骤、安全连续监控', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (550, '常见的安全编码问题不包括', 'A. FMEA分析表', 'A', '解析：安全编码Top问题\n17 FMEA是一种可靠性分析方法，可以用于产品的设计阶段。下列哪个选项不是设计阶段FMEA分析的输出(D)\nB. 软件故障需求管理\nC. 硬件故障需求管理\nD. 软件功能需求', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (551, '过载控制是指确保设备在业务过载场景下仍能保持较高业务处理能力的一种设计方法。下列选项中，哪个是常用的过载控制方案', 'A. 拒绝所有业务\nB. 接入所有业务\nC. 服务降级\nD. 复位系统', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (552, '从浴盆曲线来看，电子产品的失效包括以下哪几个阶段', 'A. 偶然失效期\nB. 早期失效期\nC. 生产失效期\nD. 耗损失效期\nE. 市场失效期', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (553, '程序在处理外部数据时必须经过严格的合法性校验，编程人员在处理外部数据过程中必须时刻保持这种思维意识，不能做出任何外部数据符合预期的假设，外部数据必须经过严格判断后才能使用。下列选项中属于外部数据的是', 'A. 进程间通信（包括管道、消息、共享内存、socket、RPC等）\nB. 函数参数（对于API）、全局变量（在本函数内，其它线程会修改全局变量）\nC. 用户输入（包括命令行、界面）、用户态数据（对于内核程序）\nD. 文件（包括程序的配置文件）、注册表、网络、环境变量', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (554, '安全风险评估就是从风险管理角度，运用科学的方法和手段，系统地分析网络与信息系统所面临的威胁及其存在的脆弱性。评估安全风险等级主要依赖于', 'A. 资产的购买价值\nB. 已有的风险消减措施\nC. 社会工程\nD. 安全风险发生可能性和业务影响性', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (555, '开展PIA时，区分数据控制者与数据处理者的关键原则是', 'A. 决定个人数据处理的目的及方式\nB. 管理数据分配时间\nC. 管理访问数据权限\nD. 决定数据存储方式', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (556, '根据《华为隐私保护总体政策》要求，在业务活动中构筑隐私保护时，如下哪些不是收集个人数据的原则', 'A. 作为数据处理者的法国供应商，基于成本考虑将数据转移到德国处理\nB. 在中国的维护终端上，远程查看和分析德国服务器上的个人数据\nC. 德国子公司的个人数据传输到俄罗斯处理\nD. 德国子公司个人数据传输到美国处理', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (557, '关于故障管理设计原则，下列说法错误的是', 'A. 冗余系统中，主备用模块的故障都需要检测，避免静默故障\nB. 对于不引起系统故障只导致系统或服务KPI下降的亚健康异常不需要检测\nC. 故障定时检测的周期，需综合考虑对CPU占用率的影响和检测延迟对业务恢复速度的影响\nD. 应及时监控有特殊寿命（如Flash有撰写次数限制）要求的器件健康状态，通过提前预警采取维护措施', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (558, '欺骗(Deception)是使用混淆和误导手段来干扰攻击者，比如部署蜜罐系统。以下哪个目标是通过欺骗(Deception)无法达成的', 'A. 为反击取证和提供支撑\nB. 消耗攻击者的攻击能力和时间，为联动防御或反制等提供时间差\nC. 发现正在进行的攻击和潜在实施的攻击\nD. 将系统进行划分，以限制成功攻击的传播和损害', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (559, '下列选项中，属于故障检测技术的是', 'A. 单板重启\nB. 软件复位\nC. 时间检查（如：心跳检测）\nD. 隔离仓设计', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (560, '下列哪项描述是正确的', 'A. 所有的软件bug都会导致安全漏洞\nB. 从成本上考虑，在验证阶段发现多数bug是比较好的\nC. 多数的安全bug不重要，因为攻击者不可能注意到\nD. 所有的软件都有bug，只有一些bug才是安全漏洞', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (561, '（）与（）需求是产品的质量属性之一，也是客户的基本诉求，产品需结合合规、准入及现网安全风险将其构筑在研发过程中', 'A. 最优惠的价格\nB. 设备平稳运行\nC. 网络安全\nD. 隐私保护', 'CD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (562, '容灾系统包括()三个级别', 'A. 数据级\nB. 应用级\nC. 业务级\nD. 代码级', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (563, '以下几种不同的隐私保护技术中，对数据进行加躁处理，用于匿名数据收集和统计分析方法是', 'A. 差分隐私\nB. 枚举\nC. 截断\nD. 掩码', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (564, '关于过载控制设计原则，下列说法错误的是', 'A.　自保恢复原则：负荷下降到设计能力范围之内后，网元可以立即恢复处理能力\nB.　业务保证原则：确保在出现大流量冲击时所有业务不被丢弃\nC.　及早控制原则：应尽可能在业务流程处理前端或业务处理较早的处理单元（网元/单板/芯片等）或底层协议层次上控制业务接入\nD.　优先级保证原则：系统过载时保证高优先级的业务能够优先获得资源，优先得到处理', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (565, '为保证业务的正常运行，提高产品和解决方案的安全和韧性，可以从以下哪些方面进行设计', 'A. 不利情况发生后恢复业务\nB. 不利情况下维持核心业务\nC. 限制不利情况发生时的损害\nD. 降低攻击成功可能性', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (566, '基于威胁建模的测试设计方法需要在安全测试活动中哪个阶段使用', 'A. 动态分析和Fuzz测试\nB. 测试方案设计\nC. 总体测试策略\nD. 静态分析', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (567, '关于故障预测预防技术，以下说法错误的是', 'A.通过故障预测预防，用户可以根据故障出现的概率以及出现的位置，采取相应的手段提前避免这些有可能出现的故障\nB.故障预测预防是一种被动故障处理技术\nC.故障预测预防技术是一种有效的主动故障处理技术\nD.故障预测可以在系统故障出现之前，通过分析系统的状态得到故障可能出现的概率以及出现的故障种类\"', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (568, '安全合规成为政府持续关注的焦点，业界在持续探索安全应对策略，平衡好监管和创新之间的关系，业界对业务风险本身的关注点从封闭网络的互联网出口延伸到系统内部模块，从业务结果风险可控，延伸到研发过程风险控制及可视化。针对以上变化点，下列说法正确的是', 'A.在研发过程中对各个环节的关键基础设施落地严格的风险应对措施，如对代码仓尽心更严格的访问、完整性方案设计，保障产品软件开发过程的完整性，一致性，不因恶意篡改导致最终的功能特性与客户预期不相符，设置损害客户利益\nB.产品要做到结果风险可控，须通过有效执行研发过程的安全活动控制项要求。\nC.产品要做到具备威胁无处不在的视角，通过有效的基础设施及环境保护应对研发过程恶意篡改风险。\nD.通过后端测试保证产品质量即可，研发过程风险无须过多关注', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (569, '故障预测预防设计，可采用哪些方法', 'A. 基于故障机理模型的故障预测\nB. 基于代码的故障预测\nC. 基于文档的故障预测\nD. 基于数据驱动的故障预测', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (570, '下面选项中，不属于故障隔离设计方法是', 'A. 重试设计\nB. 故障域划分设计\nC. 隔离舱设计\nD. 断路器隔离设计', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (571, '以下关于安全设计原则的描述，正确的有', 'A. 一个账号或账号组只能拥有必须的角色和必须的权限，一个角色只能拥有必需的权限，不分配不必要的权限，符合“权限最小化原则”\nB. 账户登录失败N此后可以暂时锁定账户X分钟，符合“失败-默认安全原则”\nC. 对资源访问的共享数量和使用应尽可能最小化，符合“最小公共化原则”\nD. 将直接对外交互的高权限高风险进程拆分为两个进程，一个负责外部交互，一个负责内部业务逻辑，符合“权限分离原则”', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (572, '如下对提高产品的可用度描述正确的是', 'A. 产品架构采用必要的冗余设计措施\nB. 冗余设计相关的要素如故障检测和回复措施得到合理设计和验证\nC. 采用更高可靠性等级的器件\nD. 采用必要的简化设计措施，降低复杂度', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (573, '关于容灾设计，以下说法错误的是', 'A. 容灾指除了生产站点以外，用户另外建立的冗余站点，当灾难发生后，生产站点受到破坏时，冗余站点管用户业务\nB. 容灾设计重点在于业务接管，数据可靠性不是其重点\nC. 衡量容灾系统的主要指标有RPO和RTO\nD. 容灾系统包括三个级别：数据级、应用级和业务级', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (574, '下面关于故障恢复的描述，正确的是', 'A. 冗余系统如果发生了影响业务的软、硬件故障后，应能通过主备倒换或符合分担实现自动的故障恢复\nB. 在非冗余系统中，对于影响业务的软件故障或硬件故障瞬间故障，可通过自动触发单板复位或局部复位等方式，系统恢复正常状态\nC. 系统自动执行故障恢复动作，可大大减少业务中断时间，但注意一定要保证判断的准确性，避免误动作。同需要在系统设计复杂性和减少业务中断时间之间权衡\nD. 通常的故障恢复技术包括进程复位、主备倒换', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (575, '下列关于数字签名的叙述中错误的是', 'A. 保证信息传输过程中的完整性\nB. 保证数据传输的机密性\nC. 发送者身份认证\nD. 防止交易中的抵赖行为发生', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (576, 'LGPL：开源软件本身（包含修改）&与其静态链接部分必须以LGPL许可对外开源，最措施是', 'A. 不修改使用\nB. 自研修改部分开源\nC. 动态链接使用，或者进程隔离', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (577, '开源软件及第三方软件使用的管控内容不包括', 'A. 软件有明确的许可证或签订有相关使用协议\nB. 对于开源软件履行开源义务，避免导致产品开源或公司声誉受损\nC. 产品使用第三方软件须先使用后申请\nD. 建立优选库路标库，减少种类和数量，牵引使用优选软件，禁选软件禁止使用', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (578, '开源软件要严进宽用，在引入时需经过严格网络安全选型评估，其主要评估内容包括', 'A. 已知安全问题及漏洞扫描，如：对业界公开的严重级别的安全漏洞已修复\nB. 病毒扫描\nC. 软件完整性及一致性检查\nD. 高风险模块静态代码扫描分析和代码人工检视', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (579, '以下关于公司IPD中开源及第三方软件风险管控活动的说法有误的是', 'A. 产品在TR4前必须进行开源认证\nB. 产品使用开源及第三方软件必须先申请后使用\nC. 在产品发布前，需进行开源认证\nD. 开源软件中心会定期将开源软件漏洞通知到产品', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (580, '产品代码开源包外发前为了保证不泄露关键信息资产，必须使用KIA扫描IPD流程中开源及第三方软件相关活动的顺序正确的是', 'A. 开源入库选型—>开源使用申请—>开源认证—>开源义务履行—>漏洞闭环处理', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (581, '如下哪些描述符合开源及第三方软件管理要求', 'A. 如果需要使用优选等级为‘DXX（禁选）’或者EOX的软件，或者应用技术风险为‘高’的软件，需要提供对应备案纪要\nB. 优先使用优选等级为‘B （优选）’的版本\nC. 不允许使用应用技术风险为‘高’的软件\nD. 不允许使用优选等级为‘DXX（禁选）’和EOX的软件', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (582, '如下哪些情况需要入库PDM', 'A. 如果待入库的的开源及第三方软件在PDM中已存在，需要引入新版本\nB. 如果待入库的开源及第三方软件在PDM中已存在，且版本号未更新，但供应商因为修改bug等原因更新了软件包\nC. 如果待入库的开源及第三方软件在PDM中不存在\nD. 供应商提供的软件包本身没有变化，且已经入库PDM，我司人员在其上进行的二次开发/编译的部分需要入库PDM', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (583, '以下哪个软件可以作为开元第三方的选型', 'A. XXXX master\nB. XXXX 1.1.11-beta\nC. XXXX.3..19\nD. XXXX.1.1.12rc2', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (584, '关于开源使用，一下描述或做法不正确的是', 'A. 客户要求使用开源软件新版本，产品A集成使用的开源软件B近3年无人维护且无可代替软件，产品A将该开源软件B及修改的代码在GitHub以新项目C开源并自行维护，再将开源软件C集成到产品A中使用。\nB. 产品A使用的开源软件被爆出存在严重漏洞(CVSSL>7)，产品A的安全SE分析发现该漏洞涉及的代码产品A未调用，可以不需要对产品A的现网版本打补丁。\nC. 产品A软件开发人员在编写代码时，拷贝Apache license 2.0的XXC++开源软件中的排序算法实现代码，以提升开发效率。\nD. 某产品共130K行代码，其中仅10行diamante与开源代码相似度较高；该10行代码可以确认为自研代码。\nE. 开源软件的选用，是产品在需求分析和架构设计时决定的；产品需基于全量全视角视图管理产品和平台使用的开源及第三方软件，确保使用的开源及第三方版本归一和满足生命周期需求。', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (585, '关于开源使用，下列说法错误的是', 'A. 产品A自研开发且对外开源XXComb软件，并捐献到Apache基金会成为顶级项目，产品B选用社区XXComb软件，仍应认定XXComb软件为自研软件。\nB. 某产品开发一款仅给内部一线行销员工使用的APP（必须华为员工账号才能使用），并上架华为手机应用市场供一线行销人员下载，该APP通过静态链接方式集成使用了一款AGPL开源软件，由于只是内部一线行销员工使用，可以不需要履行开源义务。\nC. 某员工在业余时间以个人名义，在GitHub开源了X项目；该员工在公司办公环境下载该X项目代码集成到产品A中使用，产品A不需要履行开源义务。\nD. 公有云服务产品A通过静态链接的方式集成使用了license为GPL V2.0的开源软件，服务产品A可以不履行代码开源义务。', 'ABCD', '解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (586, '有关第三方软件引入的评估标准，正确的是', 'A. 已EOSS/即将停止销售的第三方软件不建议引入\nB. 业界无替代的第三方软件，可能存在供应风险，不建议引入\nC. 未签署供应商网络安全协议的软件禁止引入\nD. 供应商发布的软件正式版本，可以引入', 'BC', '解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (587, '在业务版本发布前，对于版本中的开源及第三方软件的网络安全要求，以下描述正确的有', 'A. 为保证来源可靠，业务版本使用的开源及第三方软件必须来自保存在华为PDM库中的软件副本\nB. A类红线和高风险(CVSS评分>=7)的B类红线问题在版本发布前解决或规避，中低风险(CVSS评分<7)的B类红线问题则可待供应商/合作方修复后再同步其修复版本\nC. 非A/B类红线安全问题，如果是高风险的安全问题则在版本发布前解决或规避，如果是中低风险的安全问题可待供应商/合作方修复后再同步其修复版本\nD. 在业务版本的研发过程中，开源及第三方软件需随产品代码一起开源产品网络安全测试', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (588, '产品A计划选择一款加密算法软件，实现主控板从上电到启动过程中对比加载文件和芯片中保存的文件是否一致，当不一致时则禁止单板启动，并告诉用户，以下选型不建议的是', 'A. 若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程（需开源），通过隔离层进行交互\nB. 在内核态中对Linux kernel进行调用，以避免GPL传染\nC. 可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互\nD. 以动态链接的方式使用GPL软件，使产品代码不会被GPL传染', 'DE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (589, '产品计划引入选型OpenSSL软件，下列说法正确的是', 'A. 修改的OpenSSL软件源码如果得到作者的认可，产品可以不用回馈社区直接引入选型OpenSSL\nB. 从官网下载OpenSSL源码太麻烦，可以直接使用git命令下载github上的openssl源码\nC. openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入\nD. 可以从任意网站下载OpenSSL源码包，只要扫描不出病毒', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (590, '下面关于开源软件代码修改说法正确的是', 'A. 产品P引入XX开源软件，工程师小A分析&应用后认为将XX软件的其中几个接口再重新封装成新接口，可以更好支撑业务，于是小A在XX软件代码文件中新增一个功能接口，并且归档到开源软件目录支撑产品编译发布\nB. 产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，将开源软件归到开源代码目录，并通过部分编译的形式，仅编译需要的特性进行打包发布\nC. 产品P引入XX开源软件，工程师小A分析&应用后认为需要对开源代码进行少量修改才能满足产品需求，通过团队架构评审等确认后，将修改代码以Patch的方式进行管理\nD. 产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，于是将其它特性代码删除后，归档到开源代码目录支撑产品编译发布', 'BC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (591, '针对FOSSID上扫描出来的，和开源相似的代码，是否可以确认为自研，判断原则是什么', 'A. 判断原则是基于工具，如果FOSSID无法扫描出来，则都是自研代码\nB. 判断原则是基于事实，没看过开源代码的人写出来的东西叫自研，其他任何形式直接参考开源写的代码都算开源\nC. 判断原则是基于目录结构，自研目录下的都是自研代码，open_source目录下都是开源软件\nD. 判断原则是相似度，如果相似度很低，如低于5%可以判断为自研', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (592, '某CT产品3年前从供应商购买的一款第三方软件X，并在产品V1R1C00软件版本中配套A01单板使用。目前现网V1R1C01版本存量大，客户反馈较稳定，产品准备新立项V1R4C00版本，发现第三方软件X存在新版本，并且新版本也兼容A01单板，但切换测试成本较大，同时该软件版本标准维保即将到期，但供应商表示可以为华为单独提供延长维保服务，根据第三方软件生命周期规则，产品应该采取的策略是', 'A. 切换第三方版本X的新版本，确保能享受供应商完整的保障能力\nB. 由于不是新产品，不考虑升级第三方软件X新版本\nC. 考虑测试成本，通过购买供应商延长维保服务，继续使用X的老版本\nD. 由于架构未调整，不考虑升级第三方软件X新版本', 'A', '解析：b8299143 chooses C whereas others(b8302521, b8338303, b8395535, b8214821, b8194499, b8186353, b8194499) chooseA', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (593, '为了有效支撑事后审计，并向内部、外部客户证明研发过程风险是可控的，须准确记录所有参与软件研发环节的相关人员的信息和其交付件的信息，保证获取的上下游信息准确，需跟踪和记录的研发过程阶段有', 'A. 软件编码与构建\nB. 需求分析与设计\nC. 现网部署\nD. 验证发布', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (594, '为了促进开源回馈被社区接纳，下述哪个行为不值得推荐', 'A. 在社区邮件列表/issue列表里充分交流提交的方案，并根据意见反复修改\nB. 在社区线下会议上介绍自己的方案，赢得社区的认可\nC. 和社区维护者进行沟通，理解对方的规划思路\nD. 由于社区一直未采纳提交补丁，自己在社区中fork一个新项目出来维护', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (595, '以下关于开源选型的说法，哪些是正确的', 'A. 铲平A使用一款tinyxml软件，内存分配和解析速度均可满足产品要求，且现网已稳定运行10+年，社区近期发布了tinyxml2，且社区也表示后续主要在tinyxml2上进行维护，其解析速度为tinyxml的5倍，但综合考虑升级成本及新版本的影响，产品确定继续使用tinyxml\nB. Json-lib软件社区2013年后社区已无人贡献，建议产品独臂Jackson、fastJson、Gson等同类软件，结合产品使用场景，选择生态、license较友好的开源软件\nC. XML解析开源软件SAX性能比Dom4j快10倍，SAX 2004年发布最后一个稳定版本，当前平均每周下载量34+次，对性能要求较高，且使用场景为只读不写（xml文件）的产品可以考虑选择此软件\nD. Log4j日志组件的作者2015年发布log4j2.X和logback；性能比log4j1.X高10倍，建议使用log4j1.X的产品考虑切换到log2.X或logback', 'BD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (596, '关于开源义务履行，下面说法错误的是', 'A. 原则上只要使用了开源软件，就需要履行开源使用声明义务。\nB. 代码对外开源义务是值按照开源许可证要求将一定范围内的代码对外开源，开源范围视具体许可证要求的和产品使用具体方式而定。\nC. 修改声明是指公司做出的对修改过的开源软件就修改期间，修改的代码以及修改过的文件做出声明，无强制要求产品执行，但建议产品在修改GPL/LGPL类开源软件时，履行该义务。\nD. 不同许可证的开源代码不存在兼容性问题(如GPL License与BSD License)，只需要申请后即可按规范使用。', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (597, '在进行二进制文件差异消除时，需要根据不同的差异引入原因拟定差异消除方案进行业务功能性能测试，确保差异消除不影响业务功能和性能，下列差异消除方案哪一个是不合适的', 'A. 通过BepKit辅助消除python编译pyc文件时引入的时间差异\nB. 为消除自验代码中时间宏引入的二进制差异，可以选择删除DATE/TIME宏，并测试删除后是否影响业务功能\nC. 对于arj等压缩引入二进制差异的情况，可以通过反解的方式辅助进行差异消除\nD. gcc lto优化引入二进制差异，直接删除lto优化选项消除差异，无需对业务性能进行测试', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (598, '选用开源软件时，需考虑以下哪些方面', 'A. 合法合规\nB. 网络安全风险\nC. 生命周期情况\nD. 开源软件的技术生态', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (599, '关于开源软件常见license的解读正确的是', 'A. BSD类license，如Apache/BSD/MIT等，原则上没有对外开源要求\nB. MPL类软件若无修改，则无需对外开源\nC. GPL软件本身须开源，且具有传染性，与该软件在同一进程中运行的代码都必须对外开源\nD. LGPL软件本身须开源，且具有传染性，与其动态链接部分的代码也必须以LGPL许可开源；静态链接则不被传染', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (600, '某产品进行开源选型时，其中功能、性能等匹配度同属最高的有软件A和软件B，以下做法正确的是', 'A. 假定软件A的License为GPL V2，软件B的License为BSD类，由于GPL V2的License可能导致产品整体被迫开源，而BSD类License商业更为友好，所以推荐使用软件B\nB. 假定软件B的License为LGPL V2，如果选择软件B，为防止自研代码被传染，则只允许动态链接方式使用\nC. 假定软件A的License为MPL类，如果选择软件A，则必须关注修改后对应的开源义务\nD. 假定软件A的License为Apache V2.0，软件B的License为WTFPL，虽然Apache V2.0 License的商业比较友好，但WTFPL的License限制更少，所以建议选择软件B', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (601, '下列关于B+树的说法不正确的是', 'A. B+树通常用于数据库和操作系统的文件系统中\nB. 非叶子节点中的每个索引顼通常只含有对应子树的最大关键字和指向该子树的指针\nC. 在B+树中的所有非叶子节点不仅起到索引的作用，还可以直接在非叶子节点中词到每个关键字对应的value\nD. B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (602, '在任意一颗非空二叉排序树T1中，删除某结点v之后形成二叉排序树T2，再将v插入T2形成二叉排序树T3，下列关于T1与T3的描述中，正确的是', 'A. 若v不是T1的叶节点，则T1与T3可能不同\nB. 若v不是T1的叶节点，则T1与T3相同\nC. 若v是T1的叶节点，则T1与T3不同\nD. 若v是T1的叶节点，则T1与T3相同', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (603, '栈的入栈顺序为1、2、3、...、N，在入栈过程中随机出栈随机序列，若第一个元素是 i，则第 j 个出栈元素是', 'A. j-i+1\nB. i-j\nC. i-j-1\nD. 不确定', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (604, '以下哪个说法是正确的', 'A. 顺序表插入变动的时间复杂度为O(n)\nB. 顺序表按下表查找的时间复杂度为O(1)\nC. 顺序表在使用时，长度可随意变动\nD. 顺序表存储空间连续，即允许元素的随机访问', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (605, '对于下列关键字序列，不可能构成某二叉排序树中一条查找路径的序列是', 'A. 92,20,91,34,88,35\nB. 12,25,71,68,33,34\nC. 21,89,77,29,36,38\nD. 95,22,91,24,94,71', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (606, '已知一颗完全二叉树的第8层（设根为第1层）有10个叶节点，则该完全二叉树的节点个数可能有', 'A. 329\nB. 137\nC. 201\nD. 491', 'BD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (607, '无向图G有12条边，6个3度定点，其余定点的度均小于3，则G中可以有', 'A. 9\nB. 10\nC. 11\nD. 8', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (608, '已知一棵二叉树，如果先序遍历的节点顺序是 KDCEFGHB, 中序遍历是 CDFEGHKB, 则后序遍历的结果为', 'A. CFHGEBDK\nB. CDFEGHBK\nC. FGHCDEBK\nD. CFHGEDBK', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (609, '一个栈的入栈顺序是abcde，则不可能的出栈顺序是', 'A. edcba\nB. decba\nC. dceab\nD. abcde', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (610, '元素a,b,c,d,e,f,g依次放入一个初始为空的栈中，若元素进栈后可以立即出栈，也可停留，直到所有元素都出栈，出栈顺序为b,d,c,f,e,a,g，则栈容量最小为多少', 'A. 2\nB. 1\nC. 3\nD. 6', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (611, '假设有四个队列Q1、Q2、Q3、Q4，容量无限大。Q1是原始队列，其中有四个元素：a、b、c、d；Q2和Q3是中转队列；Q4是目标队列。现在要将原始队列中的元素经过一个或者多个中间队列中转后存入目标队列（中转的意思是说原始队列每个元素出队后入队到中间队列，原始队列全部出队后，再从中间队列出队并入队到目标队列）下列哪些序列是目标可能出现的？', 'A. a、b、c、d\nB. d、b、c、a\nC. d、c、b、a\nD. a、c、b、d', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (612, '一个链队列，头尾指针分别为front和rear，在进行出队操作时', 'A. 仅修改队头指针\nB. 仅修改队尾指针\nC. 队头、队尾指针都要修改\nD. 队头、对位指针可能都要修改', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (613, '如果一颗非空的二叉树的前序遍历结果与后序遍历结果正好相反，则该二叉树一定满足', 'A. 所有的结点均无左孩子\nB. 所有的结点均无右孩子\nC. 只有一个叶子结点\nD. 是任意的一颗二叉树', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (614, '对快速排序算法，在最差的情况下，它的时间复杂度的递归公式和时间复杂度是', 'A. T(n) = T(n/10) + T(9n/10) + O(n) 和 O(nLogn）\nB. T(n) = 2T(n/2) + O(n) 和 O(nLogn)\nC. T(n) = T(n-1) + O(n) 和 O(n^2)\nD. T(n) = T(n-2) + O(n) 和 O(n^2)', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (615, '递归以下说法正确的是', 'A. 在函数中直接调用自己成为函数的直接递归调用\nB. 递归是一种分而治之、将复杂问题转换成简单问题的求解方法\nC. 递归可以使编写的程序简洁、结构清晰\nD. 在使用递归时，可以无限递归下去，不需要考虑其他因素\nE. 函数f1调用了函数f2又再次调用了函数f1，这种调用的方式我们称之为间接递归调用', 'ABCE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (616, 'DevOps新型研发模式的目的', 'A. 促进研发（应用程序/软件工程）、技术运营（运维）部门之间的沟通、协作与整合，持续交付可靠的软件产品和服务。\nB. DevOps是以业务驱动的软件交付方法。从需求到交付生产环境，研发与运维间紧密协的文化运动与实践。\nC. DevOps文化更注重沟通，快速获得用户反馈提升创新能力。\nD. 开发和运营关注点和目标不匹配，业务交付模式需要独立开展以提高效率', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (617, 'SCRUM是以短周期迭代为核心，包含团队、工作件、管理和技术优秀实践的集合，Sprint事件包括', 'A. 产品Backlog\nB. 冲刺\nC. 计划\nD. 每日站会\nE. 评审会议\nF. 回顾会议', 'BCDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (618, '下面的描述中，哪些属于敏捷宣言的主要内容', 'A. 个体与交互重于过程和工具\nB. 可工作的软件重于完备的文档\nC. 客户协作重于合同谈判\nD. 响应变更重于遵循计划\nE. 计划驱动，阶段分离，顺序执行', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (619, '在敏捷开发模式中，Scrum Master角色的主要作用包括', 'A. 负责确保Scrum被理解并实施\nB. 按需推动Scrum事件\nC. 有权要求团队做事以及改变列表条目优先级\nD. 担当教练角色， 引领团队达到更高级的凝聚力、自组织和表现', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (620, 'SCRUM框架的工件包括', 'A. 开发文档\nB. 产品Backlog\nC. SprintBacklog\nD. 产品增量', 'BCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (621, 'SCRUM框架的关键角色包括', 'A. 产品负责人(Product Owner)\nB. Scrum Master\nC. 开发团队\nD. 软件工程师', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (622, '瀑布式模型的优缺点描述正确的是', 'A. 模型简单过程易于理解\nB. 交付周期长\nC. 反馈周期短\nD. 无法应对需求快速变化的场景和领域', 'ACD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (623, '下面关于系统之系统描述错误的是', 'A. 系统之系统中的系统的不同部分可分别对应不同的管理和控制策略和规则\nB. 系统之系统中并不存在一个对系统各个部分进行管理的管理者\nC. 系统之系统是两个或以上独立管理和治理的系统的集合\nD. 系统之系统不可能是最小规模系统，如包含不同提供商提供的服务的较小的系统，大规模系统经常是系统之系统\"', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (624, '关于软件工程，以下说法错误的是', 'A. 软件工程发展的目的就是希望找到合适的方法和技术适用软件系统\nB. 软件工程仅指实现软件生产开发的活动序列\nC. 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科，它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式灯方面\nD. 软件工程的目的是支持专业化的软件开发、而不仅仅是个人编程', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (625, '某电商公司的网站的部署周期（需求提出到部署产品环境的时间）为4周（工作日20天），其中需求分析3天，开发时间为5天，测试人员手动进行功能测试时间为6天，环境准备和部署时间为4天，该公司为了提升自身竞争力，目标在半年内将部署周期降低到2周，以下哪些DevOps时间可以帮助该公司实现目标', 'A. 功能测试自动化\nB. 自动化部署\nC. 软件开发过程引入敏捷、精益思维，最小化需求范围(MVP)\nD. 微服务拆分', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (626, '面向服务的方法的好处', 'A. 服务提供商会公开服务的信息，任何获得授权的用户都可以使用相应服务\nB. 组织内部或外部的服务提供商都可以提供服务\nC. 服务的用户能根据使用而不是提供商提供的服务来付费\nD. 应用能够延迟服务绑定直到这些服务被部署或执行', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (627, '当一个企业不得不支持许多相似但不完全相同的系统时，最有效的一种复用方法是', 'A.软件产品工程SPLE\nB.分布式系统\nC.应用框架\nD.应用系统复用', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (628, '关于软件开发和维护工作，以下说法错误的是', 'A. 软件交付的主要工作是将程序代码和相关文档交给用户\nB. 持续集成是频繁持续地将团队成员的工作进行集成\nC. 用户培训是帮助用户理解产品并掌握系统的使用和操作\nD. 软件部署是通过配置、安装和激活等活动保证软件系统的正常运行', 'B', '解析：持续集成是一个将集成提前至开发周期早期阶段的软件开发实践方式，是指软件个人研发部分向软件整体部分交付，让构建、测试和集成代码更经常性地发生，并且每次集成都要通过自动化的构建来验证，使集成错误尽早被发现。', '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (629, '下面正确地描述了SaaS和SOA的是', 'A. SaaS和SOA本质都是基于服务的思想，只是说法不同\nB. SaaS必须以SOA技术为基础\nC. SaaS环境下考虑可伸缩模型时，我们一般采用增强扩展，SOA技术能很好地支持增强扩展\nD. SaaS是向用户交付应用功能的方法，而SOA是应用系统的一种设计技术', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (630, '以下哪一项不属于工程化软件开发所面临的根本性困难', 'A. 软件是庞大的逻辑产品\nB. 软件开发工具所提供的开发支持弱\nC. 软件的复杂程度高\nD. 软件系统的问题空间和解空间之间的巨大鸿沟', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (631, '下面描述正确或分析方法正确的是', 'A. 可以使用gcore输出进程的运行coredump快照作分析\nB. 两个线程可能发生了互锁\nC. 可以attach到进程，查看两个std::mutex的_owner信息，是否为对方线程ID\nD. 两个线程可能同时在访问一个锁', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (632, 'GCC安全编译选项-fstack-protector-all的作用有哪些', 'A. GCC安全编译选项-fstack-protector-all的作用有哪些\nB. 在栈顶插入一个随机数防止栈溢出\nC. 设置栈为代码不可执行\nD. 将字符串数组调整到栈的高地址\nE. 在栈底插入一个随机数防止栈溢出', 'DE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (633, '下面哪些选项是IPD中要求使用gcc编译器必须开启的编译选项', 'A. -fPIC\\-fPIE\nB. -fstack-protector-all 栈溢出保护\nC. -Wl,-z,relro          保护got表 - 部分重定向只读\nD. -Wl,-z,noexecstack    堆+栈不可执行\nE. -z,now                保护got表 - 全部重定向只读\nF. -ftrapv', 'ABCDE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (634, '攻击者通过逆向分析可执行程序或动态库，获取程序运行过程，下面哪个选项可以删除可执行程序或动态库的符号表信息，提高逆向分析的难度', 'A.-Wpointer-arith\nB.-s\nC.-ftrapv\nD.-Wl,-z,relro', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (635, '以下关于-Wl,-z,noexecstack选项描述正确的是\nA．可有效提高缓冲区溢出的难度，但仍可以被ret2lib、rop等攻击绕过\nB．只能保护栈的不可执行\nC．不能保护数据段的不可执行\nD．可以保护堆的不可执行\n1、 链接选项-Wl, --disable-new-dtags,-rpath [path]阻止LD_Library_PATH攻击的原理是什么(A)', 'A. 设置程序启动时优先加载[path]路径下的共享库\nB. 设置只有[path]路径下的动态库才允许被加载\nC. 设置程序启动时优先加载[path]路径下的静态库\nD. 设置[path]路径没有代码可执行权限', 'AD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (636, 'GCC安全编译选项-fstack-protector-all的作用有哪些', 'A. 将字符串数组调整到栈的低地址\nB. 在栈顶插入一个随机数防止栈溢出\nC. 设置栈代码为代码不可执行\nD. 将字符串数组调整到栈的高地址\nE. 在栈底插入一个随机数防止栈溢出', 'DE', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (637, '如下关于编译构建环境的说法，哪些是正确的', 'A. 构建环境上的工具，可以由CIE从公司外网下载直接安装。\nB. 每一次构建成功后，都应该记录生成的版本包和构建环境镜像的关联关系,方便以后溯源。\nC. 为了方便开发人员定位构建问题，构建环境应该对所有开发者开放。\nD. 版本发布构建所用的环境，应该是封闭的，只能有任命的CIE可以访问环境。', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (638, '对于构建一致性的必要性和要求，说法正确的有', 'A. 基于相同源码、环境、生产与客户现网部署逐比特一致的二进制\nB. 随机差异要全部消除，除非能准确知晓这些差异的内容\nC. 随机差异优先消除，时间差异太大时没必要消除\nD. 交付源码和二进制要保持一致', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (639, '某产品在进行源码交付时被认证机构认定为所集成的A平台源码无法溯源，经过确认发现了根源，产品经理小强通过文件夹共享方式获取到A平台的联调版本并集成了该版本，A平台二进制对应的源码信息未做基线，产品在正式发布版本仍然使用A平台该联调版本，源码交付后，认证机构经过验证发现A平台源码缺失，上述行为违背了哪些配置管理原则', 'A.A平台二进制及源码没有进行配置标识及基线，导致源码缺失\nB.产品正式发布的版本应配套使用A平台的正式发布版本，不应使用A平台的联调版本\nC.联调版本没有通过联调版本发布流程发布，而是通过文件共享方式私下进行传递\nD.具备在任意时刻都能交付二进制对应的准确源代码的能力', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (640, '按照二进制文件的差异现象，可以将差异分为时间戳差异和随机差异，时间戳差异表现为各种形式的时间信息，下列哪些场景属于时间戳差异', 'A. 其他自定义格式：1990+月-日-天-小时-分-秒的偏移量\nB. 构建时刻距离1970/01/01秒数\nC. \"NOV1,2016，21：04：16“字符串\nD. “20170304180056\"字符串', 'ABCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (641, '以下哪些是链接选项', 'A. -Fpic\nB. -Wl,-z,relro\nC. -pie\nD. -Wl,-z,noexecstack', 'BCD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (642, '下面关于-fPIC和-fPIE -pie选项描述正确的是', 'A. 两者作用相似可以互相替换\nB. -fPIC是编译选项\nC. -fPIE -pie用于可执行程序\nD. -fPIC用于静态库', 'BC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (643, '关于工程构建，以下说法错误的是', 'A. 允许使用-w选项屏蔽所有告警\nB. 使用虚拟化OS工具在Windows上来模拟Linux进行构建\nC. 构建输出的日志简洁明晰，信息应分级为error/warning/info；出现error信息表示构建失败，必须终止构建\nD. 构建模块较多时，对于子模块私有的配置，可以在模块内定义config.xml作为子模块的配置', 'ABD', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (644, '有关构建脚本，下列说法正确的是', 'A. 构建脚本必须使用相对路径，禁止使用绝对路径\nB. 构建脚本成功返回0；构建失败，应以非0的退出码退出\nC. 每个文件开头包含一个注释，简要概述文件源代码的功能、版权声明\nD. 产品软件构建脚本语言智能选择一种，推荐Python', 'ABC', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'MULTI_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (645, '关于过载控制设计原则，下列说法错误的是', 'A.自保恢复原则：负荷下降到设计能力范围之内后，网元可以立即恢复处理能力\nB.业务保证原则：确保在出现大流量冲击时所有业务不被丢弃\nC.及早控制原则：应尽可能在业务流程处理前端或业务处理较早的处理单元（网元/单板/芯片等）或底层协议层次上控制业务接入\nD.优先级保证原则：系统过载时保证高优先级的业务能够优先获得资源，优先得到处理', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (646, '以下描述关于网络韧性工程的架构/技术的描述错误的是', 'A.非持久性是在有限的时间内保留信息、服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会\nB.权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配给用户和网络实体的权限，以最大限度的减少对手活动的潜在后果\nC.多样性使用异构技术（例如 硬件、软件、固件、协议），这样增加了网络建设的成本，运维的难度，是不可取的\nD.分割可以根据系统的重要级别进行划分，以限制成功攻击的传播或损害', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (647, '关于冗余设计，下面说法错误的是', 'A.主用单元和备用单元的故障检测率都直接影响冗余系统可用度\nB.系统的冗余设计是硬件独立完成的，与软件关系不大\nC.电信产品要求具备高可用性，但同时也需要考虑成本等多方面的因素，所有冗余设计并不是使用的越多越好\nD.资源池冗余设计中要考虑负载均衡', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (648, '以下哪一条是软件选课系统的质量需求，并且满足原子性要求？', 'A.用户规模不超过5千人时，登录密码验证时间不超过2秒，用户规模不超过2万人时，登录密码验证不超过5秒\nB.课程属性与学生专业属性不符时不允许选课\nC.系统应当在2018年9月1日之前上线部署运行\nD.系统可按照院系统计学生选课请款个，指定统计范围后1秒内返回统计结果', 'A', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (649, '某公司产品开发人员，功能实现时预留后门，在特定场景下可以绕过支付机制获利，并成功在商用版本中发布，可以通过哪项活动避免该问题出现', 'A.威胁建模\nB.软件包完整性保护\nC.设计架构审查\nD.代码检视', 'D', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (650, '基于威胁建模的测试设计方法需要在安全测试活动中哪个阶段使用？', 'A.动态分析和Fuzz测试\nB.测试方案设计\nC.总体测试策略\nD.静态分析', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (651, 'FMEA(Failure Mode and Effects Analysis)是一种可靠性分析方法，FMEA分析过程中，我们常说的补偿措施，不包括以下哪个选项（）', 'A.通过负荷分担保护业务\nB.主备单板倒换\nC.现场更换单板\nD.自动复位单板', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (652, '关于“开放设计安全原则”，下面描述不正确的是（）', 'A.涉及加密算法选择时，多使用业界公开标准的成熟算法，而不要设计私有的，自以为安全可靠的算法\nB.设计不应该是秘密的，不应依赖对设计和实现的保密，以及攻击者的无知\nC.加密秘钥要公开开放\nD.密钥禁止硬编码', 'C', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);
INSERT INTO `question` VALUES (653, '关于故障预测预防技术，以下说法错误的是（）', 'A.通过故障预测预防，用户可以根据故障出现的概率以及出现的位置，采取相应的手段提前避免这些有可能出现的故障\nB.故障预测预防是一种被动故障处理技术\nC.故障预测预防技术是一种有效的主动故障处理技术\nD.故障预测可以在系统故障出现之前，通过分析系统的状态得到故障可能出现的概率以及出现的故障种类', 'B', NULL, '可信认证科目三整理 - 王凯凯的博客', NULL, '科目3', 'SINGLE_CHOICE', 1, 1, 1, 0, 0, 0);

SET FOREIGN_KEY_CHECKS = 1;
