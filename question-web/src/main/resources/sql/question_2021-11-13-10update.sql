UPDATE option_info  SET context='反射可以获取注解（@Target为Runtime）信息；',selected=0,parsing='A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法\nB:通过getMethods能获取方法并使用invoke进行调用\nC:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置\nD:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值\n故选择：CD',remark='C',question_id=1  WHERE id=5;
UPDATE option_info  SET context='反射能够直接get(obj)获取私有的Field成员的值；',selected=0,parsing='A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法\nB:通过getMethods能获取方法并使用invoke进行调用\nC:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置\nD:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值\n故选择：CD',remark='D',question_id=1  WHERE id=6;
UPDATE option_info  SET context='运行时出现异常',selected=0,parsing='运行时list.add(2, \"str2\");报错，因为ArrayList在添加前会调用rangeCheckForAdd方法判断当前索引是否大于了当前数组的size一句话list.add(2, \"str2\")只能替换不能追加',remark='D',question_id=2  WHERE id=10;
UPDATE option_info  SET context='空行不是代码，所以代码中多写几个空行没有关系；',selected=0,remark='C',question_id=3  WHERE id=13;
UPDATE option_info  SET context='java.io.FileNotFountException',selected=0,remark='A',question_id=4  WHERE id=15;
UPDATE option_info  SET context='ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；',selected=0,remark='A',question_id=5  WHERE id=19;
UPDATE option_info  SET context='若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。',selected=0,parsing='D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了',remark='D',question_id=6  WHERE id=26;
UPDATE option_info  SET context='结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640',selected=0,parsing='D:看来权限是给高了，个人感觉是不是600就可以了',remark='D',question_id=7  WHERE id=30;
UPDATE option_info  SET context='transient',selected=0,remark='D',question_id=8  WHERE id=34;
UPDATE option_info  SET context='某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字',selected=0,remark='D',question_id=9  WHERE id=38;
UPDATE option_info  SET context='32位',selected=0,parsing='D:long类型在不同的操作系统才有区别',remark='A',question_id=10  WHERE id=39;
UPDATE option_info  SET context='char ch = 1;（char可以容纳的数字范围是多少）',selected=0,remark='D',question_id=11  WHERE id=46;
UPDATE option_info  SET context='345',selected=0,remark='A',question_id=12  WHERE id=47;
UPDATE option_info  SET context='Exception',selected=0,remark='B',question_id=13  WHERE id=52;
UPDATE option_info  SET context='不允许重复元素，元素无顺序',selected=0,parsing='顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n',remark='D',question_id=14  WHERE id=58;
UPDATE option_info  SET context='Map<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();',selected=0,parsing='D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}',remark='D',question_id=15  WHERE id=62;
UPDATE option_info  SET context='List numList = new ArrayList();\nList intList = new ArrayList();\n因为Integer是Number的子类，所以intList可以赋值给numberList',selected=0,parsing='A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n',remark='B',question_id=16  WHERE id=64;
UPDATE option_info  SET context='synchronized可用于处理读写互斥，读读不互斥的操作场景',selected=0,parsing='A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？',remark='D',question_id=17  WHERE id=70;
UPDATE option_info  SET context='ABCDE',selected=0,remark='D',question_id=18  WHERE id=74;
UPDATE option_info  SET context='反射可以获取注解（@Target为Runtime）信息；',selected=0,parsing='A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法\nB:通过getMethods能获取方法并使用invoke进行调用\nC:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置\nD:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值\n故选择：CD',remark='C',question_id=1  WHERE id=5;
UPDATE option_info  SET context='反射能够直接get(obj)获取私有的Field成员的值；',selected=0,parsing='A:通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法\nB:通过getMethods能获取方法并使用invoke进行调用\nC:没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置\nD:首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值\n故选择：CD',remark='D',question_id=1  WHERE id=6;
UPDATE option_info  SET context='运行时出现异常',selected=0,parsing='运行时list.add(2, \"str2\");报错，因为ArrayList在添加前会调用rangeCheckForAdd方法判断当前索引是否大于了当前数组的size一句话list.add(2, \"str2\")只能替换不能追加',remark='D',question_id=2  WHERE id=10;
UPDATE option_info  SET context='空行不是代码，所以代码中多写几个空行没有关系；',selected=0,remark='C',question_id=3  WHERE id=13;
UPDATE option_info  SET context='java.io.FileNotFountException',selected=0,remark='A',question_id=4  WHERE id=15;
UPDATE option_info  SET context='ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；',selected=0,remark='A',question_id=5  WHERE id=19;
UPDATE option_info  SET context='若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。',selected=0,parsing='D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了',remark='D',question_id=6  WHERE id=26;
UPDATE option_info  SET context='结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640',selected=0,parsing='D:看来权限是给高了，个人感觉是不是600就可以了',remark='D',question_id=7  WHERE id=30;
UPDATE option_info  SET context='transient',selected=0,remark='D',question_id=8  WHERE id=34;
UPDATE option_info  SET context='某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字',selected=0,remark='D',question_id=9  WHERE id=38;
UPDATE option_info  SET context='32位',selected=0,parsing='D:long类型在不同的操作系统才有区别',remark='A',question_id=10  WHERE id=39;
UPDATE option_info  SET context='char ch = 1;（char可以容纳的数字范围是多少）',selected=0,remark='D',question_id=11  WHERE id=46;
UPDATE option_info  SET context='345',selected=0,remark='A',question_id=12  WHERE id=47;
UPDATE option_info  SET context='Exception',selected=0,remark='B',question_id=13  WHERE id=52;
UPDATE option_info  SET context='不允许重复元素，元素无顺序',selected=0,parsing='顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n',remark='D',question_id=14  WHERE id=58;
UPDATE option_info  SET context='Map<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();',selected=0,parsing='D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}',remark='D',question_id=15  WHERE id=62;
UPDATE option_info  SET context='List numList = new ArrayList();\nList intList = new ArrayList();\n因为Integer是Number的子类，所以intList可以赋值给numberList',selected=0,parsing='A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n',remark='B',question_id=16  WHERE id=64;
UPDATE option_info  SET context='synchronized可用于处理读写互斥，读读不互斥的操作场景',selected=0,parsing='A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？',remark='D',question_id=17  WHERE id=70;
UPDATE option_info  SET context='ABCDE',selected=0,remark='D',question_id=18  WHERE id=74;
UPDATE option_info  SET context='如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；',selected=0,parsing='参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。',remark='C',question_id=20  WHERE id=81;
UPDATE option_info  SET context='使得第idx个参数的值设为val',selected=0,parsing='PreparedStatement的索引是从1开始',remark='A',question_id=21  WHERE id=83;
UPDATE option_info  SET context='Selector本身不是一个文件，不用Close',selected=0,parsing='A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭',remark='C',question_id=22  WHERE id=89;
UPDATE option_info  SET context='private int count=0;\nprivate final Integer lock=new Integer(count);\npublic void doSomething(){\n    Synchronized(lock){\n    Count++;\n    }\n}',selected=0,parsing='一句话，锁不要公用，容易阻塞/死锁',remark='A',question_id=23  WHERE id=91;
UPDATE option_info  SET context='class Test {\n​private String userName;\n}',selected=0,parsing='A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对',remark='C',question_id=24  WHERE id=97;
UPDATE option_info  SET context='输出结果不确定',selected=0,parsing='System.out.println(1000000000f == 1000000010f);//true\n应该是float精度问题？？？',remark='C',question_id=25  WHERE id=101;
UPDATE option_info  SET context='boolean isNullsRemoved = names.remove(null);\n  assert isNullsRemoved',selected=0,parsing='没懂A为啥不对',remark='D',question_id=26  WHERE id=105;
UPDATE option_info  SET context='Java的GC机制会选择其中一种方法进行垃圾回收；',selected=0,parsing='A：（看来不同的路线，选择机制还是不一样的）\nB：（这块需要反复计算才可以解决）\nC：（GC的回收过程中多种回收机制一起处理的结果）\nD：（这个缺点是很明显的）\n',remark='C',question_id=27  WHERE id=108;
UPDATE option_info  SET context='URLClassLoader的签名校验依赖jar包里的公钥，因此不能使用URLClassLoader来校验jar的合法性；（里面可能被人修改过，里面是底层的源码）',selected=0,remark='A',question_id=28  WHERE id=110;
UPDATE option_info  SET context='String userName = \"name”;\n  ResultSet rs = st.executeQuery(\"select * from user where name = ‘” + userName + \"’”);\n//该代码可能会产生SQL注入漏洞',selected=0,parsing='B 这题好牵强哦~ 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验',remark='B',question_id=29  WHERE id=114;
UPDATE option_info  SET context='Processor proc=rt.exec(\"cmd.exe /c dir ” + args[0]);',selected=0,parsing='选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入\n选项B：使用正则校验，过滤特殊字符\n选项C：对文件的有效性进行校验\n选项D：无任何校验，可能导致命令注入',remark='D',question_id=30  WHERE id=120;
UPDATE option_info  SET context='可以在代码最外层捕获NullPointException防止代码出现预期之外的行为',selected=0,remark='D',question_id=31  WHERE id=124;
UPDATE option_info  SET context='FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常（这个也是敏感异常）（DOS攻击）',selected=0,remark='A',question_id=32  WHERE id=125;
UPDATE option_info  SET context='使用new出来的Integer实例作为对象的内置锁可能导致死锁',selected=0,parsing='A:-128~127将存入缓存\nB:new出来的好像没有什么问题\nC:这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存\nD:都是用的这两个',remark='B',question_id=33  WHERE id=130;
UPDATE option_info  SET context='flag：读写状态位',selected=0,remark='B',question_id=34  WHERE id=134;
UPDATE option_info  SET context='\\W',selected=0,remark='C',question_id=35  WHERE id=139;
UPDATE option_info  SET context='对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁',selected=0,remark='A',question_id=36  WHERE id=142;
UPDATE option_info  SET context='能用无锁数据结构，就不要用锁',selected=0,remark='B',question_id=36  WHERE id=143;
UPDATE option_info  SET context='能用对象锁，就不要用类锁',selected=0,remark='C',question_id=36  WHERE id=144;
UPDATE option_info  SET context='能锁区块，就不要锁方法体',selected=0,remark='D',question_id=36  WHERE id=145;
UPDATE option_info  SET context='错误流',selected=0,remark='A',question_id=37  WHERE id=146;
UPDATE option_info  SET context='输出流',selected=0,remark='C',question_id=37  WHERE id=148;
UPDATE option_info  SET context='输入流',selected=0,remark='D',question_id=37  WHERE id=149;
UPDATE option_info  SET context='public class GpsLocation implements Serializable {\n    private double from;\n    private double to;\n    private String id;\n    // non-sensitive field\n    // other content\n    private static final ObjectStreamField[] serialPersistentFields = {\n        new ObjectStreamField(\"id\", String.class)\n    };\n}',selected=0,parsing='防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确',remark='B',question_id=38  WHERE id=151;
UPDATE option_info  SET context='.public class GpsLocation implements Serializable {\n    private transient double from;\n    private transient double to;\n    private String id;\n    // non-sensitive field\n    // other content\n}',selected=0,parsing='防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确',remark='D',question_id=38  WHERE id=153;
UPDATE option_info  SET context='public final class Helper {\n    private final int n;\n    public Helper(int n) {\n        this.n = n;\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        Helper h = helper;\n        if (h == null) {\n            synchronized (this) {\n                h = helper;\n                if (h == null) {\n                    h = new Helper(42);\n                    helper = h;\n                }\n            }\n        }\n        return h;\n    }\n}',selected=0,parsing='选项A的private Helper helper = null; 没有加volatile进行修饰，可能线程A和线程B都进入了第一个判断，但是A先获取锁，B被阻塞，A释放后创建了helper对象但是B又能获取锁创建一个新的helper对象违背单例模式原则\n\n选项B在获取锁后重新赋值了h的值类似与volatile通知线程修改副本值，所以即使没有加入volatile修饰也是可行的\n选项C同选项A一样选项\n\nD是饿汉式非懒加载，但是线程安全故选择：BD',remark='B',question_id=39  WHERE id=155;
UPDATE option_info  SET context='public final class Helper {\n    public Helper() {\n    }\n}\nfinal class Foo {\n    private static class Holder {\n        static Helper helper = new Helper();\n    }\n    public Helper getInstance() {\n        return Holder.helper;\n    }\n}',selected=0,parsing='选项A的private Helper helper = null; 没有加volatile进行修饰，可能线程A和线程B都进入了第一个判断，但是A先获取锁，B被阻塞，A释放后创建了helper对象但是B又能获取锁创建一个新的helper对象违背单例模式原则\n\n选项B在获取锁后重新赋值了h的值类似与volatile通知线程修改副本值，所以即使没有加入volatile修饰也是可行的\n选项C同选项A一样选项\n\nD是饿汉式非懒加载，但是线程安全故选择：BD',remark='D',question_id=39  WHERE id=157;
UPDATE option_info  SET context='执行shutdown方法中，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出',selected=0,remark='C',question_id=40  WHERE id=160;
UPDATE option_info  SET context='执行shutdownNow方法后，不能能再往线程池中添加任务，线程池视图停止所有正在执行的线程，不再处理池中等待的任务',selected=0,remark='D',question_id=40  WHERE id=161;
UPDATE option_info  SET context='HashTable',selected=0,remark='B',question_id=41  WHERE id=163;
UPDATE option_info  SET context='Vector',selected=0,remark='C',question_id=41  WHERE id=164;
UPDATE option_info  SET context='5',selected=0,parsing='首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished',remark='A',question_id=42  WHERE id=166;
UPDATE option_info  SET context='finished',selected=0,parsing='首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished',remark='C',question_id=42  WHERE id=168;
UPDATE option_info  SET context='AAB',selected=0,remark='B',question_id=43  WHERE id=171;
UPDATE option_info  SET context='AB',selected=0,remark='D',question_id=43  WHERE id=173;
UPDATE option_info  SET context='File实例封装了指定文件的信息',selected=0,remark='C',question_id=44  WHERE id=176;
UPDATE option_info  SET context='File类位于jav.io包中',selected=0,remark='D',question_id=44  WHERE id=177;
UPDATE option_info  SET context='在频率/周期性的逻辑中更要尽量 避免主动GC的调用',selected=0,remark='A',question_id=45  WHERE id=178;
UPDATE option_info  SET context='在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险（说的有道理）',selected=0,remark='B',question_id=45  WHERE id=179;
UPDATE option_info  SET context='如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间',selected=0,remark='D',question_id=45  WHERE id=181;
UPDATE option_info  SET context='在对不可信数据进行校验时，禁止使用assert语句（）',selected=0,remark='A',question_id=46  WHERE id=182;
UPDATE option_info  SET context='\"白名单\"方式净化的方式包括删除，编码 ，替换',selected=0,remark='B',question_id=46  WHERE id=183;
UPDATE option_info  SET context='\"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新 ，该校验方式就会很快过时',selected=0,remark='C',question_id=46  WHERE id=184;
UPDATE option_info  SET context='尽可能使用接收一直合法数据的白名单策略（这个我是记得的）',selected=0,remark='D',question_id=46  WHERE id=185;
UPDATE option_info  SET context='扩展类Thread',selected=0,remark='A',question_id=47  WHERE id=186;
UPDATE option_info  SET context='实现Runnable接口',selected=0,remark='B',question_id=47  WHERE id=187;
UPDATE option_info  SET context='攻击者可以使用实现计算好的哈希列表在几秒钟之内破解口令',selected=0,parsing='C:hash不可逆',remark='A',question_id=48  WHERE id=190;
UPDATE option_info  SET context='加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加',selected=0,parsing='C:hash不可逆',remark='B',question_id=48  WHERE id=191;
UPDATE option_info  SET context='由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候（难道是有什么规律吗）',selected=0,parsing='C:hash不可逆',remark='D',question_id=48  WHERE id=193;
UPDATE option_info  SET context='ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包',selected=0,remark='A',question_id=49  WHERE id=194;
UPDATE option_info  SET context='AppClassLoader负责加载当前应用classpath下的所有jar包和类',selected=0,remark='B',question_id=49  WHERE id=195;
UPDATE option_info  SET context='BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定 的路径中的所有类',selected=0,remark='C',question_id=49  WHERE id=196;
UPDATE option_info  SET context='方法抛出的异常，应该与本身的抽象层次相对应',selected=0,remark='B',question_id=50  WHERE id=199;
UPDATE option_info  SET context='对可容错处理的情况使用受检异常，对编程错误使用运行时异常',selected=0,remark='C',question_id=50  WHERE id=200;
UPDATE option_info  SET context='一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中年记录每个抛出的异常及其条件',selected=0,remark='D',question_id=50  WHERE id=201;
UPDATE option_info  SET context='程序代码编译时',selected=0,parsing='程序代码编译时确定',remark='A',question_id=51  WHERE id=202;
UPDATE option_info  SET context='int[] hello2 = new int[4] {1,2,3,4};',selected=0,remark='B',question_id=52  WHERE id=206;
UPDATE option_info  SET context='Integer b = Integer.valueOf(“2”);',selected=0,parsing='解析：\nInteger.valueOf(value)在-128~127间，则会重用内存中缓存的对象',remark='B',question_id=53  WHERE id=210;
UPDATE option_info  SET context='BigInteger',selected=0,parsing='和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。',remark='C',question_id=54  WHERE id=213;
UPDATE option_info  SET context='java.io.FileNotFoundException',selected=0,parsing='',remark='A',question_id=55  WHERE id=215;
UPDATE option_info  SET context='java.net.BindException',selected=0,parsing='',remark='B',question_id=55  WHERE id=216;
UPDATE option_info  SET context='java.util.ConcurrentModificationException',selected=0,parsing='',remark='C',question_id=55  WHERE id=217;
UPDATE option_info  SET context='java.sql.SQLException',selected=0,parsing='',remark='D',question_id=55  WHERE id=218;
UPDATE option_info  SET context='Map',selected=0,remark='D',question_id=56  WHERE id=224;
UPDATE option_info  SET context='错误',selected=0,remark='B',question_id=57  WHERE id=226;
UPDATE option_info  SET context='FileChannel',selected=0,parsing='http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png',remark='D',question_id=58  WHERE id=230;
UPDATE option_info  SET context='结尾插入数据采用.APPEND而不是 .CREATE',selected=0,remark='E',question_id=59  WHERE id=235;
UPDATE option_info  SET context='stream 流跟迭代器一样，使用完再次使用时需要重新生成',selected=0,remark='B',question_id=60  WHERE id=237;
UPDATE option_info  SET context='private String userName;',selected=0,remark='C',question_id=61  WHERE id=242;
UPDATE option_info  SET context='DES',selected=0,parsing='\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD',remark='B',question_id=62  WHERE id=245;
UPDATE option_info  SET context='MD5',selected=0,parsing='\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD',remark='D',question_id=62  WHERE id=247;
UPDATE option_info  SET context='java.io.FileNotFoundException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='A',question_id=63  WHERE id=248;
UPDATE option_info  SET context='java.util.jar.JarException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='B',question_id=63  WHERE id=249;
UPDATE option_info  SET context='java.util.MissingResourceException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='C',question_id=63  WHERE id=250;
UPDATE option_info  SET context='java.security.acl.NotOwnerException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='D',question_id=63  WHERE id=251;
UPDATE option_info  SET context='java.util.ConcurrentModificationException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='E',question_id=63  WHERE id=252;
UPDATE option_info  SET context='javax.naming.InsufficientResourcesException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='F',question_id=63  WHERE id=253;
UPDATE option_info  SET context='java.net.BindException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='G',question_id=63  WHERE id=254;
UPDATE option_info  SET context='java.lang.OutOfMemoryError',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='H',question_id=63  WHERE id=255;
UPDATE option_info  SET context='java.lang.StackOverflowError\nO java.sql.SQLException',selected=0,parsing='A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举',remark='I',question_id=63  WHERE id=256;
UPDATE option_info  SET context='private',selected=0,remark='A',question_id=64  WHERE id=257;
UPDATE option_info  SET context='final',selected=0,remark='C',question_id=64  WHERE id=259;
UPDATE option_info  SET context='abc@host.com',selected=0,remark='A',question_id=65  WHERE id=261;
UPDATE option_info  SET context='abc_@host.com',selected=0,remark='B',question_id=65  WHERE id=262;
UPDATE option_info  SET context='abc@host.org.com',selected=0,remark='C',question_id=65  WHERE id=263;
UPDATE option_info  SET context='abc_@host+com',selected=0,remark='D',question_id=65  WHERE id=264;
UPDATE option_info  SET context='Java.lang.OutOfMemoryError',selected=0,remark='A',question_id=66  WHERE id=265;
UPDATE option_info  SET context='Java.lang.StackOverflowError',selected=0,remark='B',question_id=66  WHERE id=266;
UPDATE option_info  SET context='javax.naming.InsufficientResourcesException',selected=0,remark='C',question_id=66  WHERE id=267;
UPDATE option_info  SET context='A 65',selected=0,parsing='参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理',remark='C',question_id=67  WHERE id=271;
UPDATE option_info  SET context='sun zhao qian',selected=0,parsing='在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段',remark='C',question_id=68  WHERE id=275;
UPDATE option_info  SET context='RSA',selected=0,parsing='安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）',remark='B',question_id=69  WHERE id=278;
UPDATE option_info  SET context='DSA/ECDSA',selected=0,parsing='安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）',remark='C',question_id=69  WHERE id=279;
UPDATE option_info  SET context='加入盐值的SHA256',selected=0,parsing='安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）',remark='D',question_id=69  WHERE id=280;
UPDATE option_info  SET context='CSRF',selected=0,parsing='有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n',remark='A',question_id=70  WHERE id=282;
UPDATE option_info  SET context='XSS',selected=0,parsing='有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n',remark='C',question_id=70  WHERE id=284;
UPDATE option_info  SET context='aa:0',selected=0,parsing='这里finally的continue使得catch中的throw e无效了',remark='A',question_id=71  WHERE id=286;
UPDATE option_info  SET context='线程池不再接收新的任务，队列中等待的任务会执行',selected=0,parsing='shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。',remark='D',question_id=72  WHERE id=293;
UPDATE option_info  SET context='Thread.sleep()',selected=0,parsing='在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。',remark='A',question_id=73  WHERE id=294;
UPDATE option_info  SET context='java.nio.channels.SocketChannel的阻塞方法',selected=0,parsing='在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。',remark='C',question_id=73  WHERE id=296;
UPDATE option_info  SET context='Thread.wait()',selected=0,parsing='在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。',remark='D',question_id=73  WHERE id=297;
UPDATE option_info  SET context='staticA',selected=0,parsing='',remark='A',question_id=74  WHERE id=298;
UPDATE option_info  SET context='CONSTANT',selected=0,parsing='',remark='B',question_id=74  WHERE id=299;
UPDATE option_info  SET context='“i am a string”',selected=0,parsing='',remark='C',question_id=74  WHERE id=300;
UPDATE option_info  SET context='innerA',selected=0,parsing='',remark='D',question_id=74  WHERE id=301;
UPDATE option_info  SET context='动态链接',selected=0,parsing='',remark='A',question_id=75  WHERE id=302;
UPDATE option_info  SET context='局部变量表',selected=0,parsing='',remark='B',question_id=75  WHERE id=303;
UPDATE option_info  SET context='操作数栈',selected=0,parsing='',remark='C',question_id=75  WHERE id=304;
UPDATE option_info  SET context='方法返回地址',selected=0,parsing='',remark='D',question_id=75  WHERE id=305;
UPDATE option_info  SET context='JITTest.doubleIndex被内联',selected=0,parsing='默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行',remark='A',question_id=76  WHERE id=306;
UPDATE option_info  SET context='JITTest.doubleIndex会被编译成机器码执行',selected=0,parsing='默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行',remark='B',question_id=76  WHERE id=307;
UPDATE option_info  SET context='JITTest.sum会被编译成机器码执行',selected=0,parsing='默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行',remark='C',question_id=76  WHERE id=308;
UPDATE option_info  SET context='反射可以获取注解（@Target为Runtime）信息；',selected=0,parsing='A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器',remark='C',question_id=77  WHERE id=312;
UPDATE option_info  SET context='java 抛出异常',selected=0,parsing='这个暂时记住先。。。',remark='C',question_id=78  WHERE id=316;
UPDATE option_info  SET context='3 1',selected=0,parsing='getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。',remark='B',question_id=79  WHERE id=319;
UPDATE option_info  SET context='Optional.ofNullable(obj)，obj不为null时直接调用Optional.of(obj)',selected=0,parsing='Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象',remark='C',question_id=80  WHERE id=324;
UPDATE option_info  SET context='Optiona.of()可以放置集合或对象。',selected=0,parsing='Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象',remark='D',question_id=80  WHERE id=325;
UPDATE option_info  SET context='私有方法',selected=0,parsing='一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法',remark='A',question_id=81  WHERE id=326;
UPDATE option_info  SET context='456456456\\d 123456 123456',selected=0,parsing='// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);',remark='E',question_id=82  WHERE id=334;
UPDATE option_info  SET context='重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常',selected=0,parsing='A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写',remark='A',question_id=83  WHERE id=335;
UPDATE option_info  SET context='重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类',selected=0,parsing='A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写',remark='C',question_id=83  WHERE id=337;
UPDATE option_info  SET context='声明为final或static的方法不能被重写',selected=0,parsing='A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写',remark='D',question_id=83  WHERE id=338;
UPDATE option_info  SET context='修改日期',selected=0,parsing='',remark='B',question_id=84  WHERE id=340;
UPDATE option_info  SET context='import包应当按照先华为公司，安卓、其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组',selected=0,parsing='建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组',remark='C',question_id=85  WHERE id=345;
UPDATE option_info  SET context='浮点型包装类型建议使用equals或flt.compareTo(another)==0做相等的比较',selected=0,parsing='选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。',remark='D',question_id=86  WHERE id=350;
UPDATE option_info  SET context='class WhoKnows {\n    static String sentence = \"I don\'t know.\";\n    public static void main(String[] args) {\n        String sentence = \"I know!\";\n        System.out.println(sentence);\n    }\n}\n输出\"I know!\"',selected=0,parsing='A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。',remark='B',question_id=87  WHERE id=352;
UPDATE option_info  SET context='Map<String,String> map = new HashMap<>();\nmap.put(\"1\",\"a\");\nmap.put(\"2\",\"b\");\nList<String> list = new ArrayList<>();\nlist.addAll(map.values());\nlist.addAll(Collections.singleton(\"c\"));',selected=0,parsing='A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。',remark='B',question_id=88  WHERE id=355;
UPDATE option_info  SET context='0',selected=0,parsing='传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }',remark='A',question_id=89  WHERE id=358;
UPDATE option_info  SET context='调用SecurityManager执行的安全检查，进行安全检查的方法必须声明为private或final',selected=0,parsing='A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略',remark='C',question_id=90  WHERE id=364;
UPDATE option_info  SET context='[5,7,8,9,6]',selected=0,parsing='注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order',remark='C',question_id=91  WHERE id=368;
UPDATE option_info  SET context='30 200 300',selected=0,parsing='1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准',remark='C',question_id=92  WHERE id=372;
UPDATE option_info  SET context='MaxDirectMemeorySize写满',selected=0,parsing='触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类',remark='A',question_id=93  WHERE id=374;
UPDATE option_info  SET context='永生代（Perm）或Metaspace被写满',selected=0,parsing='触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类',remark='B',question_id=93  WHERE id=375;
UPDATE option_info  SET context='年老代（tenured）被写满',selected=0,parsing='触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类',remark='C',question_id=93  WHERE id=376;
UPDATE option_info  SET context='显示调用System.gc',selected=0,parsing='触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类',remark='D',question_id=93  WHERE id=377;
UPDATE option_info  SET context='java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。',selected=0,parsing='',remark='A',question_id=94  WHERE id=378;
UPDATE option_info  SET context='java.lang.StackOverflowError: 线程栈空间不足',selected=0,parsing='',remark='B',question_id=94  WHERE id=379;
UPDATE option_info  SET context='java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出',selected=0,parsing='',remark='C',question_id=94  WHERE id=380;
UPDATE option_info  SET context='建议子类通过重载扩大方法的可访问性，这样可以拥有更大的访问权限',selected=0,parsing='A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。',remark='B',question_id=95  WHERE id=382;
UPDATE option_info  SET context='使用不可信数据构造格式化字符串时，当转换参数与对应的格式符不匹配时，标准类库会抛出异常，不会造成系统信息泄露或拒绝服务',selected=0,parsing='A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png',remark='A',question_id=96  WHERE id=385;
UPDATE option_info  SET context='尽可能使用“黑名单”策略来接收跨信任边界的数据，而不是使用白名单，白名单校验方式较弱',selected=0,parsing='A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png',remark='C',question_id=96  WHERE id=387;
UPDATE option_info  SET context='对不可信数据校验建议使用断言的方式校验',selected=0,parsing='A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png',remark='D',question_id=96  WHERE id=388;
UPDATE option_info  SET context='非静态的内部类序列化时会隐式的对外部类实例的非transient对象进行序列化',selected=0,parsing='',remark='D',question_id=97  WHERE id=392;
UPDATE option_info  SET context='java.text.Normalizer.normalize()',selected=0,parsing='在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。',remark='D',question_id=98  WHERE id=396;
UPDATE option_info  SET context='临时文件由于会定期被清理掉，所以不用显示的清理临时文件',selected=0,parsing='A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png',remark='A',question_id=99  WHERE id=397;
UPDATE option_info  SET context='java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改',selected=0,parsing='A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png',remark='B',question_id=99  WHERE id=398;
UPDATE option_info  SET context='Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值',selected=0,parsing='A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png',remark='D',question_id=99  WHERE id=400;
UPDATE option_info  SET context='long nl = 4664382371590123456L;\ndouble d2 = (double) nl * 2;',selected=0,parsing='A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：',remark='D',question_id=100  WHERE id=404;
UPDATE option_info  SET context='不建议使用varargs重写使用一个固定长度数组作为参数的方法',selected=0,parsing='',remark='B',question_id=101  WHERE id=406;
UPDATE option_info  SET context='JDK1.5引入Varargs（variable number of arguments）可变数量参数，应该在确实需要操作可变长度的值的序列时使用',selected=0,parsing='',remark='C',question_id=101  WHERE id=407;
UPDATE option_info  SET context='可变参数必须位于最后一项',selected=0,parsing='',remark='D',question_id=101  WHERE id=408;
UPDATE option_info  SET context='方法的参数个数不应超过5个',selected=0,parsing='',remark='A',question_id=102  WHERE id=409;
UPDATE option_info  SET context='构造方法如果参数较多，尽量重用',selected=0,parsing='',remark='B',question_id=102  WHERE id=410;
UPDATE option_info  SET context='避免方法过长，不超过50行（非空非注释）；避免方法的代码块嵌套过深，不要超过4层',selected=0,parsing='',remark='D',question_id=102  WHERE id=412;
UPDATE option_info  SET context='Java 8使用Optional代替null作为返回值或者可能的缺失值;禁止对optional对象赋值为null',selected=0,parsing='',remark='A',question_id=103  WHERE id=413;
UPDATE option_info  SET context='禁止对optional对象赋值/返回为null，或与null比较',selected=0,parsing='',remark='B',question_id=103  WHERE id=414;
UPDATE option_info  SET context='不应该返回Optional<Integer> , Optional<Long> , Optional<Double> ,而用OptionalInt,OptionalLong,OptionalDouble',selected=0,parsing='',remark='C',question_id=103  WHERE id=415;
UPDATE option_info  SET context='不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符',selected=0,parsing='',remark='A',question_id=104  WHERE id=417;
UPDATE option_info  SET context='使用java.nio.charset中的类编码解码字符集',selected=0,parsing='',remark='D',question_id=104  WHERE id=420;
UPDATE option_info  SET context='接口中可包含静态方法和default方法',selected=0,parsing='',remark='A',question_id=105  WHERE id=421;
UPDATE option_info  SET context='接口中属性默认public static final修饰词',selected=0,parsing='',remark='B',question_id=105  WHERE id=422;
UPDATE option_info  SET context='方法已缺省具有public abstract修饰词',selected=0,parsing='',remark='C',question_id=105  WHERE id=423;
UPDATE option_info  SET context='攻击者可以访问受限目录和文件',selected=0,parsing='',remark='A',question_id=106  WHERE id=424;
UPDATE option_info  SET context='攻击者可以篡改系统的任意文件',selected=0,parsing='',remark='B',question_id=106  WHERE id=425;
UPDATE option_info  SET context='攻击可可以恶意删除系统中的文件',selected=0,parsing='',remark='C',question_id=106  WHERE id=426;
UPDATE option_info  SET context='进行正则匹配前，先对匹配的文本的长度进行校验',selected=0,parsing='避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。',remark='A',question_id=107  WHERE id=428;
UPDATE option_info  SET context='在编写正则时，尽量不要使用过于复杂的正则，越复杂越容易有缺陷',selected=0,parsing='避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。',remark='B',question_id=107  WHERE id=429;
UPDATE option_info  SET context='在编写正则时，尽量减少分组的使用',selected=0,parsing='避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。',remark='C',question_id=107  WHERE id=430;
UPDATE option_info  SET context='使用transient定义敏感数据',selected=0,parsing='',remark='A',question_id=108  WHERE id=432;
UPDATE option_info  SET context='使用serialPersistentFields定义非敏感数据',selected=0,parsing='',remark='B',question_id=108  WHERE id=433;
UPDATE option_info  SET context='重新定义Serializable接口的writeObject()、writeReplace()、writeExternal()这些函数，不将包含敏感信息的字段写到序列化字节流中。',selected=0,parsing='',remark='C',question_id=108  WHERE id=434;
UPDATE option_info  SET context='在在序列化与反序列化涉及的writeObject()和readObject()方法中使用安全管理器',selected=0,parsing='',remark='D',question_id=108  WHERE id=435;
UPDATE option_info  SET context='未对程序输入做有效的校验与限制可能会导致zip炸弹攻击、SQL注入、OS命令注入、XML注入以及目录遍历等攻击',selected=0,parsing='',remark='B',question_id=109  WHERE id=437;
UPDATE option_info  SET context='数值运算，建议使用先决条件检查、Math.*Exact()方法、向上类型转换等方式防止溢出',selected=0,parsing='',remark='C',question_id=109  WHERE id=438;
UPDATE option_info  SET context='ResultSet的fetchSize越大，JDBC client端消耗的内存越大，性能也越快',selected=0,parsing='',remark='C',question_id=110  WHERE id=442;
UPDATE option_info  SET context='getDeclaredNames',selected=0,parsing='',remark='B',question_id=111  WHERE id=445;
UPDATE option_info  SET context='float f = 10f',selected=0,parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',remark='A',question_id=112  WHERE id=448;
UPDATE option_info  SET context='double d = 10',selected=0,parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',remark='D',question_id=112  WHERE id=451;
UPDATE option_info  SET context='double d = 10.0',selected=0,parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',remark='F',question_id=112  WHERE id=453;
UPDATE option_info  SET context='HashMap和HashSet的默认值大小为16，HashTable的默认值大小为11',selected=0,parsing='A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个',remark='B',question_id=113  WHERE id=455;
UPDATE option_info  SET context='LinkedHashMap保持插入的顺序，TreeMap保持key的自然顺序',selected=0,parsing='A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个',remark='C',question_id=113  WHERE id=456;
UPDATE option_info  SET context='byte',selected=0,parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',remark='A',question_id=114  WHERE id=458;
UPDATE option_info  SET context='char',selected=0,parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',remark='C',question_id=114  WHERE id=460;
UPDATE option_info  SET context='String',selected=0,parsing='// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch',remark='D',question_id=114  WHERE id=461;
UPDATE option_info  SET context='Throwable是所有Error或Exception的超累',selected=0,parsing='B 纯属狗屁了，你把Throwable不放在眼里',remark='A',question_id=115  WHERE id=462;
UPDATE option_info  SET context='Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError',selected=0,parsing='B 纯属狗屁了，你把Throwable不放在眼里',remark='C',question_id=115  WHERE id=464;
UPDATE option_info  SET context='编译器会强制要求使用者捕获RuntimeException或申明抛出',selected=0,parsing='B 纯属狗屁了，你把Throwable不放在眼里',remark='D',question_id=115  WHERE id=465;
UPDATE option_info  SET context='Java多线程程序中，线程不允许抛出未捕获的Checked Exception',selected=0,parsing='',remark='A',question_id=116  WHERE id=466;
UPDATE option_info  SET context='Java多线程程序中，建议使用Thread对象的setUncaughtExceptionHandler方法注册Runtime异常的处理者',selected=0,parsing='',remark='C',question_id=116  WHERE id=468;
UPDATE option_info  SET context='在运行时判断任意一个对象所属的类。',selected=0,parsing='',remark='A',question_id=117  WHERE id=470;
UPDATE option_info  SET context='在运行时构造任意一个类的对象。',selected=0,parsing='',remark='B',question_id=117  WHERE id=471;
UPDATE option_info  SET context='在运行时判断任意一个类所具有的成员变量和方法。',selected=0,parsing='',remark='C',question_id=117  WHERE id=472;
UPDATE option_info  SET context='在运行时调用任意一个对象的方法。',selected=0,parsing='',remark='D',question_id=117  WHERE id=473;
UPDATE option_info  SET context='SelectionKey.OP_ACCEPT',selected=0,parsing='有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生',remark='A',question_id=118  WHERE id=474;
UPDATE option_info  SET context='SelectionKey.OP_CONNECT',selected=0,parsing='有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生',remark='B',question_id=118  WHERE id=475;
UPDATE option_info  SET context='SelectionKey.OP_WRITE',selected=0,parsing='有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生',remark='C',question_id=118  WHERE id=476;
UPDATE option_info  SET context='SelectionKey.OP_READ',selected=0,parsing='有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生',remark='D',question_id=118  WHERE id=477;
UPDATE option_info  SET context='Integer',selected=0,parsing='貌似包装类都是final class可能看看源码加深记忆',remark='B',question_id=119  WHERE id=479;
UPDATE option_info  SET context='String',selected=0,parsing='貌似包装类都是final class可能看看源码加深记忆',remark='C',question_id=119  WHERE id=480;
UPDATE option_info  SET context='char',selected=0,parsing='https://blog.csdn.net/u012611878/article/details/52455576',remark='A',question_id=120  WHERE id=482;
UPDATE option_info  SET context='long',selected=0,parsing='https://blog.csdn.net/u012611878/article/details/52455576',remark='C',question_id=120  WHERE id=484;
UPDATE option_info  SET context='short',selected=0,parsing='https://blog.csdn.net/u012611878/article/details/52455576',remark='D',question_id=120  WHERE id=485;
UPDATE option_info  SET context='ABCDEABCDE',selected=0,parsing='',remark='B',question_id=121  WHERE id=487;
UPDATE option_info  SET context='运行异常',selected=0,parsing='',remark='C',question_id=122  WHERE id=492;
UPDATE option_info  SET context='true true',selected=0,parsing='',remark='A',question_id=123  WHERE id=494;
UPDATE option_info  SET context='flag',selected=0,parsing='',remark='B',question_id=124  WHERE id=499;
UPDATE option_info  SET context='IO允许一个线程监听多个输入通道',selected=0,parsing='',remark='D',question_id=125  WHERE id=505;
UPDATE option_info  SET context='Reader',selected=0,parsing='',remark='D',question_id=126  WHERE id=509;
UPDATE option_info  SET context='synchronized和ReentrantLock都是可重入锁',selected=0,parsing='',remark='C',question_id=127  WHERE id=512;
UPDATE option_info  SET context='-1',selected=0,parsing='false ？ 1 : false ？ 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1',remark='C',question_id=128  WHERE id=516;
UPDATE option_info  SET context='编码方式启动 System.setProperty(“java.security.manager”, xxx);',selected=0,parsing='',remark='D',question_id=129  WHERE id=521;
UPDATE option_info  SET context='服务出现不可恢复的异常时，主动执行System.exit()',selected=0,parsing='',remark='D',question_id=130  WHERE id=525;
UPDATE option_info  SET context='调用Thread.interrupt() 用于请求另外一个线程中止执行，而不是直接中止',selected=0,parsing='',remark='A',question_id=131  WHERE id=526;
UPDATE option_info  SET context='检测到当前线程被interrupt后，应抛出InterruptedException，并在finally或try-with-resource中清理执行状态',selected=0,parsing='',remark='C',question_id=131  WHERE id=528;
UPDATE option_info  SET context='调用线程的interrupt方法，只有当线程走到了sleep, wait, join等阻塞这些方法的时候，才会抛出InterruptedException。',selected=0,parsing='',remark='D',question_id=131  WHERE id=529;
UPDATE option_info  SET context='Vector',selected=0,parsing='Stack<E> extend Vector<E> 故线程安全',remark='B',question_id=132  WHERE id=531;
UPDATE option_info  SET context='Hashtable',selected=0,parsing='Stack<E> extend Vector<E> 故线程安全',remark='C',question_id=132  WHERE id=532;
UPDATE option_info  SET context='ConcurrentHashMap',selected=0,parsing='Stack<E> extend Vector<E> 故线程安全',remark='F',question_id=132  WHERE id=535;
UPDATE option_info  SET context='Stack',selected=0,parsing='Stack<E> extend Vector<E> 故线程安全',remark='G',question_id=132  WHERE id=536;
UPDATE option_info  SET context='Exchanger',selected=0,parsing='',remark='A',question_id=133  WHERE id=537;
UPDATE option_info  SET context='Semaphore',selected=0,parsing='',remark='B',question_id=133  WHERE id=538;
UPDATE option_info  SET context='CountDownLatch',selected=0,parsing='',remark='C',question_id=133  WHERE id=539;
UPDATE option_info  SET context='CyclicBarrier',selected=0,parsing='',remark='D',question_id=133  WHERE id=540;
UPDATE option_info  SET context='Phaser',selected=0,parsing='',remark='E',question_id=133  WHERE id=541;
UPDATE option_info  SET context='DT FUZZ测试中，如果被测函数代码有修改，但被测函数被调用逻辑没有修改，不需要修改测试用例',selected=0,parsing='',remark='A',question_id=134  WHERE id=542;
UPDATE option_info  SET context='就绪',selected=0,parsing='',remark='D',question_id=135  WHERE id=549;
UPDATE option_info  SET context='Java的反序列化操作，可以绕过对象构造函数的执行',selected=0,parsing='',remark='B',question_id=136  WHERE id=551;
UPDATE option_info  SET context='CSRF',selected=0,parsing='CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ',remark='A',question_id=137  WHERE id=554;
UPDATE option_info  SET context='日志中如果必须记录敏感信息，需要使用长度固定的*替代',selected=0,parsing='',remark='C',question_id=138  WHERE id=560;
UPDATE option_info  SET context='XXE',selected=0,parsing='规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击',remark='B',question_id=139  WHERE id=563;
UPDATE option_info  SET context='内部实体扩展',selected=0,parsing='规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击',remark='C',question_id=139  WHERE id=564;
UPDATE option_info  SET context='对于使用外部输入构造的命令行，在执行前进行转码处理',selected=0,parsing='在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。',remark='C',question_id=140  WHERE id=568;
UPDATE option_info  SET context='java.Security.SecureRandom()',selected=0,parsing='',remark='D',question_id=141  WHERE id=573;
UPDATE option_info  SET context='XMLDecoder是jdk原生类，提供了xml的反序列化操作，所以相对Xstream，更推荐使用XMLDecoder进行xml数据的反序列化操作',selected=0,parsing='java原生的XMLDecoder类常被用来序列化反序列化XML格式数据，但是这个类也存在严重安全问题，这里解析任意xml文件可以导致反序列化命令执行，oracle官方未提供任何针对此问题的安全措施，所以在反序列化不可信xml数据时，强烈建议不要使用此类。',remark='A',question_id=142  WHERE id=574;
UPDATE option_info  SET context='③',selected=0,parsing='规则7.5 禁止序列化非静态的内部类',remark='A',question_id=143  WHERE id=578;
UPDATE option_info  SET context='②',selected=0,parsing='规则7.5 禁止序列化非静态的内部类',remark='B',question_id=143  WHERE id=579;
UPDATE option_info  SET context='CharBuffer.duplicate();',selected=0,parsing='http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。',remark='B',question_id=144  WHERE id=582;
UPDATE option_info  SET context='CharBuffer.subSequence();',selected=0,parsing='http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。',remark='C',question_id=144  WHERE id=583;
UPDATE option_info  SET context='CharBuffer.wrap();',selected=0,parsing='http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。',remark='D',question_id=144  WHERE id=584;
UPDATE option_info  SET context='对于单例模式的java类，即使该类对象可暴露给不可信代码，使用同步方法可以正确进行线程同步',selected=0,remark='B',question_id=145  WHERE id=586;
UPDATE option_info  SET context='日志注入',selected=0,remark='B',question_id=146  WHERE id=590;
UPDATE option_info  SET context='④',selected=0,parsing='解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='B',question_id=147  WHERE id=594;
UPDATE option_info  SET context='Runtime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nStreamGobbler outputGobbler = new StreamGobbler(proc.getInputStream(), System.out);\nerrorGobbler.start();\noutputGobbler.start();\nint exitVal = proc.waitFor();',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上',remark='B',question_id=148  WHERE id=598;
UPDATE option_info  SET context='线程会一直运行',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387',remark='D',question_id=149  WHERE id=604;
UPDATE option_info  SET context='转码仅对拼接sql语句中，单引号或双引号限制的字段生效',selected=0,parsing='解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。',remark='B',question_id=150  WHERE id=606;
UPDATE option_info  SET context='SAXParserFactory factory = SAXParserFactory.newInstance();\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(inStream, defaultHandler);',selected=0,remark='A',question_id=151  WHERE id=609;
UPDATE option_info  SET context='AES-ECB',selected=0,remark='B',question_id=152  WHERE id=614;
UPDATE option_info  SET context='DES',selected=0,remark='C',question_id=152  WHERE id=615;
UPDATE option_info  SET context='MD5',selected=0,remark='D',question_id=152  WHERE id=616;
UPDATE option_info  SET context='使用不安全的XSLT转换XML文件',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753',remark='A',question_id=153  WHERE id=617;
UPDATE option_info  SET context='对不可信数据进行反序列化操作',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753',remark='B',question_id=153  WHERE id=618;
UPDATE option_info  SET context='使用不可信数据拼接命令行',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753',remark='D',question_id=153  WHERE id=620;
UPDATE option_info  SET context='外部实体注入(XXE)',selected=0,remark='A',question_id=154  WHERE id=621;
UPDATE option_info  SET context='内部实体扩展',selected=0,remark='B',question_id=154  WHERE id=622;
UPDATE option_info  SET context='XPath注入',selected=0,remark='D',question_id=154  WHERE id=624;
UPDATE option_info  SET context='将敏感数据声明为transient',selected=0,remark='B',question_id=155  WHERE id=626;
UPDATE option_info  SET context='特殊情况下正确加密了的数据可以被序列化',selected=0,remark='D',question_id=155  WHERE id=628;
UPDATE option_info  SET context='异常条件下没有正确释放锁',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='B',question_id=156  WHERE id=630;
UPDATE option_info  SET context='两个或多个线程以不同的顺序请求和释放锁',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='C',question_id=156  WHERE id=631;
UPDATE option_info  SET context='在产生阻塞的操作中持有锁',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='D',question_id=156  WHERE id=632;
UPDATE option_info  SET context='资源未正确释放',selected=0,remark='A',question_id=157  WHERE id=633;
UPDATE option_info  SET context='配置文件中明文保存密码',selected=0,remark='D',question_id=157  WHERE id=636;
UPDATE option_info  SET context='方法的局部变量表',selected=0,remark='A',question_id=158  WHERE id=637;
UPDATE option_info  SET context='操作数栈',selected=0,remark='B',question_id=158  WHERE id=638;
UPDATE option_info  SET context='动态连接',selected=0,remark='C',question_id=158  WHERE id=639;
UPDATE option_info  SET context='方法返回地址',selected=0,remark='D',question_id=158  WHERE id=640;
UPDATE option_info  SET context='堆区',selected=0,remark='A',question_id=159  WHERE id=641;
UPDATE option_info  SET context='方法区',selected=0,remark='B',question_id=159  WHERE id=642;
UPDATE option_info  SET context='BigInteger',selected=0,remark='C',question_id=160  WHERE id=645;
UPDATE option_info  SET context='501',selected=0,remark='A',question_id=161  WHERE id=647;
UPDATE option_info  SET context='\\W',selected=0,remark='A',question_id=162  WHERE id=651;
UPDATE option_info  SET context='map()',selected=0,remark='B',question_id=163  WHERE id=656;
UPDATE option_info  SET context='0',selected=0,remark='A',question_id=164  WHERE id=659;
UPDATE option_info  SET context='RandomAccessFile继承InputStream和OutputStream',selected=0,parsing='解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。',remark='C',question_id=165  WHERE id=665;
UPDATE option_info  SET context='ABCDEABCDEACBDE',selected=0,parsing='解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。',remark='B',question_id=166  WHERE id=669;
UPDATE option_info  SET context='BufferedReader',selected=0,remark='A',question_id=167  WHERE id=672;
UPDATE option_info  SET context='FileChannel从文件读取数据，或将数据写入文件，无法设置为非阻塞模式',selected=0,parsing='解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。',remark='A',question_id=168  WHERE id=676;
UPDATE option_info  SET context='ServerSocketChannel可以监听新进来的TCP连接',selected=0,parsing='解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。',remark='D',question_id=168  WHERE id=679;
UPDATE option_info  SET context='创建文件时指定合理的访问权限',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='A',question_id=169  WHERE id=680;
UPDATE option_info  SET context='对所有外部输入进行校验',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='B',question_id=169  WHERE id=681;
UPDATE option_info  SET context='禁止不受信任的代码直接终止JVM',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='D',question_id=169  WHERE id=683;
UPDATE option_info  SET context='运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空',selected=0,parsing='解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值',remark='C',question_id=170  WHERE id=686;
UPDATE option_info  SET context='Java NIO中的一个选择器只能注册一个通道',selected=0,parsing='解析：\n一个选择器最多可以同时被63个通道一起注册使用。',remark='B',question_id=171  WHERE id=689;
UPDATE option_info  SET context='多路复用IO没有一个线程需要被阻塞',selected=0,remark='C',question_id=172  WHERE id=694;
UPDATE option_info  SET context='server socket的accpet()监听客户端连接',selected=0,parsing='解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)',remark='A',question_id=173  WHERE id=696;
UPDATE option_info  SET context='执行socket的输出流写数据',selected=0,parsing='解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)',remark='B',question_id=173  WHERE id=697;
UPDATE option_info  SET context='执行socket的输入流读取数据',selected=0,parsing='解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)',remark='C',question_id=173  WHERE id=698;
UPDATE option_info  SET context='内存泄漏',selected=0,parsing='解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。',remark='A',question_id=174  WHERE id=700;
UPDATE option_info  SET context='num%num1',selected=0,remark='C',question_id=175  WHERE id=706;
UPDATE option_info  SET context='float f = 10f;',selected=0,remark='A',question_id=176  WHERE id=708;
UPDATE option_info  SET context='double d = 10;',selected=0,remark='D',question_id=176  WHERE id=711;
UPDATE option_info  SET context='double d = 10.0;',selected=0,remark='F',question_id=176  WHERE id=713;
UPDATE option_info  SET context='char c1 = 1;',selected=0,remark='B',question_id=177  WHERE id=715;
UPDATE option_info  SET context='byte',selected=0,parsing='short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);',remark='A',question_id=178  WHERE id=717;
UPDATE option_info  SET context='float',selected=0,parsing='short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);',remark='B',question_id=178  WHERE id=718;
UPDATE option_info  SET context='long',selected=0,parsing='short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);',remark='D',question_id=178  WHERE id=720;
UPDATE option_info  SET context='TreeMap可以有null的key、value',selected=0,parsing='解析：\nTreeMap键可以为\'null\'，值不允许',remark='B',question_id=179  WHERE id=722;
UPDATE option_info  SET context='多线程环境下使用HashTable和Collections. synchronizedMap实现同步效率差别不大',selected=0,remark='C',question_id=180  WHERE id=727;
UPDATE option_info  SET context='往一个ArrayList或者Vector里插入一个元素时，如果内部数组空间不够，ArrayList或Vector会扩展它的大小。Vector在默认情况下增长一倍的大小，而ArrayList增加50%的大小',selected=0,parsing='解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。',remark='A',question_id=181  WHERE id=729;
UPDATE option_info  SET context='HashMap键、值均可以为null值',selected=0,remark='A',question_id=182  WHERE id=733;
UPDATE option_info  SET context='HashMap中的数据是无序的',selected=0,remark='B',question_id=182  WHERE id=734;
UPDATE option_info  SET context='TreeMap中的键是自动排序的，不允许为null值',selected=0,remark='C',question_id=182  WHERE id=735;
UPDATE option_info  SET context='LinkedHashMap插入元素是有序的',selected=0,remark='D',question_id=182  WHERE id=736;
UPDATE option_info  SET context='把第parameterIndex的参数值设置为x',selected=0,remark='B',question_id=183  WHERE id=738;
UPDATE option_info  SET context='保留表而删除所有数据的时候建议使用truncate',selected=0,remark='A',question_id=184  WHERE id=741;
UPDATE option_info  SET context='删除部分数据行时，可以使用delete，并且带上where子句',selected=0,remark='B',question_id=184  WHERE id=742;
UPDATE option_info  SET context='truncate drop是dll，操作立即生效，原始数据不放到rollback segment中，不能回滚',selected=0,remark='D',question_id=184  WHERE id=744;
UPDATE option_info  SET context='DataSource对象的属性不可以修改',selected=0,parsing='解析：\nDataSource对象的属性在必要时可以修改。',remark='B',question_id=185  WHERE id=746;
UPDATE option_info  SET context='命令行',selected=0,parsing='解析：\n不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）',remark='A',question_id=186  WHERE id=749;
UPDATE option_info  SET context='用户输入',selected=0,parsing='解析：\n不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）',remark='B',question_id=186  WHERE id=750;
UPDATE option_info  SET context='环境变量',selected=0,parsing='解析：\n不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）',remark='C',question_id=186  WHERE id=751;
UPDATE option_info  SET context='网络数据',selected=0,parsing='解析：\n不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）',remark='D',question_id=186  WHERE id=752;
UPDATE option_info  SET context='当返回类型为数组或者容器时，应返回长度为0的数组或者容器',selected=0,remark='C',question_id=187  WHERE id=755;
UPDATE option_info  SET context='int a,b;',selected=0,parsing='解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)',remark='A',question_id=188  WHERE id=757;
UPDATE option_info  SET context='int replacementLen = replacement.length();\nString string = sequence.toString();\nint pos = indexIn(string);\nif (replacementLen == 0) {\nreturn removeFrom(sequence);\n}\nif (replacementLen == 1) {\nreturn replaceFrom(sequence, replacement.charAt(0));\n}\nif (pos == -1) {\nreturn string;\n}',selected=0,parsing='解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)',remark='B',question_id=188  WHERE id=758;
UPDATE option_info  SET context='String args[];',selected=0,parsing='解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)',remark='C',question_id=188  WHERE id=759;
UPDATE option_info  SET context='public boolean matchs (char c) {\nswitch (c) {\ncase \'\\t\':\ncase \'\\n\':\ncase \'\\u205f\':\ncase \'\\u3000\':\nreturn true;\ncase \'\\u2007\':\nreturn false;\ndefault:\nreturn false;\n}\n}',selected=0,parsing='解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)',remark='D',question_id=188  WHERE id=760;
UPDATE option_info  SET context='Socket s = new Socket(\"10.116.123.112\", 6526);\nInputStream stream = s.getInputStream();\n// use thread read data',selected=0,remark='A',question_id=189  WHERE id=761;
UPDATE option_info  SET context='Socket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526));\nInputStream stream = s.getInputStream();\n// use thread read data',selected=0,remark='D',question_id=189  WHERE id=764;
UPDATE option_info  SET context='writeObject()',selected=0,parsing='解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。',remark='B',question_id=190  WHERE id=766;
UPDATE option_info  SET context='readObject()',selected=0,parsing='解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。',remark='C',question_id=190  WHERE id=767;
UPDATE option_info  SET context='java.security.AccessControlException.access denied',selected=0,parsing='解析：\npolicy文件里面java.version的权限是read，程序去write权限不足',remark='C',question_id=191  WHERE id=771;
UPDATE option_info  SET context='当一个父类实现序列化，子类若要实现序列化，需要显式实现Serializable接口',selected=0,parsing='解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。',remark='C',question_id=192  WHERE id=775;
UPDATE option_info  SET context='反序列化的输入数据可以由外部输入指定',selected=0,parsing='解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699',remark='B',question_id=193  WHERE id=778;
UPDATE option_info  SET context='资源关闭在catch和finally中语句执行之前',selected=0,parsing='解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。',remark='D',question_id=194  WHERE id=784;
UPDATE option_info  SET context='try (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}',selected=0,remark='B',question_id=195  WHERE id=786;
UPDATE option_info  SET context='DSA',selected=0,parsing='解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA',remark='A',question_id=196  WHERE id=788;
UPDATE option_info  SET context='ECDSA',selected=0,parsing='解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA',remark='B',question_id=196  WHERE id=789;
UPDATE option_info  SET context='zip文件解压时，可以使用entry.getSize()对解压缩文件进行文件大小判断',selected=0,parsing='解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。',remark='A',question_id=197  WHERE id=792;
UPDATE option_info  SET context='public Image loadImage(String path) throws IOException',selected=0,remark='B',question_id=198  WHERE id=797;
UPDATE option_info  SET context='private final Object lock = new Object();',selected=0,parsing='解析：\nA. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。\n\nC. 非信任域内，锁不能用public\n\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化',remark='B',question_id=199  WHERE id=800;
UPDATE option_info  SET context='private final String lock = new String(\"LOCK\").intern();\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}',selected=0,parsing='解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例',remark='A',question_id=200  WHERE id=803;
UPDATE option_info  SET context='private final String lock = \"lock\"\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}',selected=0,parsing='解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例',remark='B',question_id=200  WHERE id=804;
UPDATE option_info  SET context='private final Boolean = Boolean.TRUE;\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}',selected=0,parsing='解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例',remark='D',question_id=200  WHERE id=806;
UPDATE option_info  SET context='volatile可以解决数据可见性问题，即对volatile变量的变更，可以直接写入主内存',selected=0,remark='D',question_id=201  WHERE id=810;
UPDATE option_info  SET context='AtomicReference',selected=0,remark='C',question_id=202  WHERE id=813;
UPDATE option_info  SET context='语义分析及生成字节码',selected=0,remark='A',question_id=203  WHERE id=815;
UPDATE option_info  SET context='词法分析及填充符号表',selected=0,remark='B',question_id=203  WHERE id=816;
UPDATE option_info  SET context='注解处理',selected=0,remark='D',question_id=203  WHERE id=818;
UPDATE option_info  SET context='一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的',selected=0,parsing='解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类',remark='B',question_id=204  WHERE id=821;
UPDATE option_info  SET context='ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null',selected=0,parsing='解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类',remark='D',question_id=204  WHERE id=823;
UPDATE option_info  SET context='所有ClassLoader装载的类都来自CLASSPATH环境指定的路径',selected=0,parsing='解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类',remark='F',question_id=204  WHERE id=825;
UPDATE option_info  SET context='由用户自定义的类加载器加载的类是可以被卸载的',selected=0,parsing='解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。',remark='B',question_id=205  WHERE id=827;
UPDATE option_info  SET context='由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载',selected=0,parsing='解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。',remark='C',question_id=205  WHERE id=828;
UPDATE option_info  SET context='所有的java类都有一个静态属性class，它代表这个类的class对象',selected=0,parsing='解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。',remark='D',question_id=205  WHERE id=829;
UPDATE option_info  SET context='声明抽象类必须带有abstract',selected=0,remark='C',question_id=206  WHERE id=832;
UPDATE option_info  SET context='static class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<？ super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}',selected=0,parsing='解析：\n泛型通配符<？ extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<？ super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<？ extends T>。\n- 2. 经常往里插入的，适合用<？ super T>。\n<？ extends T> = <subClass extends T> = T以及T的子类\n<？ super T> = <superClass super T> = T以及T的父类',remark='A',question_id=207  WHERE id=834;
UPDATE option_info  SET context='static class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}',selected=0,parsing='解析：\n泛型通配符<？ extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<？ super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<？ extends T>。\n- 2. 经常往里插入的，适合用<？ super T>。\n<？ extends T> = <subClass extends T> = T以及T的子类\n<？ super T> = <superClass super T> = T以及T的父类',remark='D',question_id=207  WHERE id=837;
UPDATE option_info  SET context='[0,0],[5,5]',selected=0,remark='C',question_id=208  WHERE id=840;
UPDATE option_info  SET context='20 100',selected=0,remark='A',question_id=209  WHERE id=842;
UPDATE option_info  SET context='编译错误',selected=0,parsing='解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数',remark='D',question_id=210  WHERE id=849;
UPDATE option_info  SET context='debug',selected=0,remark='A',question_id=211  WHERE id=850;
UPDATE option_info  SET context='trace',selected=0,remark='D',question_id=211  WHERE id=853;
UPDATE option_info  SET context='序列化敏感数据',selected=0,parsing='解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）',remark='A',question_id=212  WHERE id=854;
UPDATE option_info  SET context='传输敏感数据',selected=0,parsing='解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）',remark='B',question_id=212  WHERE id=855;
UPDATE option_info  SET context='没有使用类似于SSL传输通道',selected=0,parsing='解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）',remark='C',question_id=212  WHERE id=856;
UPDATE option_info  SET context='敏感数据需要长久保存（比如在硬盘驱动器上）',selected=0,parsing='解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）',remark='D',question_id=212  WHERE id=857;
UPDATE option_info  SET context='先签名后加密',selected=0,remark='D',question_id=213  WHERE id=861;
UPDATE option_info  SET context='++',selected=0,remark='A',question_id=214  WHERE id=862;
UPDATE option_info  SET context='+=',selected=0,remark='C',question_id=214  WHERE id=864;
UPDATE option_info  SET context='Java.lang.math.abs()',selected=0,remark='D',question_id=214  WHERE id=865;
UPDATE option_info  SET context='对于运行时异常可调用Thread.setUncaughtExceptionHandler()方法设置运行时异常处理器来进行处理',selected=0,remark='B',question_id=215  WHERE id=867;
UPDATE option_info  SET context='默认情况下，运行时异常从线程抛出时，会在控制台输出堆栈记录',selected=0,remark='C',question_id=215  WHERE id=868;
UPDATE option_info  SET context='子线程须自己捕获异常处理',selected=0,remark='D',question_id=215  WHERE id=869;
UPDATE option_info  SET context='字符向字节转换时，需要注意编码问题',selected=0,remark='A',question_id=216  WHERE id=870;
UPDATE option_info  SET context='字节流继承于InputStream OutputStream，字符流继承于InputSteamReader OutputStreamWriter',selected=0,remark='B',question_id=216  WHERE id=871;
UPDATE option_info  SET context='字符流使用了缓冲区(Buffer)，而字节流没有使用缓冲区',selected=0,remark='C',question_id=216  WHERE id=872;
UPDATE option_info  SET context='ArrayList的默认长度值16',selected=0,parsing='解析：ArrayList默认是10',remark='A',question_id=217  WHERE id=874;
UPDATE option_info  SET context='private final Integer lock4 = new Integer(0);',selected=0,remark='D',question_id=218  WHERE id=881;
UPDATE option_info  SET context='Java.lang.OutOfMemoryError',selected=0,remark='A',question_id=219  WHERE id=882;
UPDATE option_info  SET context='Java.lang.StackOverflowError',selected=0,remark='B',question_id=219  WHERE id=883;
UPDATE option_info  SET context='InSufficientResourceException',selected=0,remark='D',question_id=219  WHERE id=885;
UPDATE option_info  SET context='命令行工具使用System.exit()',selected=0,parsing='例外场景：\n在命令行应用中调用System.exit()函数是允许的。',remark='D',question_id=220  WHERE id=889;
UPDATE option_info  SET context='不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符',selected=0,parsing='解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH',remark='A',question_id=221  WHERE id=890;
UPDATE option_info  SET context='使用java.nio.charset中的类编码解码字符集',selected=0,parsing='解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH',remark='D',question_id=221  WHERE id=893;
UPDATE option_info  SET context='重点关注异常中的文本消息，异常本身的类型不会泄露敏感信息',selected=0,parsing='解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。',remark='B',question_id=222  WHERE id=895;
UPDATE option_info  SET context='456456456\\d\n123456\n123456',selected=0,parsing='解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.',remark='B',question_id=223  WHERE id=899;
UPDATE option_info  SET context='加载',selected=0,remark='D',question_id=224  WHERE id=905;
UPDATE option_info  SET context='info',selected=0,remark='D',question_id=225  WHERE id=909;
UPDATE option_info  SET context='CPU运行用户代码的时间与CPU总消耗时间的比值',selected=0,parsing='解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)',remark='B',question_id=226  WHERE id=911;
UPDATE option_info  SET context='存在空指针异常风险',selected=0,parsing='解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。',remark='A',question_id=227  WHERE id=914;
UPDATE option_info  SET context='char i = 1;',selected=0,parsing='解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值',remark='D',question_id=228  WHERE id=921;
UPDATE option_info  SET context='public native void XXX();',selected=0,remark='B',question_id=229  WHERE id=923;
UPDATE option_info  SET context='方法需要抽象',selected=0,remark='A',question_id=230  WHERE id=926;
UPDATE option_info  SET context='功能不单一',selected=0,remark='B',question_id=230  WHERE id=927;
UPDATE option_info  SET context='过于复杂',selected=0,remark='C',question_id=230  WHERE id=928;
UPDATE option_info  SET context='不便于他人阅读和修改代码',selected=0,remark='D',question_id=230  WHERE id=929;
UPDATE option_info  SET context='反射方法',selected=0,remark='A',question_id=231  WHERE id=930;
UPDATE option_info  SET context='泛型',selected=0,remark='B',question_id=231  WHERE id=931;
UPDATE option_info  SET context='集合中类型',selected=0,remark='C',question_id=231  WHERE id=932;
UPDATE option_info  SET context='POJO RPC某些不需要设置默认值的类型',selected=0,remark='D',question_id=231  WHERE id=933;
UPDATE option_info  SET context='inputstream',selected=0,remark='B',question_id=232  WHERE id=935;
UPDATE option_info  SET context='outputstream',selected=0,remark='C',question_id=232  WHERE id=936;
UPDATE option_info  SET context='DES',selected=0,remark='A',question_id=233  WHERE id=938;
UPDATE option_info  SET context='无SQL注入风险，但是将String转化为int型变量时可能会有NumberFormatException抛出',selected=0,remark='C',question_id=234  WHERE id=944;
UPDATE option_info  SET context='空指针引用',selected=0,remark='C',question_id=235  WHERE id=948;
UPDATE option_info  SET context='stringBuilder.append(System.lineSeparator());',selected=0,parsing='解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。',remark='C',question_id=236  WHERE id=952;
UPDATE option_info  SET context='4',selected=0,parsing='fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34',remark='D',question_id=237  WHERE id=956;
UPDATE option_info  SET context='The input is 2\nThe input is 3\nBad input',selected=0,parsing='switch没有break会执行完后面的如果\nint num = 2;\nswitch (num) {\n    case 2:\n        System.out.println(\"The input is 2\");\n    case 1:\n        System.out.println(\"The input is 1\");\n    case 3:\n        System.out.println(\"The input is 3\");\n    default:\n        System.out.println(\"Bad input\");\n}\n会输出 213 Bad input',remark='D',question_id=238  WHERE id=960;
UPDATE option_info  SET context='final Stream<String> stream = Stream.of(\"Red\", \"Blue\", \"Green\");\nSet<String> colors = Stream.toSet();',selected=0,parsing='解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())',remark='D',question_id=239  WHERE id=964;
UPDATE option_info  SET context='32位',selected=0,remark='A',question_id=240  WHERE id=965;
UPDATE option_info  SET context='123456',selected=0,remark='B',question_id=241  WHERE id=970;
UPDATE option_info  SET context='345',selected=0,remark='A',question_id=242  WHERE id=973;
UPDATE option_info  SET context='false,false,true,false',selected=0,parsing='解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。',remark='A',question_id=243  WHERE id=977;
UPDATE option_info  SET context='一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内',selected=0,parsing='解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}',remark='C',question_id=244  WHERE id=983;
UPDATE option_info  SET context='将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作',selected=0,remark='B',question_id=245  WHERE id=986;
UPDATE option_info  SET context='运行test.bat和notepad.exe',selected=0,parsing='解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。',remark='D',question_id=246  WHERE id=992;
UPDATE option_info  SET context='Stream.of(\"1\",\"2\").toSet()',selected=0,remark='D',question_id=247  WHERE id=996;
UPDATE option_info  SET context='byte',selected=0,remark='A',question_id=248  WHERE id=997;
UPDATE option_info  SET context='float',selected=0,remark='C',question_id=248  WHERE id=999;
UPDATE option_info  SET context='long',selected=0,remark='D',question_id=248  WHERE id=1000;
UPDATE option_info  SET context='protected',selected=0,parsing='解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted',remark='A',question_id=249  WHERE id=1001;
UPDATE option_info  SET context='final',selected=0,parsing='解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted',remark='B',question_id=249  WHERE id=1002;
UPDATE option_info  SET context='private',selected=0,parsing='解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted',remark='D',question_id=249  WHERE id=1004;
UPDATE option_info  SET context='必须定义前缀为abstract',selected=0,remark='A',question_id=250  WHERE id=1005;
UPDATE option_info  SET context='字节流的基类InputStream/OutputStream，字符流是Reader/Writer',selected=0,parsing='A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。',remark='B',question_id=251  WHERE id=1010;
UPDATE option_info  SET context='字符流最终都会按照字节流处理',selected=0,parsing='A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。',remark='D',question_id=251  WHERE id=1012;
UPDATE option_info  SET context='方法的返回值可被忽略',selected=0,parsing='解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值',remark='D',question_id=252  WHERE id=1016;
UPDATE option_info  SET context='类可以单重继承，接口可以多重继承',selected=0,remark='C',question_id=253  WHERE id=1019;
UPDATE option_info  SET context='class Test implements ableA, ableB',selected=0,remark='A',question_id=254  WHERE id=1021;
UPDATE option_info  SET context='interface Test extends ableA, ableB',selected=0,remark='E',question_id=254  WHERE id=1025;
UPDATE option_info  SET context='Connection',selected=0,remark='B',question_id=255  WHERE id=1027;
UPDATE option_info  SET context='Stream跟迭代器类似，再次遍历需要重新生成',selected=0,parsing='解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。',remark='A',question_id=256  WHERE id=1030;
UPDATE option_info  SET context='URLClassLoader的默认签名检查依赖jar包中的公钥，因此不能仅依赖该机制对jar包进行合法性检查',selected=0,remark='A',question_id=257  WHERE id=1034;
UPDATE option_info  SET context='String',selected=0,parsing='解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal',remark='B',question_id=258  WHERE id=1039;
UPDATE option_info  SET context='Integer',selected=0,parsing='解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal',remark='D',question_id=258  WHERE id=1041;
UPDATE option_info  SET context='ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包',selected=0,parsing='解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader',remark='A',question_id=259  WHERE id=1042;
UPDATE option_info  SET context='AppClassLoader负责加载当前应用classpath下的所有jar包和类',selected=0,parsing='解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader',remark='B',question_id=259  WHERE id=1043;
UPDATE option_info  SET context='BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类',selected=0,parsing='解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader',remark='C',question_id=259  WHERE id=1044;
UPDATE option_info  SET context='1',selected=0,remark='A',question_id=260  WHERE id=1046;
UPDATE option_info  SET context='6, 3',selected=0,remark='D',question_id=261  WHERE id=1054;
UPDATE option_info  SET context='TreeMap可以有\'null\'的key和value',selected=0,parsing='解析：\nTreeMap键可以为\'null\'，值不允许\nD:也很牵强，HashTable 不如ConcurentMap好呀',remark='A',question_id=262  WHERE id=1055;
UPDATE option_info  SET context='HashMap能够保证其中元素的顺序',selected=0,remark='A',question_id=263  WHERE id=1059;
UPDATE option_info  SET context='通道可以异步读写，流是同步读写',selected=0,remark='A',question_id=264  WHERE id=1063;
UPDATE option_info  SET context='通道可以读也可以写，流一般来说是单向的',selected=0,remark='C',question_id=264  WHERE id=1065;
UPDATE option_info  SET context='通道是面向缓冲区的，流是面向流的',selected=0,remark='D',question_id=264  WHERE id=1066;
UPDATE option_info  SET context='synchronized',selected=0,remark='B',question_id=265  WHERE id=1068;
UPDATE option_info  SET context='volatile',selected=0,remark='D',question_id=265  WHERE id=1070;
UPDATE option_info  SET context='CountDownLatch.countDown()计数为0就会释放所有线程',selected=0,remark='A',question_id=266  WHERE id=1071;
UPDATE option_info  SET context='CountDownLatch.countdown()为计数减控制',selected=0,remark='C',question_id=266  WHERE id=1073;
UPDATE option_info  SET context='CountDownLatch.await()只能触发阻塞等待，计数不会-1',selected=0,remark='D',question_id=266  WHERE id=1074;
UPDATE option_info  SET context='使用PreparedStatement进行sql注入防护是优选方案',selected=0,remark='A',question_id=267  WHERE id=1075;
UPDATE option_info  SET context='使用PreparedStatement多次执行同一条sql语句可以提升执行的效率',selected=0,remark='B',question_id=267  WHERE id=1076;
UPDATE option_info  SET context='正确使用PreparedStatement，可以有效防止sql注入的发生',selected=0,remark='D',question_id=267  WHERE id=1078;
UPDATE option_info  SET context='\"select * from users where id=\" + request.getParameter(\"id\");',selected=0,remark='A',question_id=268  WHERE id=1079;
UPDATE option_info  SET context='\"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");',selected=0,remark='D',question_id=268  WHERE id=1082;
UPDATE option_info  SET context='/opt/oss/log',selected=0,remark='B',question_id=269  WHERE id=1084;
UPDATE option_info  SET context='/a{2}/(*)',selected=0,remark='C',question_id=270  WHERE id=1089;
UPDATE option_info  SET context='先签名再加密后传输',selected=0,remark='A',question_id=271  WHERE id=1093;
UPDATE option_info  SET context='可以省去changePasword()方法中的同步块，直接将changePasword()方法声明为synchronized修饰的同步方法',selected=0,remark='A',question_id=272  WHERE id=1097;
UPDATE option_info  SET context='由JVM属性获取:System.getProperty(\"user.name\")',selected=0,remark='C',question_id=273  WHERE id=1103;
UPDATE option_info  SET context='Map<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();',selected=0,remark='D',question_id=274  WHERE id=1108;
UPDATE option_info  SET context='程序员无法明确强制垃圾回收器运行',selected=0,remark='A',question_id=275  WHERE id=1109;
UPDATE option_info  SET context='String userName = \"name\";\nResultSet rs = st.executeQuery(\"select * from user where name = \'\" + userName + \"\'\");\n//该代码可能会产生SQL注入漏洞',selected=0,remark='B',question_id=276  WHERE id=1114;
UPDATE option_info  SET context='flag：读写状态位',selected=0,remark='B',question_id=277  WHERE id=1118;
UPDATE option_info  SET context='wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态',selected=0,remark='C',question_id=278  WHERE id=1123;
UPDATE option_info  SET context='错误流',selected=0,remark='A',question_id=279  WHERE id=1125;
UPDATE option_info  SET context='输出流',selected=0,remark='C',question_id=279  WHERE id=1127;
UPDATE option_info  SET context='输入流',selected=0,remark='D',question_id=279  WHERE id=1128;
UPDATE option_info  SET context='HashTable',selected=0,remark='B',question_id=280  WHERE id=1130;
UPDATE option_info  SET context='Vector',selected=0,remark='C',question_id=280  WHERE id=1131;
UPDATE option_info  SET context='float[][] f = new float[6][6];',selected=0,remark='D',question_id=281  WHERE id=1136;
UPDATE option_info  SET context='float[][] f = new float[6][];',selected=0,remark='E',question_id=281  WHERE id=1137;
UPDATE option_info  SET context='List list = new LinkedList<>();',selected=0,parsing='解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。',remark='B',question_id=282  WHERE id=1139;
UPDATE option_info  SET context='Map<Integer, Integer> map = new HashMap<>();',selected=0,parsing='解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。',remark='C',question_id=282  WHERE id=1140;
UPDATE option_info  SET context='List list = new ArrayList<>();',selected=0,parsing='解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。',remark='D',question_id=282  WHERE id=1141;
UPDATE option_info  SET context='CountDownLatch',selected=0,parsing='解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。',remark='A',question_id=283  WHERE id=1142;
UPDATE option_info  SET context='Semaphore信号量',selected=0,parsing='解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接',remark='A',question_id=284  WHERE id=1146;
UPDATE option_info  SET context='抛出一个异常时',selected=0,parsing='解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。',remark='D',question_id=285  WHERE id=1153;
UPDATE option_info  SET context='public static int answer = 42;',selected=0,parsing='解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized',remark='B',question_id=286  WHERE id=1155;
UPDATE option_info  SET context='OutOfMemoryError：Perm Gen是老年代内存溢出',selected=0,parsing='解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足',remark='B',question_id=287  WHERE id=1159;
UPDATE option_info  SET context='密钥',selected=0,parsing='',remark='B',question_id=288  WHERE id=1162;
UPDATE option_info  SET context='明文口令',selected=0,parsing='',remark='C',question_id=288  WHERE id=1163;
UPDATE option_info  SET context='密文口令',selected=0,parsing='',remark='D',question_id=288  WHERE id=1164;
UPDATE option_info  SET context='如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；',selected=0,parsing='',remark='C',question_id=289  WHERE id=1167;
UPDATE option_info  SET context='其他选项都不行',selected=0,parsing='hashMap底层是先判断hash是否相同，相同在判断equals方法\neg：\nclass Temp {\n    public static void main(String[] args) {\n        HashMap<Temp, Integer> map = new HashMap<>();\n        // 看hash相同，equals不同map的存储情况\n        Temp hash1 = new Temp(1, 2);\n        Temp hash2 = new Temp(1, 3);\n        map.put(hash1, 100);\n        map.put(hash2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash不同map的存储情况\n        Temp equals1 = new Temp(0, 1);\n        Temp equals2 = new Temp(1, 1);\n        map.put(equals1, 100);\n        map.put(equals2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash相同 map的存储情况\n        Temp hasAndEquals1 = new Temp(0, 0);\n        Temp hasAndEquals2 = new Temp(0, 0);\n        map.put(hasAndEquals1, 100);\n        map.put(hasAndEquals2, 200);\n        System.out.println(map);\n    }\n    private int code;\n    private int equals;\n    @Override\n    public String toString() {\n        return \"Temp{\" +\n            \"code=\" + code +\n            \", equals=\" + equals +\n            \'}\';\n    }\n    public Temp(int code, int equals) {\n        this.code = code;\n        this.equals = equals;\n    }\n    @Override\n    public int hashCode() {\n        System.out.println(\"调用了hash\");\n        return this.code;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"调用了equals\");\n        if (obj instanceof Temp) {\n            return ((Temp) obj).equals == this.equals;\n        }\n        return false;\n    }\n}',remark='B',question_id=290  WHERE id=1170;
UPDATE option_info  SET context='DatagramPacket',selected=0,parsing='http://3ms.huawei.com/km/groups/2032581/blogs/details/1829183',remark='A',question_id=291  WHERE id=1173;
UPDATE option_info  SET context='同一次运行中，同一个对象如果equals方法中用到的信息没有改变，多次调用hashCode方法返回值必须相同；',selected=0,parsing='B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等',remark='A',question_id=293  WHERE id=1181;
UPDATE option_info  SET context='如果两个对象调用equals方法时不相等，则这两个对象的hashCode方法，可以相同，也可以返回不同的值',selected=0,parsing='B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等',remark='C',question_id=293  WHERE id=1183;
UPDATE option_info  SET context='覆写equals的时候，应同时覆写hashCode方法',selected=0,parsing='B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等',remark='D',question_id=293  WHERE id=1184;
UPDATE option_info  SET context='private',selected=0,parsing='（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817',remark='A',question_id=294  WHERE id=1185;
UPDATE option_info  SET context='final',selected=0,parsing='（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817',remark='B',question_id=294  WHERE id=1186;
UPDATE option_info  SET context='static',selected=0,parsing='（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817',remark='C',question_id=294  WHERE id=1187;
UPDATE option_info  SET context='assert names.remove(null);',selected=0,parsing='这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;',remark='B',question_id=295  WHERE id=1190;
UPDATE option_info  SET context='assert names.add(null);',selected=0,parsing='这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;',remark='C',question_id=295  WHERE id=1191;
UPDATE option_info  SET context='成长期',selected=0,remark='A',question_id=297  WHERE id=1193;
UPDATE option_info  SET context='通过向系统注入在实际应用中可能发生的故障，观察系统功能性性能变化，故障检测、定位、隔离以及故障恢复清空，发现产品缺陷、评估系统可靠性的测试方法',selected=0,remark='A',question_id=298  WHERE id=1197;
UPDATE option_info  SET context='所有过程活动均事先计划，按照计划衡量进度',selected=0,remark='C',question_id=299  WHERE id=1203;
UPDATE option_info  SET context='第三方软件版本EOSS时间是华为根据华为软件版本的TR5时间来定义的',selected=0,remark='A',question_id=300  WHERE id=1205;
UPDATE option_info  SET context='瀑布模型',selected=0,remark='A',question_id=301  WHERE id=1209;
UPDATE option_info  SET context='采用数据平滑消除备份数据中的错误，不是软件可靠性设计的关键技术，不用投入精力进行设计',selected=0,remark='B',question_id=302  WHERE id=1214;
UPDATE option_info  SET context='开源软件使用声明包括：软件名称、软件版本、权利人声明、员工工号、许可证（license）',selected=0,remark='C',question_id=303  WHERE id=1219;
UPDATE option_info  SET context='因小红尚未离职，通过小明的回忆已经找到真实的修改人，所以没有违背配置管理原则，不存在网络安全风险',selected=0,remark='A',question_id=304  WHERE id=1221;
UPDATE option_info  SET context='在研发过程中有效测试第三方组件安全性的重要性',selected=0,remark='D',question_id=305  WHERE id=1228;
UPDATE option_info  SET context='STRIDE SD威胁建模',selected=0,remark='C',question_id=306  WHERE id=1231;
UPDATE option_info  SET context='系统构建',selected=0,remark='A',question_id=307  WHERE id=1233;
UPDATE option_info  SET context='自研二进制仓取消了VMP采用的Windows share共享方式，不容易存留漏洞后门，确保了二进制完整性保护能力',selected=0,remark='C',question_id=308  WHERE id=1239;
UPDATE option_info  SET context='所有的原型都是抛弃式',selected=0,remark='C',question_id=309  WHERE id=1243;
UPDATE option_info  SET context='对于片段引用进行整改，可自研重写，或采取申请整包使用、部分编译的方法，或其他软件替代方案',selected=0,remark='A',question_id=310  WHERE id=1245;
UPDATE option_info  SET context='对产品全量代码进行分析，确保所有使用的开源软件是整包使用，对片段引用情况可借助fossbot扫描工具辅助分析',selected=0,remark='C',question_id=310  WHERE id=1247;
UPDATE option_info  SET context='二叉树',selected=0,remark='B',question_id=311  WHERE id=1251;
UPDATE option_info  SET context='二维数组',selected=0,remark='E',question_id=311  WHERE id=1254;
UPDATE option_info  SET context='密钥用途单一化，即一个密钥应只用于一种用途',selected=0,remark='A',question_id=312  WHERE id=1255;
UPDATE option_info  SET context='工作密钥在本地存储时需提供机密性保护',selected=0,remark='B',question_id=312  WHERE id=1256;
UPDATE option_info  SET context='口令、默认设置的可见字符等，均不能直接作为密钥使用',selected=0,remark='C',question_id=312  WHERE id=1257;
UPDATE option_info  SET context='不再使用的密钥，应当立即删除',selected=0,remark='D',question_id=312  WHERE id=1258;
UPDATE option_info  SET context='基线与变更管理策略',selected=0,remark='A',question_id=313  WHERE id=1260;
UPDATE option_info  SET context='版本管理策略',selected=0,remark='B',question_id=313  WHERE id=1261;
UPDATE option_info  SET context='配置库策略',selected=0,remark='C',question_id=313  WHERE id=1262;
UPDATE option_info  SET context='配置项识别策略',selected=0,remark='E',question_id=313  WHERE id=1264;
UPDATE option_info  SET context='平台版本不需要实施数字签名',selected=0,remark='B',question_id=315  WHERE id=1266;
UPDATE option_info  SET context='提交成功，提示的是需要更新配置库上的最新版本后再进行提交',selected=0,remark='B',question_id=316  WHERE id=1270;
UPDATE option_info  SET context='老张应该将架构设计文档提交评审流程，评审通过后进行基线',selected=0,remark='B',question_id=317  WHERE id=1274;
UPDATE option_info  SET context='架构设计文档是关键的配置项，老张应该对架构设计文档进行配置项识别，按照配置项管理要求归档在统一的配置库中',selected=0,remark='C',question_id=317  WHERE id=1275;
UPDATE option_info  SET context='老张要按照配置项命名规范对架构设计文档进行规范化命名，而不能随意命名为相似的名称',selected=0,remark='D',question_id=317  WHERE id=1276;
UPDATE option_info  SET context='配置状态发布',selected=0,remark='C',question_id=318  WHERE id=1279;
UPDATE option_info  SET context='差异识别即基于相同环境，相同源代码编译两次，使用编译结果通过beyond compare进行比较，不完全一致即存在差异，由于时间戳引起的二进制一致性差异可以忽略',selected=0,remark='D',question_id=319  WHERE id=1284;
UPDATE option_info  SET context='永久故障',selected=0,parsing='解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】',remark='A',question_id=320  WHERE id=1285;
UPDATE option_info  SET context='瞬时故障',selected=0,parsing='解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】',remark='B',question_id=320  WHERE id=1286;
UPDATE option_info  SET context='间歇故障',selected=0,parsing='解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】',remark='C',question_id=320  WHERE id=1287;
UPDATE option_info  SET context='时间检查 (如：心跳检测)',selected=0,remark='C',question_id=321  WHERE id=1291;
UPDATE option_info  SET context='降低攻击成功可能性',selected=0,remark='A',question_id=322  WHERE id=1293;
UPDATE option_info  SET context='不利情况发生后恢复业务',selected=0,remark='B',question_id=322  WHERE id=1294;
UPDATE option_info  SET context='限制不利情况发生时的损害',selected=0,remark='C',question_id=322  WHERE id=1295;
UPDATE option_info  SET context='不利情况下维持核心业务',selected=0,remark='D',question_id=322  WHERE id=1296;
UPDATE option_info  SET context='软件编码与构建',selected=0,remark='A',question_id=323  WHERE id=1297;
UPDATE option_info  SET context='需求分析与设计',selected=0,remark='B',question_id=323  WHERE id=1298;
UPDATE option_info  SET context='验证发布',selected=0,remark='D',question_id=323  WHERE id=1300;
UPDATE option_info  SET context='隐私保护',selected=0,remark='A',question_id=324  WHERE id=1301;
UPDATE option_info  SET context='网络安全',selected=0,remark='B',question_id=324  WHERE id=1302;
UPDATE option_info  SET context='如果将用户个人数据转移给第三方，公司应获得用户同意或满足其他合法性基础',selected=0,remark='B',question_id=325  WHERE id=1306;
UPDATE option_info  SET context='作为数据处理者的法国供应商，基于成本考虑将数据转移到德国处理',selected=0,remark='A',question_id=326  WHERE id=1309;
UPDATE option_info  SET context='对于不引起系统故障只导致系统或服务KPI下降的亚健康异常不需要检测',selected=0,remark='B',question_id=327  WHERE id=1314;
UPDATE option_info  SET context='当程序需要用户上传文件时，只需要校验用户上传的文件后缀名即可有效防止可执行文件上传漏洞',selected=0,remark='C',question_id=328  WHERE id=1319;
UPDATE option_info  SET context='机密性',selected=0,parsing='解析：收集数据原则： 合法、正当、透明 + 目的限制 + 数据最小化 + 准确性 + 存储期限最小化 + 完整性与保密性 + 可归责】',remark='B',question_id=329  WHERE id=1322;
UPDATE option_info  SET context='需要从系统架构层面来关注整个系统级别的安全防御机制',selected=0,remark='A',question_id=330  WHERE id=1325;
UPDATE option_info  SET context='不能只依赖单一安全机制',selected=0,remark='B',question_id=330  WHERE id=1326;
UPDATE option_info  SET context='采用多点，多重的安全校验机制',selected=0,remark='C',question_id=330  WHERE id=1327;
UPDATE option_info  SET context='“Nov 1,2016,21:04:16”字符串',selected=0,remark='A',question_id=331  WHERE id=1329;
UPDATE option_info  SET context='构建时刻距离1970/01/01秒数',selected=0,remark='B',question_id=331  WHERE id=1330;
UPDATE option_info  SET context='“2017030418056”字符串',selected=0,remark='C',question_id=331  WHERE id=1331;
UPDATE option_info  SET context='其他自定义格式：1990+月-日-天-小时-分-秒的偏移量',selected=0,remark='D',question_id=331  WHERE id=1332;
UPDATE option_info  SET context='某云服务应该对涉及的个人数据处理场景进行隐私风险评估，针对风险制定消减措施并闭环',selected=0,remark='A',question_id=332  WHERE id=1333;
UPDATE option_info  SET context='某网站在设计时，在重定向到第三方网页前，告知用户将会发生跳转',selected=0,remark='B',question_id=332  WHERE id=1334;
UPDATE option_info  SET context='某云服务收集个人数据前，明确提示用户，并获得用户的同意',selected=0,remark='D',question_id=332  WHERE id=1336;
UPDATE option_info  SET context='可以进入系统的隐藏快捷键',selected=0,remark='A',question_id=333  WHERE id=1337;
UPDATE option_info  SET context='隐藏命令或参数',selected=0,remark='B',question_id=333  WHERE id=1338;
UPDATE option_info  SET context='可绕过系统认证的访问接口',selected=0,remark='C',question_id=333  WHERE id=1339;
UPDATE option_info  SET context='隐藏账号',selected=0,remark='D',question_id=333  WHERE id=1340;
UPDATE option_info  SET context='认证绕过',selected=0,parsing='解析：常见安全编码问题包括：缓冲区溢出、跨站脚本攻击、SQL注入和其他等等】',remark='A',question_id=334  WHERE id=1341;
UPDATE option_info  SET context='安全风险发生可能性和业务影响性',selected=0,remark='D',question_id=335  WHERE id=1348;
UPDATE option_info  SET context='身份管理和访问控制，数据安全，信息保护流程和步骤，安全运维',selected=0,parsing='解析：CSF：http://3ms.huawei.com/km/blogs/details/6437325】',remark='A',question_id=336  WHERE id=1349;
UPDATE option_info  SET context='既不是数据控制者也不是数据处理者',selected=0,parsing='解析：只开发软件卖给客户，则买软件的客户是数据处理者，A公司什么也不是，只是个开发工具的人，不接触数据】',remark='B',question_id=337  WHERE id=1354;
UPDATE option_info  SET context='决定个人数据处理的目的及方式',selected=0,parsing='解析：区分数据控制者与数据处理者的关键原则】',remark='A',question_id=338  WHERE id=1357;
UPDATE option_info  SET context='现场更换单板',selected=0,remark='C',question_id=339  WHERE id=1363;
UPDATE option_info  SET context='软件功能需求',selected=0,remark='D',question_id=340  WHERE id=1368;
UPDATE option_info  SET context='服务降级',selected=0,remark='C',question_id=341  WHERE id=1371;
UPDATE option_info  SET context='减轻',selected=0,remark='A',question_id=342  WHERE id=1373;
UPDATE option_info  SET context='偶然失效期',selected=0,remark='A',question_id=343  WHERE id=1377;
UPDATE option_info  SET context='早期失效期',selected=0,remark='B',question_id=343  WHERE id=1378;
UPDATE option_info  SET context='损耗失效期',selected=0,remark='D',question_id=343  WHERE id=1380;
UPDATE option_info  SET context='进程间通信 (包括管道，消息，共享内存，socket，RPC等)',selected=0,remark='A',question_id=344  WHERE id=1382;
UPDATE option_info  SET context='函数参数 (对于API)，全局变量 (在本函数内，其他线程会修改全局变量)',selected=0,remark='B',question_id=344  WHERE id=1383;
UPDATE option_info  SET context='用户输入 (包括命令行，界面)，用户动态数据 (对于内核程序)',selected=0,remark='C',question_id=344  WHERE id=1384;
UPDATE option_info  SET context='文件 (包括程序的配置文件)，注册表，网络，环境变量',selected=0,remark='D',question_id=344  WHERE id=1385;
UPDATE option_info  SET context='可干预性',selected=0,remark='B',question_id=345  WHERE id=1387;
UPDATE option_info  SET context='重试设计',selected=0,remark='A',question_id=347  WHERE id=1394;
UPDATE option_info  SET context='若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程 (需开源)，通过隔离层进行交互',selected=0,remark='A',question_id=348  WHERE id=1398;
UPDATE option_info  SET context='在内核态中对Linux kernel进行调用，以避免GPL串扰',selected=0,remark='B',question_id=348  WHERE id=1399;
UPDATE option_info  SET context='整包使用开源软件，版本名称可以根据产品版本定制命名',selected=0,parsing='解析：\n【规则】整包使用开源软件，版本名称与官网保持一致\n【规则】涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理\n【规则】开源修改的patch独立存放可管理\n【规则】禁止片段引用开源软件代码',remark='C',question_id=349  WHERE id=1404;
UPDATE option_info  SET context='已EOSS/即将停止销售的第三方软件不建议引入',selected=0,parsing='解析：供应商发布的软件正式版本，需要评估才能引入】',remark='B',question_id=350  WHERE id=1407;
UPDATE option_info  SET context='未签署供应商网络安全协议的软件禁止引入',selected=0,parsing='解析：供应商发布的软件正式版本，需要评估才能引入】',remark='C',question_id=350  WHERE id=1408;
UPDATE option_info  SET context='业务无替代的第三方软件，可能存在供应风险，不建议引入',selected=0,parsing='解析：供应商发布的软件正式版本，需要评估才能引入】',remark='D',question_id=350  WHERE id=1409;
UPDATE option_info  SET context='判断原则是基于事实，编码前没阅读过开源代码写出的代码可以判定为自研，其他形式直接参考开源写的代码都属于开源',selected=0,remark='B',question_id=351  WHERE id=1411;
UPDATE option_info  SET context='openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入',selected=0,remark='B',question_id=352  WHERE id=1415;
UPDATE option_info  SET context='经评审不得随意修改开开开元源生代码，但基于开源定制的代码规模无限制',selected=0,parsing='解析：使用Patch方式管理—>正确】',remark='B',question_id=353  WHERE id=1419;
UPDATE option_info  SET context='法务层面来看，产品无法正确且完整地履行开源软件义务，导致引起法务诉讼',selected=0,remark='A',question_id=354  WHERE id=1422;
UPDATE option_info  SET context='网络安全层面来看，产品无法完整地回合社区对应补丁或漏洞无法追溯',selected=0,remark='B',question_id=354  WHERE id=1423;
UPDATE option_info  SET context='产品拷贝的来源可能是不可靠的',selected=0,remark='C',question_id=354  WHERE id=1424;
UPDATE option_info  SET context='维护工作量来看，开源片段会大量地分布在产品的各个模块或特性中，网络安全的攻击面会增大，漏洞修复的投入成本也增大，且容易遗漏',selected=0,remark='D',question_id=354  WHERE id=1425;
UPDATE option_info  SET context='BSD类license，如Apache/BSD/MIT等，原则上没有对外开源要求',selected=0,remark='B',question_id=355  WHERE id=1427;
UPDATE option_info  SET context='GPL软件本身必须开源，且具有传染性，与该软件在同一进程中运行的代码都必须对外开源',selected=0,remark='C',question_id=355  WHERE id=1428;
UPDATE option_info  SET context='MPL类软件若无修改，则无需对外开源',selected=0,remark='D',question_id=355  WHERE id=1429;
UPDATE option_info  SET context='开源软件社区发布的补丁要和自研修改的补丁做成一个patch进行统一管理',selected=0,remark='D',question_id=356  WHERE id=1433;
UPDATE option_info  SET context='通过修改变量名，宏名，使得FOSSID扫描不出来',selected=0,remark='A',question_id=357  WHERE id=1434;
UPDATE option_info  SET context='通过修改函数名，使得FOSSID扫描不出来',selected=0,remark='B',question_id=357  WHERE id=1435;
UPDATE option_info  SET context='通过删除注释，将宏替换为魔鬼数字等方式规避FOSSID扫描',selected=0,remark='D',question_id=357  WHERE id=1437;
UPDATE option_info  SET context='LGPL允许静态链接使用，但要履行对应代码开源义务',selected=0,remark='A',question_id=358  WHERE id=1438;
UPDATE option_info  SET context='产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，将开源软件归档到开源代码目录，并通过部分编译的形式，仅编译需要的特性进行打包发布',selected=0,remark='B',question_id=359  WHERE id=1443;
UPDATE option_info  SET context='产品P引入XX开源软件，工程师小A分析&应用后认为需要对开源代码进行少量修改才能满足产品需求，通过团队架构评审等确认后，将修改代码以Patch的 方式进行管理',selected=0,remark='C',question_id=359  WHERE id=1444;
UPDATE option_info  SET context='一个专门的团队，同时具备开发和运维能力',selected=0,remark='B',question_id=360  WHERE id=1447;
UPDATE option_info  SET context='是指开发和运维一起参与到整个软件生命周期的过程中，事件从开发、测试、部署上线到维护',selected=0,remark='C',question_id=360  WHERE id=1448;
UPDATE option_info  SET context='和传统运维区别不大，只是使用了一些新的工具去实现自动化',selected=0,remark='D',question_id=360  WHERE id=1449;
UPDATE option_info  SET context='瀑布模型',selected=0,remark='B',question_id=361  WHERE id=1451;
UPDATE option_info  SET context='可复用的构件标准有利于复用',selected=0,remark='C',question_id=362  WHERE id=1456;
UPDATE option_info  SET context='规划复用的时候要考虑很多因素，包括开发进度，所期望的软件生命周期，开发团队的经验等，所以是否复用经常是一个管理问题而非技术问题',selected=0,remark='D',question_id=362  WHERE id=1457;
UPDATE option_info  SET context='需求基线',selected=0,remark='D',question_id=363  WHERE id=1461;
UPDATE option_info  SET context='需求变更',selected=0,remark='B',question_id=364  WHERE id=1463;
UPDATE option_info  SET context='需求分析中对不明确的功能需求要进行细致调查后进行具体化',selected=0,remark='A',question_id=365  WHERE id=1466;
UPDATE option_info  SET context='需求分析是对项目目标和场景涉及的问题都要考虑',selected=0,remark='B',question_id=365  WHERE id=1467;
UPDATE option_info  SET context='需求分析过程中需要将需求转换为形式化的功能规约，如需求规格说明书',selected=0,remark='C',question_id=365  WHERE id=1468;
UPDATE option_info  SET context='对特殊的场景不做分析',selected=0,remark='A',question_id=366  WHERE id=1470;
UPDATE option_info  SET context='特性的可交付性和服务代码要求的不一致',selected=0,remark='B',question_id=366  WHERE id=1471;
UPDATE option_info  SET context='对性能的描述：整体系统的响应时间不小于2s',selected=0,remark='C',question_id=366  WHERE id=1472;
UPDATE option_info  SET context='用户可以根据图书名搜索到该图书',selected=0,parsing='解析：产品需求：CE、组织需求：F】',remark='A',question_id=367  WHERE id=1474;
UPDATE option_info  SET context='系统可以查询用户当前已经借到的图书',selected=0,parsing='解析：产品需求：CE、组织需求：F】',remark='B',question_id=367  WHERE id=1475;
UPDATE option_info  SET context='用户输入书名后。2s内查询到该书的信息',selected=0,parsing='解析：产品需求：CE、组织需求：F】',remark='D',question_id=367  WHERE id=1477;
UPDATE option_info  SET context='更新风险清单并分析风险影响',selected=0,remark='A',question_id=368  WHERE id=1480;
UPDATE option_info  SET context='客户对于软件产品的需求持续下降',selected=0,parsing='解析：软件危机详解：http://3ms.huawei.com/hi/group/2025905/wiki_4400291.html】',remark='A',question_id=369  WHERE id=1484;
UPDATE option_info  SET context='严酷度为I类和 II 类的故障',selected=0,remark='D',question_id=370  WHERE id=1491;
UPDATE option_info  SET context='采用忽略策略应对具体风险概率',selected=0,parsing='解析：风险规避 + 转移 + 减轻；但是风险不能忽略】',remark='B',question_id=371  WHERE id=1493;
UPDATE option_info  SET context='采用应急计划处置风险转变为具体问题的事件',selected=0,parsing='解析：风险规避 + 转移 + 减轻；但是风险不能忽略】',remark='C',question_id=371  WHERE id=1494;
UPDATE option_info  SET context='采用最小化策略降低风险的影响',selected=0,parsing='解析：风险规避 + 转移 + 减轻；但是风险不能忽略】',remark='D',question_id=371  WHERE id=1495;
UPDATE option_info  SET context='保护开发团队免受外部干扰',selected=0,parsing='解析：定义产品需求不属于Scrum Master的职责】',remark='A',question_id=372  WHERE id=1496;
UPDATE option_info  SET context='引导团队正确应用敏捷实践',selected=0,parsing='解析：定义产品需求不属于Scrum Master的职责】',remark='B',question_id=372  WHERE id=1497;
UPDATE option_info  SET context='促进团队紧密协作',selected=0,parsing='解析：定义产品需求不属于Scrum Master的职责】',remark='D',question_id=372  WHERE id=1499;
UPDATE option_info  SET context='软件交付的主要工作是将程序代码和相关文档交给用户',selected=0,remark='B',question_id=373  WHERE id=1501;
UPDATE option_info  SET context='提供叫车与车辆信息服务来满足司机车辆服务与乘客出行的要求',selected=0,remark='C',question_id=374  WHERE id=1506;
UPDATE option_info  SET context='软件工程仅指实现软件生产开发的活动序列',selected=0,remark='C',question_id=375  WHERE id=1510;
UPDATE option_info  SET context='用户规模不超过5000人时，登陆密码验证时间不超过2秒，用户规模不超过2万人时，登陆密码验证不超过5秒',selected=0,remark='C',question_id=376  WHERE id=1514;
UPDATE option_info  SET context='–Xmn50M',selected=0,parsing='解析：-Xmn、-Xms、-Xmx、-Xss都是JVM对内存的配置参数：】\n-Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小\n-Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn\n-Xss设置每个线程可使用的内存大小',remark='A',question_id=377  WHERE id=1516;
UPDATE option_info  SET context='jmap [options]',selected=0,remark='A',question_id=378  WHERE id=1520;
UPDATE option_info  SET context='多个进程竞争资源出现了循环等待',selected=0,remark='A',question_id=379  WHERE id=1524;
UPDATE option_info  SET context='使用jmap可以定位线程死锁的问题',selected=0,remark='C',question_id=380  WHERE id=1530;
UPDATE option_info  SET context='占有并请求',selected=0,remark='B',question_id=381  WHERE id=1533;
UPDATE option_info  SET context='jmap',selected=0,remark='C',question_id=382  WHERE id=1538;
UPDATE option_info  SET context='使用-Xrunjdwp后，将以调试模式启动java进程',selected=0,parsing='解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】',remark='B',question_id=383  WHERE id=1541;
UPDATE option_info  SET context='transport类型可以是dt_socket和dt_shmem，其中dt_shmem只适用于window平台',selected=0,parsing='解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】',remark='C',question_id=383  WHERE id=1542;
UPDATE option_info  SET context='onthrow指明是否在发生指定异常时中断执行，进行调试',selected=0,parsing='解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】',remark='D',question_id=383  WHERE id=1543;
UPDATE option_info  SET context='Thread.join()',selected=0,parsing='解析：start()方法不会引起切换】',remark='A',question_id=384  WHERE id=1544;
UPDATE option_info  SET context='Object.wait()',selected=0,parsing='解析：start()方法不会引起切换】',remark='B',question_id=384  WHERE id=1545;
UPDATE option_info  SET context='Thread.yeild()',selected=0,parsing='解析：start()方法不会引起切换】',remark='C',question_id=384  WHERE id=1546;
UPDATE option_info  SET context='Thread.sleep()',selected=0,parsing='解析：start()方法不会引起切换】',remark='E',question_id=384  WHERE id=1548;
UPDATE option_info  SET context='可以查看java程序的内存使用情况',selected=0,parsing='解析：可以查看/修改JVM参数，java系统参数】',remark='D',question_id=385  WHERE id=1552;
UPDATE option_info  SET context='jmap –histo 17212',selected=0,parsing='解析：jmap：查看内存占用情况】',remark='A',question_id=386  WHERE id=1553;
UPDATE option_info  SET context='相比server模式，JVM client模式可以获得更好的性能',selected=0,remark='A',question_id=387  WHERE id=1557;
UPDATE option_info  SET context='单个测试用例体现了多个功能点测试',selected=0,remark='D',question_id=388  WHERE id=1564;
UPDATE option_info  SET context='静态测试并没有真正运行软件，而动态测试需要真正运行软件',selected=0,remark='C',question_id=389  WHERE id=1567;
UPDATE option_info  SET context='尽可能多的',selected=0,remark='A',question_id=390  WHERE id=1569;
UPDATE option_info  SET context='测试数据属于测试用例的组成部分',selected=0,remark='C',question_id=391  WHERE id=1575;
UPDATE option_info  SET context='开发者具有熟悉系统的优势，因此应该尽量让开发者完成整个IPD测试过程',selected=0,remark='B',question_id=392  WHERE id=1578;
UPDATE option_info  SET context='单元测试',selected=0,remark='D',question_id=393  WHERE id=1584;
UPDATE option_info  SET context='3,2,5,4,1',selected=0,parsing='解析：注意栈后进先出的特点即可，每个选项带入栈推导下)',remark='C',question_id=394  WHERE id=1587;
UPDATE option_info  SET context='计数排序',selected=0,parsing='解析：数组几乎有序/短数组时，插入排序效率高，因为此场景下每个元素离它最终排定的位置都不会太远】',remark='A',question_id=395  WHERE id=1589;
UPDATE option_info  SET context='3',selected=0,remark='C',question_id=396  WHERE id=1595;
UPDATE option_info  SET context='n/2',selected=0,remark='A',question_id=397  WHERE id=1597;
UPDATE option_info  SET context='顺序表插入变动的时间复杂度为O (n)',selected=0,remark='A',question_id=398  WHERE id=1601;
UPDATE option_info  SET context='顺序表按下标查找的时间复杂度是O (1)',selected=0,remark='B',question_id=398  WHERE id=1602;
UPDATE option_info  SET context='顺序表存储空间连续，即允许元素的随机访问',selected=0,remark='D',question_id=398  WHERE id=1604;
UPDATE option_info  SET context='安全强度就是密钥长度',selected=0,remark='C',question_id=399  WHERE id=1607;
UPDATE option_info  SET context='对计算机上执行的计算过程得具体描述',selected=0,remark='B',question_id=400  WHERE id=1610;
UPDATE option_info  SET context='1或者5',selected=0,remark='C',question_id=401  WHERE id=1615;
UPDATE option_info  SET context='95,22,91,24,94,71',selected=0,parsing='解析：对于当前节点，它要么比后面的节点都大，要么比后面的节点都小】',remark='D',question_id=402  WHERE id=1620;
UPDATE option_info  SET context='若v是T1的叶节点，则T1与T3相同',selected=0,parsing='解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】',remark='B',question_id=403  WHERE id=1622;
UPDATE option_info  SET context='若v不是T1的叶节点，则T1与T3可能不同',selected=0,parsing='解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】',remark='C',question_id=403  WHERE id=1623;
UPDATE option_info  SET context='120',selected=0,parsing='解析：5个位置放5个字符= 54321=120】',remark='D',question_id=404  WHERE id=1628;
UPDATE option_info  SET context='2的(k-1)次方',selected=0,remark='B',question_id=405  WHERE id=1630;
UPDATE option_info  SET context='由于社区一直未采纳提交补丁，自己在社区中fork一个新项目出来维护',selected=0,remark='D',question_id=407  WHERE id=1636;
UPDATE option_info  SET context='使用辅助工具BepKit消除',selected=0,remark='C',question_id=408  WHERE id=1639;
UPDATE option_info  SET context='将系统进行划分，以限制成功攻击的传播和损害',selected=0,remark='A',question_id=409  WHERE id=1641;
UPDATE option_info  SET context='2的k-1次方',selected=0,remark='C',question_id=410  WHERE id=1647;
UPDATE option_info  SET context='差分隐私',selected=0,remark='A',question_id=411  WHERE id=1649;
UPDATE option_info  SET context='O(logN)',selected=0,remark='D',question_id=412  WHERE id=1656;
UPDATE option_info  SET context='软件工程仅指实现软件生产开发的活动序列',selected=0,remark='B',question_id=413  WHERE id=1658;
UPDATE option_info  SET context='113',selected=0,remark='A',question_id=414  WHERE id=1661;
UPDATE option_info  SET context='系统之系统不可能是最小规模系统，如包含不同提供商提供的服务的较小的系统，大规模系统经常是系统之系统',selected=0,remark='D',question_id=415  WHERE id=1668;
UPDATE option_info  SET context='业务保证原则：确保在出现大流量冲击时所有业务不被丢弃',selected=0,remark='B',question_id=416  WHERE id=1670;
UPDATE option_info  SET context='-Wl,-z,now',selected=0,remark='C',question_id=417  WHERE id=1675;
UPDATE option_info  SET context='级联故障',selected=0,remark='A',question_id=418  WHERE id=1676;
UPDATE option_info  SET context='多样性使用异构技术（例如 硬件、软件、固件、协议），这样增加了网络建设的成本，运维的难度，是不可取的',selected=0,remark='C',question_id=419  WHERE id=1682;
UPDATE option_info  SET context='5',selected=0,remark='B',question_id=420  WHERE id=1685;
UPDATE option_info  SET context='系统的冗余设计是硬件独立完成的，与软件关系不大',selected=0,remark='B',question_id=421  WHERE id=1689;
UPDATE option_info  SET context='-Werror',selected=0,remark='C',question_id=422  WHERE id=1694;
UPDATE option_info  SET context='cryptojs 3.19',selected=0,remark='C',question_id=423  WHERE id=1698;
UPDATE option_info  SET context='20',selected=0,remark='A',question_id=424  WHERE id=1700;
UPDATE option_info  SET context='95,22,91,24,94,71',selected=0,remark='D',question_id=425  WHERE id=1707;
UPDATE option_info  SET context='Scrum Master应该对成员所描述的任务内容进行评价',selected=0,remark='B',question_id=426  WHERE id=1709;
UPDATE option_info  SET context='判断原则是基于事实，编码前没阅读过开源代码编写出的代码可判定为自研，其他任何形式直接参考开源写的代码是属于开源',selected=0,remark='A',question_id=427  WHERE id=1712;
UPDATE option_info  SET context='差异识别即基于相同的环境、相同的源代码编译两次，对两次编译结果通过beyond compare进行比较，不完全一致即存在差异，由于时间戳引起的二进制一致性差异可以忽略',selected=0,remark='C',question_id=428  WHERE id=1718;
UPDATE option_info  SET context='遵循社区规则，及时提交社区讨论互动',selected=0,remark='A',question_id=429  WHERE id=1720;
UPDATE option_info  SET context='9',selected=0,remark='A',question_id=430  WHERE id=1724;
UPDATE option_info  SET context='10',selected=0,remark='B',question_id=430  WHERE id=1725;
UPDATE option_info  SET context='11',selected=0,remark='C',question_id=430  WHERE id=1726;
UPDATE option_info  SET context='A平台二进制及源码没有进行配置标识及基线，导致源码缺失',selected=0,remark='A',question_id=431  WHERE id=1728;
UPDATE option_info  SET context='产品正式发布的版本应配套使用A平台的正式发布版本，不应使用A平台的联调版本',selected=0,remark='B',question_id=431  WHERE id=1729;
UPDATE option_info  SET context='联调版本没有通过联调版本发布流程发布，而是通过文件共享方式私下进行传递',selected=0,remark='C',question_id=431  WHERE id=1730;
UPDATE option_info  SET context='具备在任意时刻都能交付二进制对应的准确源代码的能力',selected=0,remark='D',question_id=431  WHERE id=1731;
UPDATE option_info  SET context='网络安全',selected=0,remark='C',question_id=432  WHERE id=1734;
UPDATE option_info  SET context='隐私保护',selected=0,remark='D',question_id=432  WHERE id=1735;
UPDATE option_info  SET context='某产品开发一款仅给内部一线行销员工使用的APP，并上架华为手机应用市场开放下载（但必须华为员工账号产能登录使用），该AAPP通过静态编译方式使用了一款AGPL开源软件，由于只是内部一线行销员工才能登录使用，可以不需要履行开源义务',selected=0,remark='A',question_id=433  WHERE id=1736;
UPDATE option_info  SET context='公有云服务产品A通过静态链接的方式集成使用了license为GPL V2.0的开源软件，服务产品A可以不履行代码开源义务',selected=0,remark='B',question_id=433  WHERE id=1737;
UPDATE option_info  SET context='产品A自研开发且对外开源XXComb软件，并捐献到Apache基金会成为顶级项目，产品B选用社区XXComb软件，仍应认定XXComb软件为自研软件',selected=0,remark='D',question_id=433  WHERE id=1739;
UPDATE option_info  SET context='137',selected=0,remark='B',question_id=434  WHERE id=1741;
UPDATE option_info  SET context='491',selected=0,remark='D',question_id=434  WHERE id=1743;
UPDATE option_info  SET context='验证发布',selected=0,remark='A',question_id=435  WHERE id=1744;
UPDATE option_info  SET context='现网部署',selected=0,remark='B',question_id=435  WHERE id=1745;
UPDATE option_info  SET context='需求分析与设计',selected=0,remark='C',question_id=435  WHERE id=1746;
UPDATE option_info  SET context='软件编码与构建',selected=0,remark='D',question_id=435  WHERE id=1747;
UPDATE option_info  SET context='-fPIE -pie用于可执行程序',selected=0,remark='A',question_id=436  WHERE id=1748;
UPDATE option_info  SET context='-fPIC是编译选项',selected=0,remark='D',question_id=436  WHERE id=1751;
UPDATE option_info  SET context='业界无替代的第三方软件，可能存在供应风险',selected=0,remark='B',question_id=437  WHERE id=1753;
UPDATE option_info  SET context='未签署供应商网络安全协议的软件禁止引入',selected=0,remark='C',question_id=437  WHERE id=1754;
UPDATE option_info  SET context='Json-lib软件社区2013年后社区已无人贡献，建议产品独臂Jackson、fastJson、Gson等同类软件，结合产品使用场景，选择生态、license较友好的开源软件',selected=0,remark='B',question_id=438  WHERE id=1757;
UPDATE option_info  SET context='Log4j日志组件的作者2015年发布log4j2.X和logback；性能比log4j1.X高10倍，建议使用log4j1.X的产品考虑切换到log2.X或logback',selected=0,remark='D',question_id=438  WHERE id=1759;
UPDATE option_info  SET context='功能测试自动化',selected=0,remark='A',question_id=439  WHERE id=1760;
UPDATE option_info  SET context='自动化部署',selected=0,remark='B',question_id=439  WHERE id=1761;
UPDATE option_info  SET context='软件开发过程引入敏捷、精益思维，最小化需求范围(MVP)',selected=0,remark='C',question_id=439  WHERE id=1762;
UPDATE option_info  SET context='不利情况发生后恢复业务',selected=0,remark='A',question_id=440  WHERE id=1764;
UPDATE option_info  SET context='不利情况下维持核心业务',selected=0,remark='B',question_id=440  WHERE id=1765;
UPDATE option_info  SET context='限制不利情况发生时的损害',selected=0,remark='C',question_id=440  WHERE id=1766;
UPDATE option_info  SET context='降低攻击成功可能性',selected=0,remark='D',question_id=440  WHERE id=1767;
UPDATE option_info  SET context='严格遵循计划和流程',selected=0,remark='B',question_id=441  WHERE id=1769;
UPDATE option_info  SET context='观察者是各个不同的显示视图，被观察者是铁路实时订票数据',selected=0,remark='A',question_id=442  WHERE id=1772;
UPDATE option_info  SET context='引入灰度发布，功能先对小范围用户开放，然后增量开放给其他用户',selected=0,remark='B',question_id=443  WHERE id=1777;
UPDATE option_info  SET context='自动化产品的部署和回滚，降低失败对用户的影响时间',selected=0,remark='D',question_id=443  WHERE id=1779;
UPDATE option_info  SET context='预生产环境数据准备要接近生产环境，可以更好的针对生产环境数据进行验证',selected=0,remark='E',question_id=443  WHERE id=1780;
UPDATE option_info  SET context='用户规模不超过5千人时，登录密码验证时间不超过2秒，用户规模不超过2万人时，登录密码验证不超过5秒',selected=0,remark='A',question_id=444  WHERE id=1781;
UPDATE option_info  SET context='基于故障机理模型的故障预测',selected=0,remark='A',question_id=445  WHERE id=1785;
UPDATE option_info  SET context='基于数据驱动的故障预测',selected=0,remark='D',question_id=445  WHERE id=1788;
UPDATE option_info  SET context='代码检视',selected=0,remark='D',question_id=446  WHERE id=1792;
UPDATE option_info  SET context='截断：舍弃属性值的后几位信息来保证数据的模糊性',selected=0,remark='A',question_id=447  WHERE id=1793;
UPDATE option_info  SET context='置换：在表中某字段各记录的数据随机进行打乱(shuffling)',selected=0,remark='B',question_id=447  WHERE id=1794;
UPDATE option_info  SET context='掩码：将属性值的部分字符替换为固定的特殊字符（例如*）',selected=0,remark='C',question_id=447  WHERE id=1795;
UPDATE option_info  SET context='加噪：对原始数据增加一个随机值',selected=0,remark='D',question_id=447  WHERE id=1796;
UPDATE option_info  SET context='不同该许可证的开源代码不存在兼容性问题（如GPL License与BDS License），只要申请后即可按规范使用',selected=0,remark='B',question_id=448  WHERE id=1798;
UPDATE option_info  SET context='服务提供商会公开服务的信息，任何获得授权的用户都可以使用相应服务',selected=0,remark='A',question_id=449  WHERE id=1801;
UPDATE option_info  SET context='组织内部或外部的服务提供商都可以提供服务',selected=0,remark='B',question_id=449  WHERE id=1802;
UPDATE option_info  SET context='服务的用户能根据使用而不是提供商提供的服务来付费',selected=0,remark='C',question_id=449  WHERE id=1803;
UPDATE option_info  SET context='应用能够延迟服务绑定直到这些服务被部署或执行',selected=0,remark='D',question_id=449  WHERE id=1804;
UPDATE option_info  SET context='测试方案设计',selected=0,remark='B',question_id=450  WHERE id=1806;
UPDATE option_info  SET context='8',selected=0,remark='B',question_id=451  WHERE id=1810;
UPDATE option_info  SET context='定义产品需求',selected=0,remark='C',question_id=452  WHERE id=1815;
UPDATE option_info  SET context='现场更换单板',selected=0,remark='C',question_id=453  WHERE id=1819;
UPDATE option_info  SET context='加密秘钥要公开开放',selected=0,remark='C',question_id=454  WHERE id=1823;
UPDATE option_info  SET context='开源软件发布的官方网站，或官方指定的获取渠道',selected=0,remark='B',question_id=455  WHERE id=1826;
UPDATE option_info  SET context='openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入',selected=0,remark='D',question_id=456  WHERE id=1832;
UPDATE option_info  SET context='整包使用开源软件，版本名称可以根据产品版本定制命名',selected=0,remark='D',question_id=457  WHERE id=1836;
UPDATE option_info  SET context='配置状态发布',selected=0,remark='C',question_id=458  WHERE id=1839;
UPDATE option_info  SET context='gcc lto优化引入二进制差异，直接删除lto优化选项消除差异，无需对业务性能进行测试',selected=0,remark='D',question_id=459  WHERE id=1844;
UPDATE option_info  SET context='故障预测预防是一种被动故障处理技术',selected=0,remark='B',question_id=460  WHERE id=1846;
UPDATE option_info  SET context='切换第三方版本X的新版本，确保能享受供应商完整的保障能力',selected=0,remark='A',question_id=461  WHERE id=1849;
UPDATE option_info  SET context='软件产品工程SPLE',selected=0,remark='A',question_id=462  WHERE id=1853;
UPDATE option_info  SET context='若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程（需开源），通过隔离层进行交互',selected=0,remark='A',question_id=463  WHERE id=1857;
UPDATE option_info  SET context='可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互',selected=0,remark='C',question_id=463  WHERE id=1859;
UPDATE option_info  SET context='静态工具扫描',selected=0,remark='A',question_id=464  WHERE id=1861;
UPDATE option_info  SET context='关键字扫描',selected=0,remark='B',question_id=464  WHERE id=1862;
UPDATE option_info  SET context='自上而下分析法',selected=0,remark='D',question_id=464  WHERE id=1864;
UPDATE option_info  SET context='在研发过程中对各个环节的关键基础设施落地严格的风险应对措施，如对代码仓尽心更严格的访问、完整性方案设计，保障产品软件开发过程的完整性，一致性，不因恶意篡改导致最终的功能特性与客户预期不相符，设置损害客户利益',selected=0,remark='A',question_id=465  WHERE id=1865;
UPDATE option_info  SET context='产品要做到结果风险可控，须通过有效执行研发过程的安全活动控制项要求。',selected=0,remark='B',question_id=465  WHERE id=1866;
UPDATE option_info  SET context='产品要做到具备威胁无处不在的视角，通过有效的基础设施及环境保护应对研发过程恶意篡改风险。',selected=0,remark='C',question_id=465  WHERE id=1867;
UPDATE option_info  SET context='合法合规',selected=0,remark='A',question_id=466  WHERE id=1869;
UPDATE option_info  SET context='网络安全风险',selected=0,remark='B',question_id=466  WHERE id=1870;
UPDATE option_info  SET context='生命周期情况',selected=0,remark='C',question_id=466  WHERE id=1871;
UPDATE option_info  SET context='开源软件的技术生态',selected=0,remark='D',question_id=466  WHERE id=1872;
UPDATE option_info  SET context='需求基线',selected=0,remark='D',question_id=467  WHERE id=1876;
UPDATE option_info  SET context='需求变更控制',selected=0,remark='B',question_id=468  WHERE id=1878;
UPDATE option_info  SET context='需求分析中，对不明确的功能需求，要进行细致调查后进行具体化。',selected=0,remark='A',question_id=469  WHERE id=1881;
UPDATE option_info  SET context='需求分析时，对项目目标，涉及的问题和场景，都需要考虑。',selected=0,remark='B',question_id=469  WHERE id=1882;
UPDATE option_info  SET context='需求分析过程中，需要将需求转化成形式化的功能规约，如需求规格说明书。',selected=0,remark='C',question_id=469  WHERE id=1883;
UPDATE option_info  SET context='对特殊的异常场景，不做分析。',selected=0,remark='A',question_id=470  WHERE id=1885;
UPDATE option_info  SET context='特性的可交付性和服务代表要求不一致。',selected=0,remark='B',question_id=470  WHERE id=1886;
UPDATE option_info  SET context='对性能的描述：整体系统的响应时间不小于2秒。',selected=0,remark='C',question_id=470  WHERE id=1887;
UPDATE option_info  SET context='用户可以根据图书名搜索到该图书',selected=0,remark='A',question_id=471  WHERE id=1889;
UPDATE option_info  SET context='系统可以查询到某用户当前已借的图书',selected=0,remark='B',question_id=471  WHERE id=1890;
UPDATE option_info  SET context='类图',selected=0,remark='B',question_id=472  WHERE id=1896;
UPDATE option_info  SET context='访问者模式(VISITOR)',selected=0,remark='C',question_id=473  WHERE id=1901;
UPDATE option_info  SET context='结构型模式可以在不破坏类封装性的基础上，实现新的功能。',selected=0,remark='A',question_id=474  WHERE id=1903;
UPDATE option_info  SET context='结构型模式可以创建一组类的统一访问接口。',selected=0,remark='C',question_id=474  WHERE id=1905;
UPDATE option_info  SET context='结构型模式可以在不破坏类封装性的基础上，使得类可以同不曾估计到的系统进行交互。',selected=0,remark='D',question_id=474  WHERE id=1906;
UPDATE option_info  SET context='参数化工厂方法',selected=0,remark='B',question_id=475  WHERE id=1908;
UPDATE option_info  SET context='所有语言的特点',selected=0,remark='C',question_id=475  WHERE id=1909;
UPDATE option_info  SET context='使用模板以避免创建子类',selected=0,remark='D',question_id=475  WHERE id=1910;
UPDATE option_info  SET context='当发现类A某个函数不仅仅适用于当前类，还适用于其他的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。',selected=0,remark='C',question_id=476  WHERE id=1913;
UPDATE option_info  SET context='根据函数所要达到的目的，即做什么。',selected=0,remark='B',question_id=477  WHERE id=1916;
UPDATE option_info  SET context='提取接口(Extract Interface)和提取超类(Extract Superclass)本质上是一回事，均可提取通用代码。',selected=0,remark='A',question_id=478  WHERE id=1919;
UPDATE option_info  SET context='隐藏委托关系会使代码层次更清晰，因此委托类的功能越多越好。',selected=0,remark='B',question_id=478  WHERE id=1920;
UPDATE option_info  SET context='将值域上移到父类会有效减少子类的成员变量，只需要做搬移值域，不需要搬移对该值域的操作方法。',selected=0,remark='D',question_id=478  WHERE id=1922;
UPDATE option_info  SET context='程序\"如果没有坏(功能可用)，就不要去修复它\"，是代码是否需要选择重构的必要条件。',selected=0,remark='B',question_id=479  WHERE id=1924;
UPDATE option_info  SET context='重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。',selected=0,remark='C',question_id=479  WHERE id=1925;
UPDATE option_info  SET context='重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。',selected=0,remark='D',question_id=479  WHERE id=1926;
UPDATE option_info  SET context='使用各种有利于解耦的设计模式常常会导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。',selected=0,remark='E',question_id=479  WHERE id=1927;
UPDATE option_info  SET context='开发初期如果类中有一个字段location标识位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。',selected=0,remark='A',question_id=480  WHERE id=1928;
UPDATE option_info  SET context='我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显示地关闭ResultSet和Statement，保持代码简单和简洁。',selected=0,remark='A',question_id=481  WHERE id=1931;
UPDATE option_info  SET context='我们需要先关闭Connection，接着显示地关闭ResultSet和Statement。',selected=0,remark='B',question_id=481  WHERE id=1932;
UPDATE option_info  SET context='我们需要先关闭Connection，接着显示地关闭Statement和ResultSet。',selected=0,remark='C',question_id=481  WHERE id=1933;
UPDATE option_info  SET context='我们需要先关闭ResultSet和Statement，然后Connection就自动关闭了，不需要显示地关闭Connection。',selected=0,remark='D',question_id=481  WHERE id=1934;
UPDATE option_info  SET context='同一个预共享秘钥，既可以用于认证，又可以用于完整性保护。',selected=0,remark='A',question_id=482  WHERE id=1935;
UPDATE option_info  SET context='完整性',selected=0,remark='B',question_id=483  WHERE id=1940;
UPDATE option_info  SET context='一个帐号或帐号组只能拥有必需的角色和必需的权限，一个角色只能拥有必需的权限，不分配不必要的权限。',selected=0,remark='A',question_id=484  WHERE id=1943;
UPDATE option_info  SET context='权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则',selected=0,remark='B',question_id=484  WHERE id=1944;
UPDATE option_info  SET context='不使用“administrator”、 “Root”、”sa”、“sysman”、“Supervisor”和其他特权帐号来运行应用程序或连接Web服务接口、数据库和其它中间件。',selected=0,remark='C',question_id=484  WHERE id=1945;
UPDATE option_info  SET context='根据运行所需的操作系统权限的不同以及暴露给用户的访问权限的不同，对其进行划分和授权，采用不同权限的帐号运行。',selected=0,remark='D',question_id=484  WHERE id=1946;
UPDATE option_info  SET context='时间宏引起的差异',selected=0,remark='A',question_id=485  WHERE id=1947;
UPDATE option_info  SET context='JITTest.doubleIndex被内联',selected=0,remark='A',question_id=486  WHERE id=1951;
UPDATE option_info  SET context='JITTest.doubleIndex会被编译成机器码执行',selected=0,remark='B',question_id=486  WHERE id=1952;
UPDATE option_info  SET context='JITTest.sum会被编译成机器码执行',selected=0,remark='C',question_id=486  WHERE id=1953;
UPDATE option_info  SET context='性能优化的三个指标：吞吐量、延迟、内存占用',selected=0,remark='C',question_id=487  WHERE id=1957;
UPDATE option_info  SET context='JVM垃圾收集三个基本原则：\nMinor GC最多原则、GC内存最大化原则、GC调优(吞吐量、延迟、内存占用)的3选2原则。',selected=0,remark='D',question_id=487  WHERE id=1958;
UPDATE option_info  SET context='在java8中，-Xdebug可有可无',selected=0,remark='A',question_id=488  WHERE id=1959;
UPDATE option_info  SET context='transport类型可以是dt_socket和dt_shmem，其中dt_shmem只适用于windows平台',selected=0,remark='B',question_id=488  WHERE id=1960;
UPDATE option_info  SET context='使用-Xrunjdwp后，将以调试模式启动java进程',selected=0,remark='C',question_id=488  WHERE id=1961;
UPDATE option_info  SET context='onthrow指明是否在发生指定异常时中断执行，进行调试',selected=0,remark='E',question_id=488  WHERE id=1963;
UPDATE option_info  SET context='语义分析及生成字节码',selected=0,parsing='解析：词法分析 语法分析 填充符号表 语义分析 字节码生成',remark='A',question_id=489  WHERE id=1964;
UPDATE option_info  SET context='词法分析及填充符号表',selected=0,parsing='解析：词法分析 语法分析 填充符号表 语义分析 字节码生成',remark='B',question_id=489  WHERE id=1965;
UPDATE option_info  SET context='注解处理',selected=0,parsing='解析：词法分析 语法分析 填充符号表 语义分析 字节码生成',remark='D',question_id=489  WHERE id=1967;
UPDATE option_info  SET context='为了提供开发和维护效率，各个子系统和模块可以自由选择最熟悉的脚本来编写构建脚本，可以多种脚本语言并存。',selected=0,remark='D',question_id=490  WHERE id=1972;
UPDATE option_info  SET context='构建工程和脚本应该对工具安装路径做明确的要求，明确写在脚本中，比如工具必须安装在/usr/build/tools目录下，这样方便对构建环境进行规范化和溯源。',selected=0,remark='D',question_id=491  WHERE id=1977;
UPDATE option_info  SET context='compile：默认的依赖范围，编译、测试、运行期都需要',selected=0,remark='A',question_id=492  WHERE id=1978;
UPDATE option_info  SET context='provided：表示在编译和测试期需要，但是运行期不需要',selected=0,remark='B',question_id=492  WHERE id=1979;
UPDATE option_info  SET context='test：表示在测试期需要，编译和运行时都不需要',selected=0,remark='C',question_id=492  WHERE id=1980;
UPDATE option_info  SET context='system：表示非maven仓库引入的jar，使用时需要显式的用systemPath元素提供一个本地系统中jar文件的路径',selected=0,remark='D',question_id=492  WHERE id=1981;
UPDATE option_info  SET context='runtime：表示在测试和运行期需要，但在编译的时候不需要',selected=0,remark='E',question_id=492  WHERE id=1982;
UPDATE option_info  SET context='jmap –histo 17212',selected=0,remark='A',question_id=493  WHERE id=1983;
UPDATE option_info  SET context='相比server模式，JVM client模式可以获得更好的性能',selected=0,remark='B',question_id=494  WHERE id=1988;
UPDATE option_info  SET context='独立性',selected=0,remark='D',question_id=495  WHERE id=1994;
UPDATE option_info  SET context='4',selected=0,remark='C',question_id=496  WHERE id=1997;
UPDATE option_info  SET context='@Test(expected = IllegalArgumentException.class)\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nperson.canVote();\n}',selected=0,remark='B',question_id=497  WHERE id=2000;
UPDATE option_info  SET context='@Rule\npublic ExpecetedException thrown = ExpecetedException.none();\n@Test\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nthrown.expect(IllegalArgumentException.class);\nperson.canVote();\n}',selected=0,remark='C',question_id=497  WHERE id=2001;
UPDATE option_info  SET context='两个分支分别修改了不同文件的内容。',selected=0,remark='D',question_id=498  WHERE id=2006;
UPDATE option_info  SET context='可以使用Excel文件来作为配置文件。',selected=0,remark='A',question_id=499  WHERE id=2007;
UPDATE option_info  SET context='对单个软件项目的软件生产过程中产生业务对象的过程及对象间的关系的准确记录。',selected=0,remark='A',question_id=500  WHERE id=2012;
UPDATE option_info  SET context='开发过程中软件跨项目的需求以及配套依赖的关系的准确记录。',selected=0,remark='B',question_id=500  WHERE id=2013;
UPDATE option_info  SET context='客户要求使用开源软件新版本，产品A集成使用的开源软件B近3年无人维护且无可替代软件，产品A将开源软件B及修改的代码在github以新项目C开源并且自行维护，再将开源软件C集成到产品A中进行使用。',selected=0,remark='A',question_id=501  WHERE id=2016;
UPDATE option_info  SET context='产品A软件开发在编写代码时，拷贝Apache license 2.1、 的 XXC++ 开源代码中的排序算法实现代码，已提升开发效率。',selected=0,remark='C',question_id=501  WHERE id=2018;
UPDATE option_info  SET context='产品A 使用的开源软件被爆出存在严重漏洞（CVSS>7）,产品A的安全SE分析发现该漏洞涉及的代码A未调用，可以不需要对产品A的现网版本打补丁。',selected=0,remark='D',question_id=501  WHERE id=2019;
UPDATE option_info  SET context='某产品共130K行代码，其中仅10行代码与开源代码相似度较高; 该10行代码可以确认为自研代码。',selected=0,remark='E',question_id=501  WHERE id=2020;
UPDATE option_info  SET context='为保证来源可靠，业务版本使用的开源及第三方软件必须来自保存在华为PDM库中的软件副本',selected=0,remark='A',question_id=502  WHERE id=2021;
UPDATE option_info  SET context='非A/B类红线安全问题，如果是高风险(CVSS评分>=7)的安全问题则在版本发布前解决或规避，如果是中低风险(CVSS评分<7)的安全问题则可待供应商/合作方修复后再同步其修复版本',selected=0,remark='B',question_id=502  WHERE id=2022;
UPDATE option_info  SET context='在业务版本的研发过程中，开源及第三方软件需随产品代码一起开展产品网络安全测试',selected=0,remark='C',question_id=502  WHERE id=2023;
UPDATE option_info  SET context='A类红线和高风险(CVSS评分>=7)的B类红线问题在版本发布前解决或规避，中低风险(CVSS评分<7)的B类红线问题则可待供应商/合作方修复后再同步修复版本',selected=0,remark='D',question_id=502  WHERE id=2024;
UPDATE option_info  SET context='是指开发和运维一起参与到整个软件生命周期过程的实践-从开发、测试、部署上线到维护。',selected=0,remark='C',question_id=503  WHERE id=2027;
UPDATE option_info  SET context='CFHGEDBK',selected=0,remark='D',question_id=504  WHERE id=2032;
UPDATE option_info  SET context='没有错误',selected=0,remark='D',question_id=505  WHERE id=2036;
UPDATE option_info  SET context='try (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}',selected=0,remark='B',question_id=506  WHERE id=2038;
UPDATE option_info  SET context='基数排序',selected=0,remark='B',question_id=507  WHERE id=2041;
UPDATE option_info  SET context='计数排序',selected=0,remark='C',question_id=508  WHERE id=2046;
UPDATE option_info  SET context='HashSet<String> set = ...;\nif (set.contains(\"Martin\")) {\n...\n}',selected=0,remark='C',question_id=509  WHERE id=2050;
UPDATE option_info  SET context='public final class Sinleton {\nprivate static class Sinleton {\nprivate static Sinleton instance = new Sinleton();\n}\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nreturn SinletonHolder.instance;\n}\n}',selected=0,remark='B',question_id=510  WHERE id=2053;
UPDATE option_info  SET context='public final class Sinleton {\nprivate static volatile Sinleton instance;\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nif (instance == null) {\nsynchronized (Sinleton.class) {\nif (instance == null) {\ninstance = new Sinleton();\n}\n}\n}\nreturn instance;\n}\n}',selected=0,remark='C',question_id=510  WHERE id=2054;
UPDATE option_info  SET context='public final class Sinleton {\nprivate static Sinleton instance = new Sinleton();\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nreturn instance;\n}\n}',selected=0,remark='D',question_id=510  WHERE id=2055;
UPDATE option_info  SET context='static class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<？ super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}',selected=0,remark='A',question_id=511  WHERE id=2056;
UPDATE option_info  SET context='static class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}',selected=0,remark='D',question_id=511  WHERE id=2059;
UPDATE option_info  SET context='线程DEADLOCK_TEST-1处于死锁状态',selected=0,remark='A',question_id=512  WHERE id=2060;
UPDATE option_info  SET context='线程DEADLOCK_TEST-2处于死锁状态',selected=0,remark='B',question_id=512  WHERE id=2061;
UPDATE option_info  SET context='线程DEADLOCK_TEST-3处于死锁状态',selected=0,remark='C',question_id=512  WHERE id=2062;
UPDATE option_info  SET context='public class LeftRightLock {\nprivate final Object left = new Object();\nprivate final Object right = new Object();\npublic void functionA() {\nsynchronized (left) {\nsynchronized (right) {\ndoSomething();\n}\n}\n}\npublic void functionB() {\nsynchronized (right) {\nsynchronized(left) {\ndoSomething();\n}\n}\n}\n}\n......',selected=0,remark='A',question_id=513  WHERE id=2064;
UPDATE option_info  SET context='public void transferMony(Account fromAccount, Account toAccount, int amount) {\nsynchronized (fromAccount) {\nsynchronized(toAccount) {\nfromAccount.debit(amount);\ntoAccount.credit(amount);\n}\n}\n}',selected=0,remark='B',question_id=513  WHERE id=2065;
UPDATE option_info  SET context='public class Taxi {\nprivate Point location;\nprivate Point destinztion;\nprivate final Dispatcher dispatcher;\npublic Taxi(Dispatcher dispatcher) {\nthis.dispatcher = dispatcher;\n}\npublic synchronized Point getLocation() {\nreturn location;\n}\npublic synchronized void setLocation(Point location) {\nthis.location = location;\nif (this.location.equals(destinztion)) {\ndispatcher.notifyAvailable(this);\n}\n}\n......\n}\npublic class Dispatcher {\nprivate final Set<Taxi> taxis = new HashSet<>();\nprivate final Set<Taxi> availableTaxis = new HashSet<>();\npublic synchronized void notifyAvailable(Taxi taxi) {\navailableTaxis.add(taxi);\n}\npublic synchronized Image getImage() {\nfinal Image image = new Image();\nfor (final Taxi taxi : taxis) {\nimage.drawMarket(taxi.getLocation());\n}\nreturn image;\n}\n......\n}',selected=0,remark='C',question_id=513  WHERE id=2066;
UPDATE option_info  SET context='private final ExecutorService executor = Executors.newSingleThreadExecutor();\npublic void renderPage() throws InterruptedException, ExecutionException {\nFuture<String> page = executor.submit(new RenderPageTask());\nframe.set(page.get());\n}\npublic class RenderPageTask implements Callable<String> {\n@Override\npublic String call() throws Exception {\nfinal Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));\nfinal Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));\nreturn header.get() + \"page\" + foot.get();\n}\n}',selected=0,remark='D',question_id=513  WHERE id=2067;
UPDATE option_info  SET context='平台版本不需要实施数字签名',selected=0,remark='D',question_id=514  WHERE id=2071;
UPDATE option_info  SET context='源代码与二进制版本的对应关系应该通过配置库、产品软件全量信息树等手段进行管理，不能靠人的责任心保障正确性。',selected=0,remark='B',question_id=515  WHERE id=2073;
UPDATE option_info  SET context='-nowarn',selected=0,remark='B',question_id=516  WHERE id=2077;
UPDATE option_info  SET context='-Xlint:none',selected=0,remark='C',question_id=516  WHERE id=2078;
UPDATE option_info  SET context='可以查看java系统参数',selected=0,remark='B',question_id=517  WHERE id=2081;
UPDATE option_info  SET context='开源软件社区发布的补丁要和自研修改的补丁做成一个patch进行统一管理。',selected=0,remark='C',question_id=518  WHERE id=2086;
UPDATE option_info  SET context='3',selected=0,remark='A',question_id=519  WHERE id=2088;
UPDATE option_info  SET context='system：适用于所有阶段，会随着项目一起发布。',selected=0,remark='D',question_id=520  WHERE id=2095;
UPDATE option_info  SET context='老张应该将该架构设计文档提交评审流程，评审通过后进行基线',selected=0,remark='B',question_id=521  WHERE id=2097;
UPDATE option_info  SET context='架构设计文档是关键的配置项，老张应该对架构设计文档进行配置项识别，按照配置项管理要求归档在统一的配置中',selected=0,remark='C',question_id=521  WHERE id=2098;
UPDATE option_info  SET context='老张要按照配置项命名规范对架构设计文档进行规范化命名，而不能随意命名为相似的名称',selected=0,remark='D',question_id=521  WHERE id=2099;
UPDATE option_info  SET context='static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid, high, key);\n} else {\nreturn recursive(arr, low, mid - 1, key);\n}\n}',selected=0,remark='A',question_id=522  WHERE id=2100;
UPDATE option_info  SET context='static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high + low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid - 1, high, key);\n} else {\nreturn recursive(arr, low, mid + 1, key);\n}\n}',selected=0,remark='B',question_id=522  WHERE id=2101;
UPDATE option_info  SET context='static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, low, mid - 1, key);\n} else {\nreturn recursive(arr, mid + 1, high, key);\n}\n}',selected=0,remark='D',question_id=522  WHERE id=2103;
UPDATE option_info  SET context='line 1',selected=0,parsing='解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg',remark='A',question_id=523  WHERE id=2104;
UPDATE option_info  SET context='line 2',selected=0,parsing='解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg',remark='E',question_id=523  WHERE id=2108;
UPDATE option_info  SET context='line 3',selected=0,parsing='解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg',remark='G',question_id=523  WHERE id=2110;
UPDATE option_info  SET context='3',selected=0,remark='A',question_id=524  WHERE id=2111;
UPDATE option_info  SET context='0',selected=0,remark='C',question_id=524  WHERE id=2113;
UPDATE option_info  SET context='1',selected=0,remark='D',question_id=524  WHERE id=2114;
UPDATE option_info  SET context='1.0',selected=0,parsing='解析：Maven依赖冲突解决原则是 1) 最短路径优先 2）同路径先声明优先',remark='A',question_id=525  WHERE id=2115;
UPDATE option_info  SET context='只能保护栈的不可执行',selected=0,remark='B',question_id=526  WHERE id=2120;
UPDATE option_info  SET context='根据函数所要达到的目的，即做什么',selected=0,remark='B',question_id=527  WHERE id=2124;
UPDATE option_info  SET context='程序“如果没有坏（功能可用），就不要去修复它”，是代码是否需要选择重构的必要条件。',selected=0,remark='B',question_id=528  WHERE id=2128;
UPDATE option_info  SET context='重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。',selected=0,remark='C',question_id=528  WHERE id=2129;
UPDATE option_info  SET context='重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。',selected=0,remark='D',question_id=528  WHERE id=2130;
UPDATE option_info  SET context='使用各种有利于解耦的设计模式常常回导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。',selected=0,remark='E',question_id=528  WHERE id=2131;
UPDATE option_info  SET context='开发初期如果一个类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。',selected=0,remark='A',question_id=529  WHERE id=2132;
UPDATE option_info  SET context='对于返回数组或者容器的方法，应返回长度为0的数组或容器',selected=0,remark='C',question_id=530  WHERE id=2137;
UPDATE option_info  SET context='类的字段',selected=0,remark='A',question_id=531  WHERE id=2139;
UPDATE option_info  SET context='方法参数',selected=0,remark='B',question_id=531  WHERE id=2140;
UPDATE option_info  SET context='方法',selected=0,remark='C',question_id=531  WHERE id=2141;
UPDATE option_info  SET context='局部变量',selected=0,remark='D',question_id=531  WHERE id=2142;
UPDATE option_info  SET context='软件架构设计',selected=0,remark='B',question_id=532  WHERE id=2144;
UPDATE option_info  SET context='配置状态发布',selected=0,remark='C',question_id=533  WHERE id=2148;
UPDATE option_info  SET context='完整性',selected=0,remark='A',question_id=534  WHERE id=2150;
UPDATE option_info  SET context='一致性',selected=0,remark='C',question_id=534  WHERE id=2152;
UPDATE option_info  SET context='可追溯性',selected=0,remark='D',question_id=534  WHERE id=2153;
UPDATE option_info  SET context='根据实际的特性接口变更规则，通过便跟过流程更新已基线的特性设计文档',selected=0,remark='A',question_id=535  WHERE id=2154;
UPDATE option_info  SET context='引入灰度发布，功能先对小范围用户开放，然后增量开放给其他用户',selected=0,remark='B',question_id=536  WHERE id=2159;
UPDATE option_info  SET context='引入自动化测试，减少测试人员手工测试可能导致的错误',selected=0,remark='C',question_id=536  WHERE id=2160;
UPDATE option_info  SET context='自动化产品的部署和回滚，降低失败对用户的影响时间',selected=0,remark='D',question_id=536  WHERE id=2161;
UPDATE option_info  SET context='预生产环境数据准备要接近生产环境，可以更好的针对生产环境数据进行验证',selected=0,remark='E',question_id=536  WHERE id=2162;
UPDATE option_info  SET context='系统设计方案缺少对B单板业务的自动故障检测和故障恢复功能，是造成业务长时间中断的主要原因',selected=0,remark='A',question_id=537  WHERE id=2163;
UPDATE option_info  SET context='原设计方案缺少对异常报文的容器处理能力，是导致B单板业务全部中断的主要原因',selected=0,remark='B',question_id=537  WHERE id=2164;
UPDATE option_info  SET context='机密性',selected=0,remark='A',question_id=538  WHERE id=2167;
UPDATE option_info  SET context='完整性',selected=0,remark='B',question_id=538  WHERE id=2168;
UPDATE option_info  SET context='可用性',selected=0,remark='C',question_id=538  WHERE id=2169;
UPDATE option_info  SET context='通过分析利益相关人的可信诉求而确定',selected=0,remark='A',question_id=539  WHERE id=2171;
UPDATE option_info  SET context='参考相关行业共识而确定',selected=0,remark='C',question_id=539  WHERE id=2173;
UPDATE option_info  SET context='参考相关国际标准而确定',selected=0,remark='D',question_id=539  WHERE id=2174;
UPDATE option_info  SET context='参考产品相关可信认证要求而确定',selected=0,remark='E',question_id=539  WHERE id=2175;
UPDATE option_info  SET context='仿冒',selected=0,remark='A',question_id=540  WHERE id=2177;
UPDATE option_info  SET context='篡改',selected=0,remark='B',question_id=540  WHERE id=2178;
UPDATE option_info  SET context='抵赖',selected=0,remark='C',question_id=540  WHERE id=2179;
UPDATE option_info  SET context='信息泄露',selected=0,remark='D',question_id=540  WHERE id=2180;
UPDATE option_info  SET context='拒绝服务',selected=0,remark='E',question_id=540  WHERE id=2181;
UPDATE option_info  SET context='权限提升',selected=0,remark='F',question_id=540  WHERE id=2182;
UPDATE option_info  SET context='组件',selected=0,remark='A',question_id=541  WHERE id=2184;
UPDATE option_info  SET context='接口',selected=0,remark='B',question_id=541  WHERE id=2185;
UPDATE option_info  SET context='基于产品架构视图进行威胁分析',selected=0,remark='A',question_id=542  WHERE id=2188;
UPDATE option_info  SET context='重点分析业务组件和接口',selected=0,remark='B',question_id=542  WHERE id=2189;
UPDATE option_info  SET context='组织级(organization level)',selected=0,remark='B',question_id=543  WHERE id=2193;
UPDATE option_info  SET context='业务级(business level)',selected=0,remark='C',question_id=543  WHERE id=2194;
UPDATE option_info  SET context='技术级(system level)',selected=0,remark='D',question_id=543  WHERE id=2195;
UPDATE option_info  SET context='韧性(Resilience)',selected=0,remark='A',question_id=544  WHERE id=2196;
UPDATE option_info  SET context='安全(Security)',selected=0,remark='B',question_id=544  WHERE id=2197;
UPDATE option_info  SET context='隐私(Privacy)',selected=0,remark='C',question_id=544  WHERE id=2198;
UPDATE option_info  SET context='安全(Safety)',selected=0,remark='D',question_id=544  WHERE id=2199;
UPDATE option_info  SET context='可靠(Reliability)',selected=0,remark='E',question_id=544  WHERE id=2200;
UPDATE option_info  SET context='可用(Availability)',selected=0,remark='F',question_id=544  WHERE id=2201;
UPDATE option_info  SET context='故障检测',selected=0,remark='A',question_id=545  WHERE id=2204;
UPDATE option_info  SET context='故障诊断',selected=0,remark='B',question_id=545  WHERE id=2205;
UPDATE option_info  SET context='故障隔离',selected=0,remark='C',question_id=545  WHERE id=2206;
UPDATE option_info  SET context='故障恢复',selected=0,remark='D',question_id=545  WHERE id=2207;
UPDATE option_info  SET context='可干预性',selected=0,remark='B',question_id=546  WHERE id=2209;
UPDATE option_info  SET context='多样性使用异构技术（例如，硬件，软件，固件，协议），这样增加了网络建设的成本，运维的难度，是不可取的',selected=0,remark='D',question_id=547  WHERE id=2215;
UPDATE option_info  SET context='同一个预共享密钥，既可以用于认证，又可以用于完整性保护',selected=0,remark='A',question_id=548  WHERE id=2216;
UPDATE option_info  SET context='身份管理和访问控制、数据安全、信息保护流程和步骤、安全运维',selected=0,parsing='解析：Half of the people think the answer is ABD and the other half think the answer is ABCD(source)\n15 CSF(Cybersecurity Framework)核心框架包含5个功能IPDRR，其中P代表保护功能（Protect Function），保护功能可以限制或抑制网络安全事件的潜在影响。以下哪一组全部属于核心架构中的保护功能项(A)\nB. 身份管理和访问控制、数据安全、安全运维、安全连续监控\nC. 身份管理和访问控制、数据安全、安全运维、风险评估\nD. 身份管理和访问控制、数据安全、信息保护流程和步骤、安全连续监控',remark='A',question_id=549  WHERE id=2220;
UPDATE option_info  SET context='FMEA分析表',selected=0,parsing='解析：安全编码Top问题\n17 FMEA是一种可靠性分析方法，可以用于产品的设计阶段。下列哪个选项不是设计阶段FMEA分析的输出(D)\nB. 软件故障需求管理\nC. 硬件故障需求管理\nD. 软件功能需求',remark='A',question_id=550  WHERE id=2221;
UPDATE option_info  SET context='服务降级',selected=0,remark='C',question_id=551  WHERE id=2224;
UPDATE option_info  SET context='偶然失效期',selected=0,remark='A',question_id=552  WHERE id=2226;
UPDATE option_info  SET context='早期失效期',selected=0,remark='B',question_id=552  WHERE id=2227;
UPDATE option_info  SET context='耗损失效期',selected=0,remark='D',question_id=552  WHERE id=2229;
UPDATE option_info  SET context='进程间通信（包括管道、消息、共享内存、socket、RPC等）',selected=0,remark='A',question_id=553  WHERE id=2231;
UPDATE option_info  SET context='函数参数（对于API）、全局变量（在本函数内，其它线程会修改全局变量）',selected=0,remark='B',question_id=553  WHERE id=2232;
UPDATE option_info  SET context='用户输入（包括命令行、界面）、用户态数据（对于内核程序）',selected=0,remark='C',question_id=553  WHERE id=2233;
UPDATE option_info  SET context='文件（包括程序的配置文件）、注册表、网络、环境变量',selected=0,remark='D',question_id=553  WHERE id=2234;
UPDATE option_info  SET context='安全风险发生可能性和业务影响性',selected=0,remark='D',question_id=554  WHERE id=2238;
UPDATE option_info  SET context='决定个人数据处理的目的及方式',selected=0,remark='A',question_id=555  WHERE id=2239;
UPDATE option_info  SET context='作为数据处理者的法国供应商，基于成本考虑将数据转移到德国处理',selected=0,remark='A',question_id=556  WHERE id=2243;
UPDATE option_info  SET context='对于不引起系统故障只导致系统或服务KPI下降的亚健康异常不需要检测',selected=0,remark='B',question_id=557  WHERE id=2248;
UPDATE option_info  SET context='将系统进行划分，以限制成功攻击的传播和损害',selected=0,remark='D',question_id=558  WHERE id=2254;
UPDATE option_info  SET context='时间检查（如：心跳检测）',selected=0,remark='C',question_id=559  WHERE id=2257;
UPDATE option_info  SET context='所有的软件bug都会导致安全漏洞',selected=0,remark='A',question_id=560  WHERE id=2259;
UPDATE option_info  SET context='网络安全',selected=0,remark='C',question_id=561  WHERE id=2265;
UPDATE option_info  SET context='隐私保护',selected=0,remark='D',question_id=561  WHERE id=2266;
UPDATE option_info  SET context='数据级',selected=0,remark='A',question_id=562  WHERE id=2267;
UPDATE option_info  SET context='应用级',selected=0,remark='B',question_id=562  WHERE id=2268;
UPDATE option_info  SET context='业务级',selected=0,remark='C',question_id=562  WHERE id=2269;
UPDATE option_info  SET context='差分隐私',selected=0,remark='A',question_id=563  WHERE id=2271;
UPDATE option_info  SET context='　业务保证原则：确保在出现大流量冲击时所有业务不被丢弃',selected=0,remark='B',question_id=564  WHERE id=2276;
UPDATE option_info  SET context='不利情况发生后恢复业务',selected=0,remark='A',question_id=565  WHERE id=2279;
UPDATE option_info  SET context='不利情况下维持核心业务',selected=0,remark='B',question_id=565  WHERE id=2280;
UPDATE option_info  SET context='限制不利情况发生时的损害',selected=0,remark='C',question_id=565  WHERE id=2281;
UPDATE option_info  SET context='降低攻击成功可能性',selected=0,remark='D',question_id=565  WHERE id=2282;
UPDATE option_info  SET context='测试方案设计',selected=0,remark='B',question_id=566  WHERE id=2284;
UPDATE option_info  SET context='故障预测预防是一种被动故障处理技术',selected=0,remark='B',question_id=567  WHERE id=2288;
UPDATE option_info  SET context='在研发过程中对各个环节的关键基础设施落地严格的风险应对措施，如对代码仓尽心更严格的访问、完整性方案设计，保障产品软件开发过程的完整性，一致性，不因恶意篡改导致最终的功能特性与客户预期不相符，设置损害客户利益',selected=0,remark='A',question_id=568  WHERE id=2291;
UPDATE option_info  SET context='产品要做到结果风险可控，须通过有效执行研发过程的安全活动控制项要求。',selected=0,remark='B',question_id=568  WHERE id=2292;
UPDATE option_info  SET context='产品要做到具备威胁无处不在的视角，通过有效的基础设施及环境保护应对研发过程恶意篡改风险。',selected=0,remark='C',question_id=568  WHERE id=2293;
UPDATE option_info  SET context='基于故障机理模型的故障预测',selected=0,remark='A',question_id=569  WHERE id=2295;
UPDATE option_info  SET context='基于数据驱动的故障预测',selected=0,remark='D',question_id=569  WHERE id=2298;
UPDATE option_info  SET context='重试设计',selected=0,remark='A',question_id=570  WHERE id=2299;
UPDATE option_info  SET context='一个账号或账号组只能拥有必须的角色和必须的权限，一个角色只能拥有必需的权限，不分配不必要的权限，符合“权限最小化原则”',selected=0,remark='A',question_id=571  WHERE id=2303;
UPDATE option_info  SET context='账户登录失败N此后可以暂时锁定账户X分钟，符合“失败-默认安全原则”',selected=0,remark='B',question_id=571  WHERE id=2304;
UPDATE option_info  SET context='对资源访问的共享数量和使用应尽可能最小化，符合“最小公共化原则”',selected=0,remark='C',question_id=571  WHERE id=2305;
UPDATE option_info  SET context='将直接对外交互的高权限高风险进程拆分为两个进程，一个负责外部交互，一个负责内部业务逻辑，符合“权限分离原则”',selected=0,remark='D',question_id=571  WHERE id=2306;
UPDATE option_info  SET context='产品架构采用必要的冗余设计措施',selected=0,remark='A',question_id=572  WHERE id=2307;
UPDATE option_info  SET context='冗余设计相关的要素如故障检测和回复措施得到合理设计和验证',selected=0,remark='B',question_id=572  WHERE id=2308;
UPDATE option_info  SET context='采用更高可靠性等级的器件',selected=0,remark='C',question_id=572  WHERE id=2309;
UPDATE option_info  SET context='采用必要的简化设计措施，降低复杂度',selected=0,remark='D',question_id=572  WHERE id=2310;
UPDATE option_info  SET context='容灾设计重点在于业务接管，数据可靠性不是其重点',selected=0,remark='B',question_id=573  WHERE id=2312;
UPDATE option_info  SET context='冗余系统如果发生了影响业务的软、硬件故障后，应能通过主备倒换或符合分担实现自动的故障恢复',selected=0,remark='A',question_id=574  WHERE id=2315;
UPDATE option_info  SET context='在非冗余系统中，对于影响业务的软件故障或硬件故障瞬间故障，可通过自动触发单板复位或局部复位等方式，系统恢复正常状态',selected=0,remark='B',question_id=574  WHERE id=2316;
UPDATE option_info  SET context='系统自动执行故障恢复动作，可大大减少业务中断时间，但注意一定要保证判断的准确性，避免误动作。同需要在系统设计复杂性和减少业务中断时间之间权衡',selected=0,remark='C',question_id=574  WHERE id=2317;
UPDATE option_info  SET context='保证数据传输的机密性',selected=0,remark='B',question_id=575  WHERE id=2320;
UPDATE option_info  SET context='动态链接使用，或者进程隔离',selected=0,remark='C',question_id=576  WHERE id=2325;
UPDATE option_info  SET context='产品使用第三方软件须先使用后申请',selected=0,remark='C',question_id=577  WHERE id=2328;
UPDATE option_info  SET context='已知安全问题及漏洞扫描，如：对业界公开的严重级别的安全漏洞已修复',selected=0,remark='A',question_id=578  WHERE id=2330;
UPDATE option_info  SET context='病毒扫描',selected=0,remark='B',question_id=578  WHERE id=2331;
UPDATE option_info  SET context='软件完整性及一致性检查',selected=0,remark='C',question_id=578  WHERE id=2332;
UPDATE option_info  SET context='产品在TR4前必须进行开源认证',selected=0,remark='A',question_id=579  WHERE id=2334;
UPDATE option_info  SET context='开源入库选型—>开源使用申请—>开源认证—>开源义务履行—>漏洞闭环处理',selected=0,remark='A',question_id=580  WHERE id=2338;
UPDATE option_info  SET context='如果需要使用优选等级为‘DXX（禁选）’或者EOX的软件，或者应用技术风险为‘高’的软件，需要提供对应备案纪要',selected=0,remark='A',question_id=581  WHERE id=2339;
UPDATE option_info  SET context='优先使用优选等级为‘B （优选）’的版本',selected=0,remark='B',question_id=581  WHERE id=2340;
UPDATE option_info  SET context='不允许使用应用技术风险为‘高’的软件',selected=0,remark='C',question_id=581  WHERE id=2341;
UPDATE option_info  SET context='不允许使用优选等级为‘DXX（禁选）’和EOX的软件',selected=0,remark='D',question_id=581  WHERE id=2342;
UPDATE option_info  SET context='如果待入库的的开源及第三方软件在PDM中已存在，需要引入新版本',selected=0,remark='A',question_id=582  WHERE id=2343;
UPDATE option_info  SET context='如果待入库的开源及第三方软件在PDM中已存在，且版本号未更新，但供应商因为修改bug等原因更新了软件包',selected=0,remark='B',question_id=582  WHERE id=2344;
UPDATE option_info  SET context='如果待入库的开源及第三方软件在PDM中不存在',selected=0,remark='C',question_id=582  WHERE id=2345;
UPDATE option_info  SET context='XXXX.3..19',selected=0,remark='C',question_id=583  WHERE id=2349;
UPDATE option_info  SET context='客户要求使用开源软件新版本，产品A集成使用的开源软件B近3年无人维护且无可代替软件，产品A将该开源软件B及修改的代码在GitHub以新项目C开源并自行维护，再将开源软件C集成到产品A中使用。',selected=0,remark='A',question_id=584  WHERE id=2351;
UPDATE option_info  SET context='产品A使用的开源软件被爆出存在严重漏洞(CVSSL>7)，产品A的安全SE分析发现该漏洞涉及的代码产品A未调用，可以不需要对产品A的现网版本打补丁。',selected=0,remark='B',question_id=584  WHERE id=2352;
UPDATE option_info  SET context='产品A软件开发人员在编写代码时，拷贝Apache license 2.0的XXC++开源软件中的排序算法实现代码，以提升开发效率。',selected=0,remark='C',question_id=584  WHERE id=2353;
UPDATE option_info  SET context='某产品共130K行代码，其中仅10行diamante与开源代码相似度较高；该10行代码可以确认为自研代码。',selected=0,remark='D',question_id=584  WHERE id=2354;
UPDATE option_info  SET context='产品A自研开发且对外开源XXComb软件，并捐献到Apache基金会成为顶级项目，产品B选用社区XXComb软件，仍应认定XXComb软件为自研软件。',selected=0,parsing='解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD',remark='A',question_id=585  WHERE id=2356;
UPDATE option_info  SET context='某产品开发一款仅给内部一线行销员工使用的APP（必须华为员工账号才能使用），并上架华为手机应用市场供一线行销人员下载，该APP通过静态链接方式集成使用了一款AGPL开源软件，由于只是内部一线行销员工使用，可以不需要履行开源义务。',selected=0,parsing='解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD',remark='B',question_id=585  WHERE id=2357;
UPDATE option_info  SET context='某员工在业余时间以个人名义，在GitHub开源了X项目；该员工在公司办公环境下载该X项目代码集成到产品A中使用，产品A不需要履行开源义务。',selected=0,parsing='解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD',remark='C',question_id=585  WHERE id=2358;
UPDATE option_info  SET context='公有云服务产品A通过静态链接的方式集成使用了license为GPL V2.0的开源软件，服务产品A可以不履行代码开源义务。',selected=0,parsing='解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD',remark='D',question_id=585  WHERE id=2359;
UPDATE option_info  SET context='业界无替代的第三方软件，可能存在供应风险，不建议引入',selected=0,parsing='解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353',remark='B',question_id=586  WHERE id=2361;
UPDATE option_info  SET context='未签署供应商网络安全协议的软件禁止引入',selected=0,parsing='解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353',remark='C',question_id=586  WHERE id=2362;
UPDATE option_info  SET context='为保证来源可靠，业务版本使用的开源及第三方软件必须来自保存在华为PDM库中的软件副本',selected=0,remark='A',question_id=587  WHERE id=2364;
UPDATE option_info  SET context='A类红线和高风险(CVSS评分>=7)的B类红线问题在版本发布前解决或规避，中低风险(CVSS评分<7)的B类红线问题则可待供应商/合作方修复后再同步其修复版本',selected=0,remark='B',question_id=587  WHERE id=2365;
UPDATE option_info  SET context='非A/B类红线安全问题，如果是高风险的安全问题则在版本发布前解决或规避，如果是中低风险的安全问题可待供应商/合作方修复后再同步其修复版本',selected=0,remark='C',question_id=587  WHERE id=2366;
UPDATE option_info  SET context='在业务版本的研发过程中，开源及第三方软件需随产品代码一起开源产品网络安全测试',selected=0,remark='D',question_id=587  WHERE id=2367;
UPDATE option_info  SET context='以动态链接的方式使用GPL软件，使产品代码不会被GPL传染',selected=0,remark='D',question_id=588  WHERE id=2371;
UPDATE option_info  SET context='openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入',selected=0,remark='C',question_id=589  WHERE id=2374;
UPDATE option_info  SET context='产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，将开源软件归到开源代码目录，并通过部分编译的形式，仅编译需要的特性进行打包发布',selected=0,remark='B',question_id=590  WHERE id=2377;
UPDATE option_info  SET context='产品P引入XX开源软件，工程师小A分析&应用后认为需要对开源代码进行少量修改才能满足产品需求，通过团队架构评审等确认后，将修改代码以Patch的方式进行管理',selected=0,remark='C',question_id=590  WHERE id=2378;
UPDATE option_info  SET context='判断原则是基于事实，没看过开源代码的人写出来的东西叫自研，其他任何形式直接参考开源写的代码都算开源',selected=0,remark='B',question_id=591  WHERE id=2381;
UPDATE option_info  SET context='切换第三方版本X的新版本，确保能享受供应商完整的保障能力',selected=0,parsing='解析：b8299143 chooses C whereas others(b8302521, b8338303, b8395535, b8214821, b8194499, b8186353, b8194499) chooseA',remark='A',question_id=592  WHERE id=2384;
UPDATE option_info  SET context='软件编码与构建',selected=0,remark='A',question_id=593  WHERE id=2388;
UPDATE option_info  SET context='需求分析与设计',selected=0,remark='B',question_id=593  WHERE id=2389;
UPDATE option_info  SET context='验证发布',selected=0,remark='D',question_id=593  WHERE id=2391;
UPDATE option_info  SET context='由于社区一直未采纳提交补丁，自己在社区中fork一个新项目出来维护',selected=0,remark='D',question_id=594  WHERE id=2395;
UPDATE option_info  SET context='Json-lib软件社区2013年后社区已无人贡献，建议产品独臂Jackson、fastJson、Gson等同类软件，结合产品使用场景，选择生态、license较友好的开源软件',selected=0,remark='B',question_id=595  WHERE id=2397;
UPDATE option_info  SET context='Log4j日志组件的作者2015年发布log4j2.X和logback；性能比log4j1.X高10倍，建议使用log4j1.X的产品考虑切换到log2.X或logback',selected=0,remark='D',question_id=595  WHERE id=2399;
UPDATE option_info  SET context='不同许可证的开源代码不存在兼容性问题(如GPL License与BSD License)，只需要申请后即可按规范使用。',selected=0,remark='D',question_id=596  WHERE id=2403;
UPDATE option_info  SET context='gcc lto优化引入二进制差异，直接删除lto优化选项消除差异，无需对业务性能进行测试',selected=0,remark='D',question_id=597  WHERE id=2407;
UPDATE option_info  SET context='合法合规',selected=0,remark='A',question_id=598  WHERE id=2408;
UPDATE option_info  SET context='网络安全风险',selected=0,remark='B',question_id=598  WHERE id=2409;
UPDATE option_info  SET context='生命周期情况',selected=0,remark='C',question_id=598  WHERE id=2410;
UPDATE option_info  SET context='开源软件的技术生态',selected=0,remark='D',question_id=598  WHERE id=2411;
UPDATE option_info  SET context='BSD类license，如Apache/BSD/MIT等，原则上没有对外开源要求',selected=0,remark='A',question_id=599  WHERE id=2412;
UPDATE option_info  SET context='MPL类软件若无修改，则无需对外开源',selected=0,remark='B',question_id=599  WHERE id=2413;
UPDATE option_info  SET context='GPL软件本身须开源，且具有传染性，与该软件在同一进程中运行的代码都必须对外开源',selected=0,remark='C',question_id=599  WHERE id=2414;
UPDATE option_info  SET context='假定软件A的License为GPL V2，软件B的License为BSD类，由于GPL V2的License可能导致产品整体被迫开源，而BSD类License商业更为友好，所以推荐使用软件B',selected=0,remark='A',question_id=600  WHERE id=2416;
UPDATE option_info  SET context='假定软件B的License为LGPL V2，如果选择软件B，为防止自研代码被传染，则只允许动态链接方式使用',selected=0,remark='B',question_id=600  WHERE id=2417;
UPDATE option_info  SET context='假定软件A的License为MPL类，如果选择软件A，则必须关注修改后对应的开源义务',selected=0,remark='C',question_id=600  WHERE id=2418;
UPDATE option_info  SET context='在B+树中的所有非叶子节点不仅起到索引的作用，还可以直接在非叶子节点中词到每个关键字对应的value',selected=0,remark='C',question_id=601  WHERE id=2422;
UPDATE option_info  SET context='若v不是T1的叶节点，则T1与T3可能不同',selected=0,remark='A',question_id=602  WHERE id=2424;
UPDATE option_info  SET context='若v是T1的叶节点，则T1与T3相同',selected=0,remark='D',question_id=602  WHERE id=2427;
UPDATE option_info  SET context='不确定',selected=0,remark='D',question_id=603  WHERE id=2431;
UPDATE option_info  SET context='顺序表插入变动的时间复杂度为O(n)',selected=0,remark='A',question_id=604  WHERE id=2432;
UPDATE option_info  SET context='顺序表按下表查找的时间复杂度为O(1)',selected=0,remark='B',question_id=604  WHERE id=2433;
UPDATE option_info  SET context='顺序表存储空间连续，即允许元素的随机访问',selected=0,remark='D',question_id=604  WHERE id=2435;
UPDATE option_info  SET context='95,22,91,24,94,71',selected=0,remark='D',question_id=605  WHERE id=2439;
UPDATE option_info  SET context='137',selected=0,remark='B',question_id=606  WHERE id=2441;
UPDATE option_info  SET context='491',selected=0,remark='D',question_id=606  WHERE id=2443;
UPDATE option_info  SET context='9',selected=0,remark='A',question_id=607  WHERE id=2444;
UPDATE option_info  SET context='10',selected=0,remark='B',question_id=607  WHERE id=2445;
UPDATE option_info  SET context='11',selected=0,remark='C',question_id=607  WHERE id=2446;
UPDATE option_info  SET context='CFHGEDBK',selected=0,remark='D',question_id=608  WHERE id=2451;
UPDATE option_info  SET context='dceab',selected=0,remark='C',question_id=609  WHERE id=2454;
UPDATE option_info  SET context='3',selected=0,remark='C',question_id=610  WHERE id=2458;
UPDATE option_info  SET context='a、b、c、d',selected=0,remark='A',question_id=611  WHERE id=2460;
UPDATE option_info  SET context='a、c、b、d',selected=0,remark='D',question_id=611  WHERE id=2463;
UPDATE option_info  SET context='队头、对位指针可能都要修改',selected=0,remark='D',question_id=612  WHERE id=2467;
UPDATE option_info  SET context='只有一个叶子结点',selected=0,remark='C',question_id=613  WHERE id=2470;
UPDATE option_info  SET context='T(n) = T(n-1) + O(n) 和 O(n^2)',selected=0,remark='C',question_id=614  WHERE id=2474;
UPDATE option_info  SET context='在函数中直接调用自己成为函数的直接递归调用',selected=0,remark='A',question_id=615  WHERE id=2476;
UPDATE option_info  SET context='递归是一种分而治之、将复杂问题转换成简单问题的求解方法',selected=0,remark='B',question_id=615  WHERE id=2477;
UPDATE option_info  SET context='递归可以使编写的程序简洁、结构清晰',selected=0,remark='C',question_id=615  WHERE id=2478;
UPDATE option_info  SET context='函数f1调用了函数f2又再次调用了函数f1，这种调用的方式我们称之为间接递归调用',selected=0,remark='E',question_id=615  WHERE id=2480;
UPDATE option_info  SET context='促进研发（应用程序/软件工程）、技术运营（运维）部门之间的沟通、协作与整合，持续交付可靠的软件产品和服务。',selected=0,remark='A',question_id=616  WHERE id=2481;
UPDATE option_info  SET context='DevOps是以业务驱动的软件交付方法。从需求到交付生产环境，研发与运维间紧密协的文化运动与实践。',selected=0,remark='B',question_id=616  WHERE id=2482;
UPDATE option_info  SET context='DevOps文化更注重沟通，快速获得用户反馈提升创新能力。',selected=0,remark='C',question_id=616  WHERE id=2483;
UPDATE option_info  SET context='冲刺',selected=0,remark='B',question_id=617  WHERE id=2486;
UPDATE option_info  SET context='计划',selected=0,remark='C',question_id=617  WHERE id=2487;
UPDATE option_info  SET context='每日站会',selected=0,remark='D',question_id=617  WHERE id=2488;
UPDATE option_info  SET context='评审会议',selected=0,remark='E',question_id=617  WHERE id=2489;
UPDATE option_info  SET context='个体与交互重于过程和工具',selected=0,remark='A',question_id=618  WHERE id=2491;
UPDATE option_info  SET context='可工作的软件重于完备的文档',selected=0,remark='B',question_id=618  WHERE id=2492;
UPDATE option_info  SET context='客户协作重于合同谈判',selected=0,remark='C',question_id=618  WHERE id=2493;
UPDATE option_info  SET context='响应变更重于遵循计划',selected=0,remark='D',question_id=618  WHERE id=2494;
UPDATE option_info  SET context='负责确保Scrum被理解并实施',selected=0,remark='A',question_id=619  WHERE id=2496;
UPDATE option_info  SET context='按需推动Scrum事件',selected=0,remark='B',question_id=619  WHERE id=2497;
UPDATE option_info  SET context='担当教练角色， 引领团队达到更高级的凝聚力、自组织和表现',selected=0,remark='D',question_id=619  WHERE id=2499;
UPDATE option_info  SET context='产品Backlog',selected=0,remark='B',question_id=620  WHERE id=2501;
UPDATE option_info  SET context='SprintBacklog',selected=0,remark='C',question_id=620  WHERE id=2502;
UPDATE option_info  SET context='产品增量',selected=0,remark='D',question_id=620  WHERE id=2503;
UPDATE option_info  SET context='产品负责人(Product Owner)',selected=0,remark='A',question_id=621  WHERE id=2504;
UPDATE option_info  SET context='Scrum Master',selected=0,remark='B',question_id=621  WHERE id=2505;
UPDATE option_info  SET context='开发团队',selected=0,remark='C',question_id=621  WHERE id=2506;
UPDATE option_info  SET context='模型简单过程易于理解',selected=0,remark='A',question_id=622  WHERE id=2508;
UPDATE option_info  SET context='反馈周期短',selected=0,remark='C',question_id=622  WHERE id=2510;
UPDATE option_info  SET context='无法应对需求快速变化的场景和领域',selected=0,remark='D',question_id=622  WHERE id=2511;
UPDATE option_info  SET context='系统之系统不可能是最小规模系统，如包含不同提供商提供的服务的较小的系统，大规模系统经常是系统之系统\"',selected=0,remark='D',question_id=623  WHERE id=2515;
UPDATE option_info  SET context='软件工程仅指实现软件生产开发的活动序列',selected=0,remark='B',question_id=624  WHERE id=2517;
UPDATE option_info  SET context='功能测试自动化',selected=0,remark='A',question_id=625  WHERE id=2520;
UPDATE option_info  SET context='自动化部署',selected=0,remark='B',question_id=625  WHERE id=2521;
UPDATE option_info  SET context='软件开发过程引入敏捷、精益思维，最小化需求范围(MVP)',selected=0,remark='C',question_id=625  WHERE id=2522;
UPDATE option_info  SET context='服务提供商会公开服务的信息，任何获得授权的用户都可以使用相应服务',selected=0,remark='A',question_id=626  WHERE id=2524;
UPDATE option_info  SET context='组织内部或外部的服务提供商都可以提供服务',selected=0,remark='B',question_id=626  WHERE id=2525;
UPDATE option_info  SET context='服务的用户能根据使用而不是提供商提供的服务来付费',selected=0,remark='C',question_id=626  WHERE id=2526;
UPDATE option_info  SET context='应用能够延迟服务绑定直到这些服务被部署或执行',selected=0,remark='D',question_id=626  WHERE id=2527;
UPDATE option_info  SET context='软件产品工程SPLE',selected=0,remark='A',question_id=627  WHERE id=2528;
UPDATE option_info  SET context='持续集成是频繁持续地将团队成员的工作进行集成',selected=0,parsing='解析：持续集成是一个将集成提前至开发周期早期阶段的软件开发实践方式，是指软件个人研发部分向软件整体部分交付，让构建、测试和集成代码更经常性地发生，并且每次集成都要通过自动化的构建来验证，使集成错误尽早被发现。',remark='B',question_id=628  WHERE id=2533;
UPDATE option_info  SET context='SaaS是向用户交付应用功能的方法，而SOA是应用系统的一种设计技术',selected=0,remark='D',question_id=629  WHERE id=2539;
UPDATE option_info  SET context='软件开发工具所提供的开发支持弱',selected=0,remark='B',question_id=630  WHERE id=2541;
UPDATE option_info  SET context='可以使用gcore输出进程的运行coredump快照作分析',selected=0,remark='A',question_id=631  WHERE id=2544;
UPDATE option_info  SET context='两个线程可能发生了互锁',selected=0,remark='B',question_id=631  WHERE id=2545;
UPDATE option_info  SET context='可以attach到进程，查看两个std::mutex的_owner信息，是否为对方线程ID',selected=0,remark='C',question_id=631  WHERE id=2546;
UPDATE option_info  SET context='将字符串数组调整到栈的高地址',selected=0,remark='D',question_id=632  WHERE id=2551;
UPDATE option_info  SET context='在栈底插入一个随机数防止栈溢出',selected=0,remark='E',question_id=632  WHERE id=2552;
UPDATE option_info  SET context='-fPIC\\-fPIE',selected=0,remark='A',question_id=633  WHERE id=2553;
UPDATE option_info  SET context='-fstack-protector-all 栈溢出保护',selected=0,remark='B',question_id=633  WHERE id=2554;
UPDATE option_info  SET context='-Wl,-z,relro          保护got表 - 部分重定向只读',selected=0,remark='C',question_id=633  WHERE id=2555;
UPDATE option_info  SET context='-Wl,-z,noexecstack    堆+栈不可执行',selected=0,remark='D',question_id=633  WHERE id=2556;
UPDATE option_info  SET context='-z,now                保护got表 - 全部重定向只读',selected=0,remark='E',question_id=633  WHERE id=2557;
UPDATE option_info  SET context='-s',selected=0,remark='B',question_id=634  WHERE id=2560;
UPDATE option_info  SET context='设置程序启动时优先加载[path]路径下的共享库',selected=0,remark='A',question_id=635  WHERE id=2563;
UPDATE option_info  SET context='设置[path]路径没有代码可执行权限',selected=0,remark='D',question_id=635  WHERE id=2566;
UPDATE option_info  SET context='将字符串数组调整到栈的高地址',selected=0,remark='D',question_id=636  WHERE id=2570;
UPDATE option_info  SET context='在栈底插入一个随机数防止栈溢出',selected=0,remark='E',question_id=636  WHERE id=2571;
UPDATE option_info  SET context='版本发布构建所用的环境，应该是封闭的，只能有任命的CIE可以访问环境。',selected=0,remark='D',question_id=637  WHERE id=2575;
UPDATE option_info  SET context='基于相同源码、环境、生产与客户现网部署逐比特一致的二进制',selected=0,remark='A',question_id=638  WHERE id=2576;
UPDATE option_info  SET context='随机差异要全部消除，除非能准确知晓这些差异的内容',selected=0,remark='B',question_id=638  WHERE id=2577;
UPDATE option_info  SET context='交付源码和二进制要保持一致',selected=0,remark='D',question_id=638  WHERE id=2579;
UPDATE option_info  SET context='A平台二进制及源码没有进行配置标识及基线，导致源码缺失',selected=0,remark='A',question_id=639  WHERE id=2580;
UPDATE option_info  SET context='产品正式发布的版本应配套使用A平台的正式发布版本，不应使用A平台的联调版本',selected=0,remark='B',question_id=639  WHERE id=2581;
UPDATE option_info  SET context='联调版本没有通过联调版本发布流程发布，而是通过文件共享方式私下进行传递',selected=0,remark='C',question_id=639  WHERE id=2582;
UPDATE option_info  SET context='具备在任意时刻都能交付二进制对应的准确源代码的能力',selected=0,remark='D',question_id=639  WHERE id=2583;
UPDATE option_info  SET context='其他自定义格式：1990+月-日-天-小时-分-秒的偏移量',selected=0,remark='A',question_id=640  WHERE id=2584;
UPDATE option_info  SET context='构建时刻距离1970/01/01秒数',selected=0,remark='B',question_id=640  WHERE id=2585;
UPDATE option_info  SET context='\"NOV1,2016，21：04：16“字符串',selected=0,remark='C',question_id=640  WHERE id=2586;
UPDATE option_info  SET context='“20170304180056\"字符串',selected=0,remark='D',question_id=640  WHERE id=2587;
UPDATE option_info  SET context='-Wl,-z,relro',selected=0,remark='B',question_id=641  WHERE id=2589;
UPDATE option_info  SET context='-pie',selected=0,remark='C',question_id=641  WHERE id=2590;
UPDATE option_info  SET context='-Wl,-z,noexecstack',selected=0,remark='D',question_id=641  WHERE id=2591;
UPDATE option_info  SET context='-fPIC是编译选项',selected=0,remark='B',question_id=642  WHERE id=2593;
UPDATE option_info  SET context='-fPIE -pie用于可执行程序',selected=0,remark='C',question_id=642  WHERE id=2594;
UPDATE option_info  SET context='允许使用-w选项屏蔽所有告警',selected=0,remark='A',question_id=643  WHERE id=2596;
UPDATE option_info  SET context='使用虚拟化OS工具在Windows上来模拟Linux进行构建',selected=0,remark='B',question_id=643  WHERE id=2597;
UPDATE option_info  SET context='构建模块较多时，对于子模块私有的配置，可以在模块内定义config.xml作为子模块的配置',selected=0,remark='D',question_id=643  WHERE id=2599;
UPDATE option_info  SET context='构建脚本必须使用相对路径，禁止使用绝对路径',selected=0,remark='A',question_id=644  WHERE id=2600;
UPDATE option_info  SET context='构建脚本成功返回0；构建失败，应以非0的退出码退出',selected=0,remark='B',question_id=644  WHERE id=2601;
UPDATE option_info  SET context='每个文件开头包含一个注释，简要概述文件源代码的功能、版权声明',selected=0,remark='C',question_id=644  WHERE id=2602;
UPDATE option_info  SET context='业务保证原则：确保在出现大流量冲击时所有业务不被丢弃',selected=0,remark='B',question_id=645  WHERE id=2605;
UPDATE option_info  SET context='多样性使用异构技术（例如 硬件、软件、固件、协议），这样增加了网络建设的成本，运维的难度，是不可取的',selected=0,remark='C',question_id=646  WHERE id=2610;
UPDATE option_info  SET context='系统的冗余设计是硬件独立完成的，与软件关系不大',selected=0,remark='B',question_id=647  WHERE id=2613;
UPDATE option_info  SET context='用户规模不超过5千人时，登录密码验证时间不超过2秒，用户规模不超过2万人时，登录密码验证不超过5秒',selected=0,remark='A',question_id=648  WHERE id=2616;
UPDATE option_info  SET context='代码检视',selected=0,remark='D',question_id=649  WHERE id=2623;
UPDATE option_info  SET context='测试方案设计',selected=0,remark='B',question_id=650  WHERE id=2625;
UPDATE option_info  SET context='现场更换单板',selected=0,remark='C',question_id=651  WHERE id=2630;
UPDATE option_info  SET context='加密秘钥要公开开放',selected=0,remark='C',question_id=652  WHERE id=2634;
UPDATE option_info  SET context='故障预测预防是一种被动故障处理技术',selected=0,remark='B',question_id=653  WHERE id=2637;
