/*
 Navicat Premium Data Transfer

 Source Server         : localhost
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : question

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 14/11/2021 21:37:18
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for option_info
-- ----------------------------
DROP TABLE IF EXISTS `option_info`;
CREATE TABLE `option_info`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `context` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '选项文字',
  `selected` int(20) NULL DEFAULT NULL COMMENT '是否选择',
  `parsing` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `remark` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `question_id` int(11) NOT NULL COMMENT '题目id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2640 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of option_info
-- ----------------------------
INSERT INTO `option_info` VALUES (3, '反射可以获取类的构造器测试', 0, '通过User.class.getConstructors()/.getDeclaredConstructors()能获取构造方法', 'A', 1);
INSERT INTO `option_info` VALUES (4, '反射可获以Method,通过invoke进行方法的调用；', 0, '通过getMethods能获取方法并使用invoke进行调用', 'B', 1);
INSERT INTO `option_info` VALUES (5, '反射可以获取注解（@Target为Runtime）信息；', 1, '没太懂@Target为Runtime这个的含义，只指定@Target是修饰自定义注解能修饰的位置', 'C', 1);
INSERT INTO `option_info` VALUES (6, '反射能够直接get(obj)获取私有的Field成员的值；', 1, '首先私有成员需要通过getDeclaredField获取，才能通过field.get(实列对象)来获取实例对象的值', 'D', 1);
INSERT INTO `option_info` VALUES (7, '编译时出现异常；', 0, '', 'A', 2);
INSERT INTO `option_info` VALUES (8, '正确运行，输出str1;', 0, '', 'B', 2);
INSERT INTO `option_info` VALUES (9, '正确运行，输出str2;', 0, '', 'C', 2);
INSERT INTO `option_info` VALUES (10, '运行时出现异常', 1, '运行时list.add(2, \"str2\");报错，因为ArrayList在添加前会调用rangeCheckForAdd方法判断当前索引是否大于了当前数组的size一句话list.add(2, \"str2\")只能替换不能追加', 'D', 2);
INSERT INTO `option_info` VALUES (11, '一个源文件按顺序包含版本、package、import、顶层、且用空行分隔；', 0, '', 'A', 3);
INSERT INTO `option_info` VALUES (12, '对于非空块和块状结构，左大括号放在行尾；', 0, '', 'B', 3);
INSERT INTO `option_info` VALUES (13, '空行不是代码，所以代码中多写几个空行没有关系；', 1, '', 'C', 3);
INSERT INTO `option_info` VALUES (14, '一个类或接口的声明部分应当按照类变、实例变量，构造器，方法的顺序出现，且用空行分隔；', 0, '', 'D', 3);
INSERT INTO `option_info` VALUES (15, 'java.io.FileNotFountException', 1, '', 'A', 4);
INSERT INTO `option_info` VALUES (16, 'java.io.IOException', 0, '', 'B', 4);
INSERT INTO `option_info` VALUES (17, 'java.util.MissResourceException', 0, '', 'C', 4);
INSERT INTO `option_info` VALUES (18, 'java.sql.SQLException', 0, '', 'D', 4);
INSERT INTO `option_info` VALUES (19, 'ORM的缓存机制可以提高数据操作性能Hibernate没有缓存机制；', 1, '', 'A', 5);
INSERT INTO `option_info` VALUES (20, 'ORM依赖于JDBC和DataSource;', 0, '', 'B', 5);
INSERT INTO `option_info` VALUES (21, 'ORM有多种实现，主流的Mybatis与Hibernate;', 0, '', 'C', 5);
INSERT INTO `option_info` VALUES (22, 'ORM、对象关系转换，即数据库的单条数据与Java对应之间的映射；', 0, '', 'D', 5);
INSERT INTO `option_info` VALUES (23, 'currentThread()方法返回当前线程的引用', 0, 'D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了', 'A', 6);
INSERT INTO `option_info` VALUES (24, '线程A通过调用interrupt()方法来中断其阻塞状态', 0, 'D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了', 'B', 6);
INSERT INTO `option_info` VALUES (25, '线程A中执行线程B的join()方法，则线程A等待直到B执行完成', 0, 'D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了', 'C', 6);
INSERT INTO `option_info` VALUES (26, '若线程A调用方法isAlive()返回值为false，则说明A正在执行中，也可能是可运行状态；isAlive为ture的时候，才是就绪态或运行态。', 1, 'D 若线程A调用方法isAlive()返回值为true，则说明A正在执行中，也可能是可运行状态；他的说法完全反了', 'D', 6);
INSERT INTO `option_info` VALUES (27, '创建转储文件时应当限制文件大小，不能创建超过业务进程承载能力的大文件', 0, 'D:看来权限是给高了，个人感觉是不是600就可以了', 'A', 7);
INSERT INTO `option_info` VALUES (28, '转储文件中如果有敏感数据，则必须进行匿名化处理，或者是对转储文件进行签名和加密', 0, 'D:看来权限是给高了，个人感觉是不是600就可以了', 'B', 7);
INSERT INTO `option_info` VALUES (29, '转储文件时如果会生成临时文件，需要保证在使用完毕后立即删除；', 0, 'D:看来权限是给高了，个人感觉是不是600就可以了', 'C', 7);
INSERT INTO `option_info` VALUES (30, '结合业务分析，该场景下的转储文件需要支持当前业务进行读写，所以转储文件的权限最好配置为640', 1, 'D:看来权限是给高了，个人感觉是不是600就可以了', 'D', 7);
INSERT INTO `option_info` VALUES (31, 'private', 0, '', 'A', 8);
INSERT INTO `option_info` VALUES (32, 'static', 0, '', 'B', 8);
INSERT INTO `option_info` VALUES (33, 'volatile', 0, '', 'C', 8);
INSERT INTO `option_info` VALUES (34, 'transient', 1, '', 'D', 8);
INSERT INTO `option_info` VALUES (35, '某产品在为了方便问题定位，在某些异常场景下，将无法处理的数据中的用户的电话，邮箱等用户标识信息打印在了日志汇中。', 0, '', 'A', 9);
INSERT INTO `option_info` VALUES (36, '某产品在数据库中存储了用户口令的哈希值，使用了SHA256哈希函数和安全随机数生成的4字节盐值（生日判定）', 0, '', 'B', 9);
INSERT INTO `option_info` VALUES (37, '某产品的业务需要使用加密算法，默认密钥直接在代码中写死，但是产品本身提供了替换加密密钥的能力', 0, '', 'C', 9);
INSERT INTO `option_info` VALUES (38, '某产品在有一个场景下由于传输的数据本身不是敏感数据并且数据不会发到信任边界外，所以两个服务在传输这些数据时使用了普通的套接字而未使用安全的套接字', 1, '', 'D', 9);
INSERT INTO `option_info` VALUES (39, '32位', 1, 'D:long类型在不同的操作系统才有区别', 'A', 10);
INSERT INTO `option_info` VALUES (40, '64位', 0, 'D:long类型在不同的操作系统才有区别', 'B', 10);
INSERT INTO `option_info` VALUES (41, '16位', 0, 'D:long类型在不同的操作系统才有区别', 'C', 10);
INSERT INTO `option_info` VALUES (42, '在32位系统上是32位，在64位系统上是64位', 0, 'D:long类型在不同的操作系统才有区别', 'D', 10);
INSERT INTO `option_info` VALUES (43, 'boolean isStop = “true”;', 0, '', 'A', 11);
INSERT INTO `option_info` VALUES (44, 'float fit = 3.1; // float fit = 3.1f;', 0, '', 'B', 11);
INSERT INTO `option_info` VALUES (45, 'int num = 1.0;', 0, '', 'C', 11);
INSERT INTO `option_info` VALUES (46, 'char ch = 1;（char可以容纳的数字范围是多少）', 1, '', 'D', 11);
INSERT INTO `option_info` VALUES (47, '345', 1, '', 'A', 12);
INSERT INTO `option_info` VALUES (48, '134', 0, '', 'B', 12);
INSERT INTO `option_info` VALUES (49, '2345', 0, '', 'C', 12);
INSERT INTO `option_info` VALUES (50, '1345', 0, '', 'D', 12);
INSERT INTO `option_info` VALUES (51, 'Error', 0, '', 'A', 13);
INSERT INTO `option_info` VALUES (52, 'Exception', 1, '', 'B', 13);
INSERT INTO `option_info` VALUES (53, 'RuntimeException', 0, '', 'C', 13);
INSERT INTO `option_info` VALUES (54, 'Throwable', 0, '', 'D', 13);
INSERT INTO `option_info` VALUES (55, '允许重复元素，元素无顺序', 0, '顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n', 'A', 14);
INSERT INTO `option_info` VALUES (56, '允许重复无素，元素有顺序', 0, '顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n', 'B', 14);
INSERT INTO `option_info` VALUES (57, '不允许重复元素，元素有顺序', 0, '顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n', 'C', 14);
INSERT INTO `option_info` VALUES (58, '不允许重复元素，元素无顺序', 1, '顺序一般为：插入顺序，自然顺序\nHashSet不重复，无序（注意int可能有序，估计是与hash有关？）\nLinkHashSet不重复，插入顺序（）\nTreeSet不重复，自然顺序\nArrayList重复，插入顺序\n\n\n', 'D', 14);
INSERT INTO `option_info` VALUES (59, 'Map<Integer, String> cityMap = new HashMap<Integer, String>() {\n    {\n        put(1, \"Nanjing\");\n        put(2, \"Beijing\");\n        put(3, \"Shanghai\");\n    }\n};', 0, 'D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}', 'A', 15);
INSERT INTO `option_info` VALUES (60, 'for (Map.Entry<Integer, String> city : cityMap.entrySet()) {\n    System.out.println(city.getValue());\n}', 0, 'D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}', 'B', 15);
INSERT INTO `option_info` VALUES (61, 'Map<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4,null);', 0, 'D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}', 'C', 15);
INSERT INTO `option_info` VALUES (62, 'Map<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 1, 'D：UnmodifiableMap是Collections的内部类实现了Map 顾名思义是不可修改的map在调用put、remove、clear相关方法时直接扔出异常\npublic void clear() {\n     throw new UnsupportedOperationException();\n}', 'D', 15);
INSERT INTO `option_info` VALUES (63, 'extends约束类型上限，如public int add (T n1, T n2); 表示方法参数必须是Number的子类型；', 0, 'A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n', 'A', 16);
INSERT INTO `option_info` VALUES (64, 'List numList = new ArrayList();\nList intList = new ArrayList();\n因为Integer是Number的子类，所以intList可以赋值给numberList', 1, 'A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n', 'B', 16);
INSERT INTO `option_info` VALUES (65, '对于同一个类，可以使用不同的泛型参数类型声明类型和方法；', 0, 'A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n', 'C', 16);
INSERT INTO `option_info` VALUES (66, '泛型定义时，一般使用E/T等大写字母表示泛化类型，这是类型的参考；当实例化时，使用具体的类型替代，这是实参', 0, 'A：（难道这个是通过返回值，来设置了必须是Number这种类型的吗，看来这是一种特殊的声明方法）\nB:（赋值是不可能的，不过可以addAll）\n', 'D', 16);
INSERT INTO `option_info` VALUES (67, '占用锁的线程在调用wait()后，会自动释放线程占有的锁', 0, 'A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？', 'A', 17);
INSERT INTO `option_info` VALUES (68, 'sychronized是JVM层面控制线程同步', 0, 'A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？', 'B', 17);
INSERT INTO `option_info` VALUES (69, '占用锁的线程在发生异常，会自动释放线程占用的锁', 0, 'A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？', 'C', 17);
INSERT INTO `option_info` VALUES (70, 'synchronized可用于处理读写互斥，读读不互斥的操作场景', 1, 'A 正确\nB 正确 sync是有原生jvm控制，lock是Java语言控制\nC 正确 sync会自动释放锁\nD Sync直接锁住整个对象 任何操作都互斥吧？', 'D', 17);
INSERT INTO `option_info` VALUES (71, 'ABCABC', 0, '', 'A', 18);
INSERT INTO `option_info` VALUES (72, 'Test', 0, '', 'B', 18);
INSERT INTO `option_info` VALUES (73, 'ABCDEABCDEABCDE', 0, '', 'C', 18);
INSERT INTO `option_info` VALUES (74, 'ABCDE', 1, '', 'D', 18);
INSERT INTO `option_info` VALUES (75, '^[0-9]*$', 0, '', 'A', 19);
INSERT INTO `option_info` VALUES (76, '^(0|[1-9][0-9]*)$', 0, '', 'B', 19);
INSERT INTO `option_info` VALUES (77, '^[1-9][0-9]*$', 1, '', 'C', 19);
INSERT INTO `option_info` VALUES (78, '(0|[1-9][0-9]*)', 0, '', 'D', 19);
INSERT INTO `option_info` VALUES (79, '类加载器之间是有层次结构', 0, '参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。', 'A', 20);
INSERT INTO `option_info` VALUES (80, '加载不到类，会抛出ClassNotFoundException();', 0, '参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。', 'B', 20);
INSERT INTO `option_info` VALUES (81, '如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；', 1, '参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。', 'C', 20);
INSERT INTO `option_info` VALUES (82, '如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载', 0, '参考：https://blog.csdn.net/codeyanbao/article/details/82875064\n一句话，先看父亲有没有，有就用，没有再在儿子有没有，都没有就报错（NotFoundClass）\n如果有人想替换系统级别的类：String.java。篡改它的实现，在这种机制下这些系统的类已经被Bootstrap classLoader加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。', 'D', 20);
INSERT INTO `option_info` VALUES (83, '使得第idx个参数的值设为val', 1, 'PreparedStatement的索引是从1开始', 'A', 21);
INSERT INTO `option_info` VALUES (84, '使得第idx-1个参数的值设为val', 0, 'PreparedStatement的索引是从1开始', 'B', 21);
INSERT INTO `option_info` VALUES (85, '使得第val-1个参数的值设为idx', 0, 'PreparedStatement的索引是从1开始', 'C', 21);
INSERT INTO `option_info` VALUES (86, '使得第val个参数的值设为idx', 0, 'PreparedStatement的索引是从1开始', 'D', 21);
INSERT INTO `option_info` VALUES (87, '可以设定Selector的监听事件，包括Connect/Accept/Read/Write;', 0, 'A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭', 'A', 22);
INSERT INTO `option_info` VALUES (88, 'Selector需要与Channel配合使用，Selector是Channel的复用器；', 0, 'A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭', 'B', 22);
INSERT INTO `option_info` VALUES (89, 'Selector本身不是一个文件，不用Close', 1, 'A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭', 'C', 22);
INSERT INTO `option_info` VALUES (90, 'Selector等事件就绪后，才会返回，避免了大量IO阻塞；', 0, 'A SelectionKey.OP_CONNECT\nSelectionKey.OP_ACCEPT\nSelectionKey.OP_READ\nSelectionKey.OP_WRITE\nB 对\nC 有close方法需要关闭', 'D', 22);
INSERT INTO `option_info` VALUES (91, 'private int count=0;\r\nprivate final Integer lock=new Integer(count);\r\npublic void doSomething(){\r\n    Synchronized(lock){\r\n    Count++;\r\n    }\r\n}', 1, '一句话，锁不要公用，容易阻塞/死锁', 'A', 23);
INSERT INTO `option_info` VALUES (92, 'private final String lock=\"LOCK”;\r\npublic void doSomething(){\r\n    synchronized (lock){\r\n    //..\r\n    }\r\n}', 0, '一句话，锁不要公用，容易阻塞/死锁', 'B', 23);
INSERT INTO `option_info` VALUES (93, 'Boolean isInitialized=Boolean.FALSE;\r\npublic void doSomething(){\r\n    synchronized (isInitialized){\r\n    //..\r\n    }\r\n}', 0, '一句话，锁不要公用，容易阻塞/死锁', 'C', 23);
INSERT INTO `option_info` VALUES (94, 'private int count=0;\r\nprivate final integer lock=count;\r\npublic void doSomething(){\r\n    synchronized (lock){\r\n        lock++;\r\n    }\r\n}', 0, '一句话，锁不要公用，容易阻塞/死锁', 'D', 23);
INSERT INTO `option_info` VALUES (95, 'enum Gender { male, femal}（形容词）', 0, 'A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对', 'A', 24);
INSERT INTO `option_info` VALUES (96, 'class Test {\n​private boolean isNotFount;\n}', 0, 'A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对', 'B', 24);
INSERT INTO `option_info` VALUES (97, 'class Test {\n​private String userName;\n}', 1, 'A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对', 'C', 24);
INSERT INTO `option_info` VALUES (98, 'class Test {\n​private static final int NUM_FIVE = 5;\n}', 0, 'A 枚举类型要大写\nB boolean 类型不能用is开头，因为自动的get会变成isNotFount()不符合规范\nC 正确\nD NUM_FIVE命名含义不对', 'D', 24);
INSERT INTO `option_info` VALUES (99, '1000000000​\r\n  1000000001​\r\n  1000000002​ \r\n  ….​\r\n  1000000010​', 0, 'System.out.println(1000000000f == 1000000010f);//true\n应该是float精度问题？？？', 'A', 25);
INSERT INTO `option_info` VALUES (100, '1000000000.0', 0, 'System.out.println(1000000000f == 1000000010f);//true\n应该是float精度问题？？？', 'B', 25);
INSERT INTO `option_info` VALUES (101, '输出结果不确定', 1, 'System.out.println(1000000000f == 1000000010f);//true\n应该是float精度问题？？？', 'C', 25);
INSERT INTO `option_info` VALUES (102, 'assert (Patten.matches(\"[0-9A-Za-z@]+\", dir);\n  Process proc = rt.exec(\"cmd.exe /c \" + dir);', 0, '没懂A为啥不对', 'A', 26);
INSERT INTO `option_info` VALUES (103, 'ArrayList<String> names;\n  //…\n  assert names.remove(null);', 0, '没懂A为啥不对', 'B', 26);
INSERT INTO `option_info` VALUES (104, 'assert index++ != MAX_LENGTH;', 0, '没懂A为啥不对', 'C', 26);
INSERT INTO `option_info` VALUES (105, 'boolean isNullsRemoved = names.remove(null);\n  assert isNullsRemoved', 1, '没懂A为啥不对', 'D', 26);
INSERT INTO `option_info` VALUES (106, '复制copy后，即把内存区域分成两个等分，from区域与to区域，都从from区分内存，回收即是把from区域还在使用的内存，copy到to内存,….，比较消耗内存；', 0, 'A：（看来不同的路线，选择机制还是不一样的）\nB：（这块需要反复计算才可以解决）\nC：（GC的回收过程中多种回收机制一起处理的结果）\nD：（这个缺点是很明显的）\n', 'A', 27);
INSERT INTO `option_info` VALUES (107, '压缩compact，重新整理达在使用的内存，一般做法是把还在使用的内存前移，填充回收空间，留下一大片连续的内存；压缩的问题是开销大；', 0, 'A：（看来不同的路线，选择机制还是不一样的）\nB：（这块需要反复计算才可以解决）\nC：（GC的回收过程中多种回收机制一起处理的结果）\nD：（这个缺点是很明显的）\n', 'B', 27);
INSERT INTO `option_info` VALUES (108, 'Java的GC机制会选择其中一种方法进行垃圾回收；', 1, 'A：（看来不同的路线，选择机制还是不一样的）\nB：（这块需要反复计算才可以解决）\nC：（GC的回收过程中多种回收机制一起处理的结果）\nD：（这个缺点是很明显的）\n', 'C', 27);
INSERT INTO `option_info` VALUES (109, '消除Sweep，直接清除，方法简单，但是会造成内存碎片，给再分配造成不可抑制的麻烦；', 0, 'A：（看来不同的路线，选择机制还是不一样的）\nB：（这块需要反复计算才可以解决）\nC：（GC的回收过程中多种回收机制一起处理的结果）\nD：（这个缺点是很明显的）\n', 'D', 27);
INSERT INTO `option_info` VALUES (110, 'URLClassLoader的签名校验依赖jar包里的公钥，因此不能使用URLClassLoader来校验jar的合法性；（里面可能被人修改过，里面是底层的源码）', 1, '', 'A', 28);
INSERT INTO `option_info` VALUES (111, '在JVM中将不同的ClassLoader实例加载的同一个类视为相同的类；（看来不同的加载器生成的类也是不同的）', 0, '', 'B', 28);
INSERT INTO `option_info` VALUES (112, '开发者不可以自定义类加载器；', 0, '', 'C', 28);
INSERT INTO `option_info` VALUES (113, 'public String getProductSummary(int index) {\n    return products[index];\n}\n//该代码中index未校验，可能相起数组越界访问', 0, 'B 这题好牵强哦~ 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验', 'A', 29);
INSERT INTO `option_info` VALUES (114, 'String userName = \"name”;\n  ResultSet rs = st.executeQuery(\"select * from user where name = ‘” + userName + \"’”);\n//该代码可能会产生SQL注入漏洞', 1, 'B 这题好牵强哦~ 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验', 'B', 29);
INSERT INTO `option_info` VALUES (115, 'Runtime.getRuntime().exec(\"cmd.exe /c dir ” + args[0]);\n//该代码可能会引起命令注入', 0, 'B 这题好牵强哦~ 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验', 'C', 29);
INSERT INTO `option_info` VALUES (116, 'String command = System.getProPerty(\"command”);\n  Runtime.getRuntime().exec(\"command”);\n//该代码可能会引起OS命令注入', 0, 'B 这题好牵强哦~ 不是因为里面符号导致，而是没有使用PreparedStatement或者拼接前对字符进行校验', 'D', 29);
INSERT INTO `option_info` VALUES (117, 'String encodeIP=HWEncoder.encodeForOS(new WindowsCodec(),args[0]);\n  String cmd=\"cmd.exe /c ping \"+encodeIP;', 0, '选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入\n选项B：使用正则校验，过滤特殊字符\n选项C：对文件的有效性进行校验\n选项D：无任何校验，可能导致命令注入', 'A', 30);
INSERT INTO `option_info` VALUES (118, 'if(Pattern.matches(\"[0-9A-Za-z@]+”, dir)) {\n    Process proc=rt.exec(cmd.exec/c\" + dir);\n   }', 0, '选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入\n选项B：使用正则校验，过滤特殊字符\n选项C：对文件的有效性进行校验\n选项D：无任何校验，可能导致命令注入', 'B', 30);
INSERT INTO `option_info` VALUES (119, 'File dir=new File(args[0]);\n   if(!validate(dir)){\n    System.out.println(\"An illegal directory”);\n   }', 0, '选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入\n选项B：使用正则校验，过滤特殊字符\n选项C：对文件的有效性进行校验\n选项D：无任何校验，可能导致命令注入', 'C', 30);
INSERT INTO `option_info` VALUES (120, 'Processor proc=rt.exec(\"cmd.exe /c dir ” + args[0]);', 1, '选项A:使用HWEncoder进行特殊字符转码，可以有效避免注入\n选项B：使用正则校验，过滤特殊字符\n选项C：对文件的有效性进行校验\n选项D：无任何校验，可能导致命令注入', 'D', 30);
INSERT INTO `option_info` VALUES (121, 'BindException异常泄露时可能造成开放端口列举', 0, '', 'A', 31);
INSERT INTO `option_info` VALUES (122, '当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤', 0, '', 'B', 31);
INSERT INTO `option_info` VALUES (123, 'FileNotFoundException会透露文件系统的结构信息，使得攻击者可以不断传入伪造的路径名称来重现出底层文件系统结构；', 0, '', 'C', 31);
INSERT INTO `option_info` VALUES (124, '可以在代码最外层捕获NullPointException防止代码出现预期之外的行为', 1, '', 'D', 31);
INSERT INTO `option_info` VALUES (125, 'FileNotFoundException、OutOfMemoryError、SQLException有可能会泄露敏感信息，但是JarException不属于敏感异常（这个也是敏感异常）（DOS攻击）', 1, '', 'A', 32);
INSERT INTO `option_info` VALUES (126, '对于调用开源三方件，三方件中抛出NullPointerException异常时，可以捕获NullPointerException，并对该异常进行处理', 0, '', 'B', 32);
INSERT INTO `option_info` VALUES (127, '输入校验是一个常用的防止通过异常泄露敏感信息的方式；', 0, '', 'C', 32);
INSERT INTO `option_info` VALUES (128, '必须做好日志的访问控制，防止日志被任意访问，导致信息泄露给非授权用户', 0, '', 'D', 32);
INSERT INTO `option_info` VALUES (129, '封包过Integer对象不适合作为锁使用是因为在一段范围内相同的值会共享同一个实例', 0, 'A:-128~127将存入缓存\nB:new出来的好像没有什么问题\nC:这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存\nD:都是用的这两个', 'A', 33);
INSERT INTO `option_info` VALUES (130, '使用new出来的Integer实例作为对象的内置锁可能导致死锁', 1, 'A:-128~127将存入缓存\nB:new出来的好像没有什么问题\nC:这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存\nD:都是用的这两个', 'B', 33);
INSERT INTO `option_info` VALUES (131, '在Java虚拟机中，调用intern()方法的String类似一个全局变量，使用intern()方法返回的String做锁对象可能会导致死锁；', 0, 'A:-128~127将存入缓存\nB:new出来的好像没有什么问题\nC:这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存\nD:都是用的这两个', 'C', 33);
INSERT INTO `option_info` VALUES (132, 'Boolean类型不适合作为锁使用，因为Boolean只有两个值：true和false，相同的值在Java虚拟机中共享同一个实例。', 0, 'A:-128~127将存入缓存\nB:new出来的好像没有什么问题\nC:这个锁迟迟不能获取，被别人拿着导致的问题，这是它的临时变量区域的内存\nD:都是用的这两个', 'D', 33);
INSERT INTO `option_info` VALUES (133, 'capacity：最大容量', 0, '', 'A', 34);
INSERT INTO `option_info` VALUES (134, 'flag：读写状态位', 1, '', 'B', 34);
INSERT INTO `option_info` VALUES (135, 'position：当前已经读到的字节数', 0, '', 'C', 34);
INSERT INTO `option_info` VALUES (136, 'limit：剩下的字节数（写入的时候奏效）', 0, '', 'D', 34);
INSERT INTO `option_info` VALUES (137, '\\t', 0, '', 'A', 35);
INSERT INTO `option_info` VALUES (138, '\\d', 0, '', 'B', 35);
INSERT INTO `option_info` VALUES (139, '\\W', 1, '', 'C', 35);
INSERT INTO `option_info` VALUES (140, '\\v', 0, '', 'D', 35);
INSERT INTO `option_info` VALUES (141, '\\w', 0, '', 'E', 35);
INSERT INTO `option_info` VALUES (142, '对多个资源、数据库表、对象同时加锁，需要保持一致的加锁顺序，否则可能导致死锁', 1, '', 'A', 36);
INSERT INTO `option_info` VALUES (143, '能用无锁数据结构，就不要用锁', 1, '', 'B', 36);
INSERT INTO `option_info` VALUES (144, '能用对象锁，就不要用类锁', 1, '', 'C', 36);
INSERT INTO `option_info` VALUES (145, '能锁区块，就不要锁方法体', 1, '', 'D', 36);
INSERT INTO `option_info` VALUES (146, '错误流', 1, '', 'A', 37);
INSERT INTO `option_info` VALUES (147, '监控流', 0, '', 'B', 37);
INSERT INTO `option_info` VALUES (148, '输出流', 1, '', 'C', 37);
INSERT INTO `option_info` VALUES (149, '输入流', 1, '', 'D', 37);
INSERT INTO `option_info` VALUES (150, 'public class GpsLocation implements Serializable {\n    private double from;\n    private double to;\n    private String id;\n    // non-sensitive field    \n    // other content\n}', 0, '防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确', 'A', 38);
INSERT INTO `option_info` VALUES (151, 'public class GpsLocation implements Serializable {\n    private double from;\n    private double to;\n    private String id;\n    // non-sensitive field\n    // other content\n    private static final ObjectStreamField[] serialPersistentFields = {\n        new ObjectStreamField(\"id\", String.class)\n    };\n}', 1, '防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确', 'B', 38);
INSERT INTO `option_info` VALUES (152, 'public class GpsLocation implements Serializable {\n    private volatile double from;\n    private volatile double to;\n    private String id;\n    // non-sensitive field\n    // other content\n}', 0, '防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确', 'C', 38);
INSERT INTO `option_info` VALUES (153, '.public class GpsLocation implements Serializable {\n    private transient double from;\n    private transient double to;\n    private String id;\n    // non-sensitive field\n    // other content\n}', 1, '防止字段被序列化方式：1. 使用transient修饰2. 明确只能序列化的字段/明确不能序列化的字段（方法待总结~）故BD正确', 'D', 38);
INSERT INTO `option_info` VALUES (154, 'public final class Helper {\n    public Helper() {\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        if (helper == null) {\n            synchronized (this) {\n                if (helper == null) {\n                    helper = new Helper();\n                }\n            }\n        }\n        return helper;\n    }\n}', 0, 'private Helper helper = null; 没有加volatile进行修饰，可能线程A和线程B都进入了第一个判断，但是A先获取锁，B被阻塞，A释放后创建了helper对象但是B又能获取锁创建一个新的helper对象违背单例模式原则', 'A', 39);
INSERT INTO `option_info` VALUES (155, 'public final class Helper {\n    private final int n;\n    public Helper(int n) {\n        this.n = n;\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        Helper h = helper;\n        if (h == null) {\n            synchronized (this) {\n                h = helper;\n                if (h == null) {\n                    h = new Helper(42);\n                    helper = h;\n                }\n            }\n        }\n        return h;\n    }\n}', 1, '在获取锁后重新赋值了h的值类似与volatile通知线程修改副本值，所以即使没有加入volatile修饰也是可行的', 'B', 39);
INSERT INTO `option_info` VALUES (156, 'public final class Helper {\n    private final int n;\n    public Helper(int n) {\n        this.n = n;\n    }\n}\nfinal class Foo {\n    private Helper helper = null;\n    public Helper getHelper() {\n        if (helper == null) {\n            synchronized (this) {\n                if (helper == null) {\n                    helper = new Helper(42);\n                }\n            }\n        }\n        return helper;\n    }\n}', 0, '同选项A一样选项', 'C', 39);
INSERT INTO `option_info` VALUES (157, 'public final class Helper {\n    public Helper() {\n    }\n}\nfinal class Foo {\n    private static class Holder {\n        static Helper helper = new Helper();\n    }\n    public Helper getInstance() {\n        return Holder.helper;\n    }\n}', 1, '饿汉式非懒加载，但是线程安全', 'D', 39);
INSERT INTO `option_info` VALUES (158, '执行shutdownNow方法后，不能再往线程池中添加任务，线程池不会立即退出，指导线程池中等待的任务全部处理完', 0, '', 'A', 40);
INSERT INTO `option_info` VALUES (159, '执行shutdown方法后，不能再往线程池中添加任务，线程池中之前提交的等待的任务不再执行，线程池立即退出', 0, '', 'B', 40);
INSERT INTO `option_info` VALUES (160, '执行shutdown方法中，不能再往线程池中添加任务，线程池中等待的任务会继续被处理，线程池直到所有的任务处理完成才会退出', 1, '', 'C', 40);
INSERT INTO `option_info` VALUES (161, '执行shutdownNow方法后，不能能再往线程池中添加任务，线程池视图停止所有正在执行的线程，不再处理池中等待的任务', 1, '', 'D', 40);
INSERT INTO `option_info` VALUES (162, 'TreeSet', 0, '', 'A', 41);
INSERT INTO `option_info` VALUES (163, 'HashTable', 1, '', 'B', 41);
INSERT INTO `option_info` VALUES (164, 'Vector', 1, '', 'C', 41);
INSERT INTO `option_info` VALUES (165, 'LinkedList', 0, '', 'D', 41);
INSERT INTO `option_info` VALUES (166, '5', 1, '首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished', 'A', 42);
INSERT INTO `option_info` VALUES (167, '4', 0, '首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished', 'B', 42);
INSERT INTO `option_info` VALUES (168, 'finished', 1, '首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished', 'C', 42);
INSERT INTO `option_info` VALUES (169, '6', 0, '首先到循环体里执行输出 5\n然后nr先运算nr=4\n然后比较4>5 false 退出循环体\n最后输出finished', 'D', 42);
INSERT INTO `option_info` VALUES (170, 'ACD', 0, '', 'A', 43);
INSERT INTO `option_info` VALUES (171, 'AAB', 1, '', 'B', 43);
INSERT INTO `option_info` VALUES (172, 'A', 0, '', 'C', 43);
INSERT INTO `option_info` VALUES (173, 'AB', 1, '', 'D', 43);
INSERT INTO `option_info` VALUES (174, 'File实例 不能用于封装目录只用于封装文件', 0, '', 'A', 44);
INSERT INTO `option_info` VALUES (175, '创建一个File类的实例将导致打开指定文件进行读写', 0, '', 'B', 44);
INSERT INTO `option_info` VALUES (176, 'File实例封装了指定文件的信息', 1, '', 'C', 44);
INSERT INTO `option_info` VALUES (177, 'File类位于jav.io包中', 1, '', 'D', 44);
INSERT INTO `option_info` VALUES (178, '在频率/周期性的逻辑中更要尽量 避免主动GC的调用', 1, '', 'A', 45);
INSERT INTO `option_info` VALUES (179, '在GC过程中的某些阶段程序会完全停顿，这会让程序失去响应，对系统造成非常大的风险（说的有道理）', 1, '', 'B', 45);
INSERT INTO `option_info` VALUES (180, '调用主动GC方法后，系统立即进行垃圾回收操作（系统也要找机会才行）', 0, '', 'C', 45);
INSERT INTO `option_info` VALUES (181, '如果触发了JVM的全量GC操作，会增加gc的次数，也就增加了程序因为GC而停顿的时间', 1, '', 'D', 45);
INSERT INTO `option_info` VALUES (182, '在对不可信数据进行校验时，禁止使用assert语句（）', 1, '', 'A', 46);
INSERT INTO `option_info` VALUES (183, '\"白名单\"方式净化的方式包括删除，编码 ，替换', 1, '', 'B', 46);
INSERT INTO `option_info` VALUES (184, '\"黑名单\"或\"负向\"校验，相对于正向校验，这是一种较弱的校验方式，如果不定期研究新的攻击方式并对校验的表达式进行日常更新 ，该校验方式就会很快过时', 1, '', 'C', 46);
INSERT INTO `option_info` VALUES (185, '尽可能使用接收一直合法数据的白名单策略（这个我是记得的）', 1, '', 'D', 46);
INSERT INTO `option_info` VALUES (186, '扩展类Thread', 1, '', 'A', 47);
INSERT INTO `option_info` VALUES (187, '实现Runnable接口', 1, '', 'B', 47);
INSERT INTO `option_info` VALUES (188, '实现接口Thread', 0, '', 'C', 47);
INSERT INTO `option_info` VALUES (189, '扩展类Runnable', 0, '', 'D', 47);
INSERT INTO `option_info` VALUES (190, '攻击者可以使用实现计算好的哈希列表在几秒钟之内破解口令', 1, 'C:hash不可逆', 'A', 48);
INSERT INTO `option_info` VALUES (191, '加入盐值可以减慢hash的计算速度，减慢攻击者的速度，不加盐值，攻击者计算哈希的速度大大增加', 1, 'C:hash不可逆', 'B', 48);
INSERT INTO `option_info` VALUES (192, '没有盐值，攻击者可以根据哈希值反向解密出原始口令', 0, 'C:hash不可逆', 'C', 48);
INSERT INTO `option_info` VALUES (193, '由于\"生日判定\"，攻击者可以快速找到一个口令，尤其是当数据库中的口令数量加大的时候（难道是有什么规律吗）', 1, 'C:hash不可逆', 'D', 48);
INSERT INTO `option_info` VALUES (194, 'ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包', 1, '', 'A', 49);
INSERT INTO `option_info` VALUES (195, 'AppClassLoader负责加载当前应用classpath下的所有jar包和类', 1, '', 'B', 49);
INSERT INTO `option_info` VALUES (196, 'BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者或被-Xbootclasspath参数指定 的路径中的所有类', 1, '', 'C', 49);
INSERT INTO `option_info` VALUES (197, 'BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader', 0, '', 'D', 49);
INSERT INTO `option_info` VALUES (198, '如果多种具体异常可以用同一个处理逻辑，可以通过捕获基类Exception来减少重复代码', 0, '', 'A', 50);
INSERT INTO `option_info` VALUES (199, '方法抛出的异常，应该与本身的抽象层次相对应', 1, '', 'B', 50);
INSERT INTO `option_info` VALUES (200, '对可容错处理的情况使用受检异常，对编程错误使用运行时异常', 1, '', 'C', 50);
INSERT INTO `option_info` VALUES (201, '一个方法不应抛出超过5个异常，并在Javadoc的@Throws标签中年记录每个抛出的异常及其条件', 1, '', 'D', 50);
INSERT INTO `option_info` VALUES (202, '程序代码编译时', 1, '程序代码编译时确定', 'A', 51);
INSERT INTO `option_info` VALUES (203, '类加载时', 0, '程序代码编译时确定', 'B', 51);
INSERT INTO `option_info` VALUES (204, '运行调用时', 0, '程序代码编译时确定', 'C', 51);
INSERT INTO `option_info` VALUES (205, 'int[] hello1 = {1,2,3,4};', 0, '', 'A', 52);
INSERT INTO `option_info` VALUES (206, 'int[] hello2 = new int[4] {1,2,3,4};', 1, '', 'B', 52);
INSERT INTO `option_info` VALUES (207, 'int[] hello3 = new int[] {1,2,3,4};', 0, '', 'C', 52);
INSERT INTO `option_info` VALUES (208, 'int[] hello4 = new int[4];', 0, '', 'D', 52);
INSERT INTO `option_info` VALUES (209, 'int b = Integer.parseInt(“2”);', 0, '解析：\nInteger.valueOf(value)在-128~127间，则会重用内存中缓存的对象', 'A', 53);
INSERT INTO `option_info` VALUES (210, 'Integer b = Integer.valueOf(“2”);', 1, '解析：\nInteger.valueOf(value)在-128~127间，则会重用内存中缓存的对象', 'B', 53);
INSERT INTO `option_info` VALUES (211, 'int', 0, '和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', 'A', 54);
INSERT INTO `option_info` VALUES (212, 'long', 0, '和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', 'B', 54);
INSERT INTO `option_info` VALUES (213, 'BigInteger', 1, '和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', 'C', 54);
INSERT INTO `option_info` VALUES (214, 'byte', 0, '和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。', 'D', 54);
INSERT INTO `option_info` VALUES (215, 'java.io.FileNotFoundException', 1, '', 'A', 55);
INSERT INTO `option_info` VALUES (216, 'java.net.BindException', 1, '', 'B', 55);
INSERT INTO `option_info` VALUES (217, 'java.util.ConcurrentModificationException', 1, '', 'C', 55);
INSERT INTO `option_info` VALUES (218, 'java.sql.SQLException', 1, '', 'D', 55);
INSERT INTO `option_info` VALUES (219, 'java.lang.NullPointerException', 0, '', 'E', 55);
INSERT INTO `option_info` VALUES (220, 'java.lang.IllegalArgumentException', 0, '', 'F', 55);
INSERT INTO `option_info` VALUES (221, 'List', 0, '', 'A', 56);
INSERT INTO `option_info` VALUES (222, 'Set', 0, '', 'B', 56);
INSERT INTO `option_info` VALUES (223, 'Queue', 0, '', 'C', 56);
INSERT INTO `option_info` VALUES (224, 'Map', 1, '', 'D', 56);
INSERT INTO `option_info` VALUES (225, '正确', 0, '', 'A', 57);
INSERT INTO `option_info` VALUES (226, '错误', 1, '', 'B', 57);
INSERT INTO `option_info` VALUES (227, 'FileWriter', 0, 'http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png', 'A', 58);
INSERT INTO `option_info` VALUES (228, 'RandomAccessFile', 0, 'http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png', 'B', 58);
INSERT INTO `option_info` VALUES (229, 'FileOutputStream', 0, 'http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png', 'C', 58);
INSERT INTO `option_info` VALUES (230, 'FileChannel', 1, 'http://image.huawei.com/tiny-lts/v1/images/1ff2b26ba27ee36205d6_714x321.png@900-0-90-f.png', 'D', 58);
INSERT INTO `option_info` VALUES (231, '大二进制文件读入', 0, '', 'A', 59);
INSERT INTO `option_info` VALUES (232, '小二进制文件读入', 0, '', 'B', 59);
INSERT INTO `option_info` VALUES (233, '小文本按行读入', 0, '', 'C', 59);
INSERT INTO `option_info` VALUES (234, '小文本按字节数读入', 0, '', 'D', 59);
INSERT INTO `option_info` VALUES (235, '结尾插入数据采用.APPEND而不是 .CREATE', 1, 'todo 感觉题不是很完善', 'E', 59);
INSERT INTO `option_info` VALUES (236, 'stream 流的数据ﾷ源只能是数组、容器、文件', 0, '', 'A', 60);
INSERT INTO `option_info` VALUES (237, 'stream 流跟迭代器一样，使用完再次使用时需要重新生成', 1, '', 'B', 60);
INSERT INTO `option_info` VALUES (238, 'stream的map是中间结果???', 0, '', 'C', 60);
INSERT INTO `option_info` VALUES (239, '???', 0, '', 'D', 60);
INSERT INTO `option_info` VALUES (240, 'private boolean isNotFound;', 0, '', 'A', 61);
INSERT INTO `option_info` VALUES (241, 'enum {male,female}', 0, '', 'B', 61);
INSERT INTO `option_info` VALUES (242, 'private String userName;', 1, '', 'C', 61);
INSERT INTO `option_info` VALUES (243, 'private static final int NUM_FIVE = 5;', 0, '', 'D', 61);
INSERT INTO `option_info` VALUES (244, 'RSA', 0, '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', 'A', 62);
INSERT INTO `option_info` VALUES (245, 'DES', 1, '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', 'B', 62);
INSERT INTO `option_info` VALUES (246, 'SKIPJACK', 0, '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', 'C', 62);
INSERT INTO `option_info` VALUES (247, 'MD5', 1, '\nhttp://3ms.huawei.com/km/blogs/details/8286589迷惑：SKIPJACK/RSA在1024位一下不推荐，DES和MD5绝对禁止，所以把答案从ABCD调整为BD', 'D', 62);
INSERT INTO `option_info` VALUES (248, 'java.io.FileNotFoundException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'A', 63);
INSERT INTO `option_info` VALUES (249, 'java.util.jar.JarException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'B', 63);
INSERT INTO `option_info` VALUES (250, 'java.util.MissingResourceException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'C', 63);
INSERT INTO `option_info` VALUES (251, 'java.security.acl.NotOwnerException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'D', 63);
INSERT INTO `option_info` VALUES (252, 'java.util.ConcurrentModificationException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'E', 63);
INSERT INTO `option_info` VALUES (253, 'javax.naming.InsufficientResourcesException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'F', 63);
INSERT INTO `option_info` VALUES (254, 'java.net.BindException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'G', 63);
INSERT INTO `option_info` VALUES (255, 'java.lang.OutOfMemoryError', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'H', 63);
INSERT INTO `option_info` VALUES (256, 'java.lang.StackOverflowError\nO java.sql.SQLException', 1, 'A:泄露文件系统结构和文件名列举\nB:泄露文件系统结构\nC:资源列举\nD:所有人列举\nE:可能提供线程不安全的代码信息\nF:服务器资源不足（可能有利于DoS攻击）\nG:当不信任客户端能够选择服务器端口时造成开放端口列举\nH:DoS\nI:DoS\nO:数据库结构，用户名列举', 'I', 63);
INSERT INTO `option_info` VALUES (257, 'private', 1, '', 'A', 64);
INSERT INTO `option_info` VALUES (258, 'public', 0, '', 'B', 64);
INSERT INTO `option_info` VALUES (259, 'final', 1, '', 'C', 64);
INSERT INTO `option_info` VALUES (260, 'abstract', 0, '', 'D', 64);
INSERT INTO `option_info` VALUES (261, 'abc@host.com', 1, '', 'A', 65);
INSERT INTO `option_info` VALUES (262, 'abc_@host.com', 1, '', 'B', 65);
INSERT INTO `option_info` VALUES (263, 'abc@host.org.com', 1, '', 'C', 65);
INSERT INTO `option_info` VALUES (264, 'abc_@host+com', 1, '', 'D', 65);
INSERT INTO `option_info` VALUES (265, 'Java.lang.OutOfMemoryError', 1, '', 'A', 66);
INSERT INTO `option_info` VALUES (266, 'Java.lang.StackOverflowError', 1, '', 'B', 66);
INSERT INTO `option_info` VALUES (267, 'javax.naming.InsufficientResourcesException', 1, '', 'C', 66);
INSERT INTO `option_info` VALUES (268, 'java.util.jar.JarException', 0, '', 'D', 66);
INSERT INTO `option_info` VALUES (269, 'A A', 0, '参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理', 'A', 67);
INSERT INTO `option_info` VALUES (270, '65 65', 0, '参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理', 'B', 67);
INSERT INTO `option_info` VALUES (271, 'A 65', 1, '参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理', 'C', 67);
INSERT INTO `option_info` VALUES (272, '65 A', 0, '参考博客：https://blog.csdn.net/j080624/article/details/81836930\n这里涉及到三元运算的类型处理', 'D', 67);
INSERT INTO `option_info` VALUES (273, 'sun zhao li qian', 0, '在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段', 'A', 68);
INSERT INTO `option_info` VALUES (274, 'sun zhao qian li', 0, '在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段', 'B', 68);
INSERT INTO `option_info` VALUES (275, 'sun zhao qian', 1, '在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段', 'C', 68);
INSERT INTO `option_info` VALUES (276, 'sun zhao li', 0, '在TreeSet中加入比较器后，会通过比较器来排序即 比较字段即key字段', 'D', 68);
INSERT INTO `option_info` VALUES (277, 'AES的ECB模式', 0, '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', 'A', 69);
INSERT INTO `option_info` VALUES (278, 'RSA', 1, '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', 'B', 69);
INSERT INTO `option_info` VALUES (279, 'DSA/ECDSA', 1, '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', 'C', 69);
INSERT INTO `option_info` VALUES (280, '加入盐值的SHA256', 1, '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', 'D', 69);
INSERT INTO `option_info` VALUES (281, 'DES', 0, '安全编码规范规则 9.2 禁止使用私有或者弱加密算法，加密算法分为对称加密算法和非对称加密算法。\n推荐使用的对称加密算法有：AES\n推荐使用的非对称算法有：RSA\n推荐使用的数字签名算法有：DSA/ECDSA\n除了以上提到的几种算法之外，还经常使用安全哈希算法（SHA256）等来验证消息的完整性。如果使用哈希算法来存储口令，则必须加入盐值（salt）', 'E', 69);
INSERT INTO `option_info` VALUES (282, 'CSRF', 1, '有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n', 'A', 70);
INSERT INTO `option_info` VALUES (283, 'SQL注入', 0, '有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n', 'B', 70);
INSERT INTO `option_info` VALUES (284, 'XSS', 1, '有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n', 'C', 70);
INSERT INTO `option_info` VALUES (285, 'XML注入', 0, '有点问题，答案到底是？\nXSS和CRSF\n\nXSS：Cross-site scripting，它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 具体分为反射型XSS和存储型XSS。\nCSRF: Cross-site request forgery跨站请求伪造，也被称为“One Click Attack”或者Session Riding，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。通俗的理解：攻击者盗用你的身份，以你的名义发送了恶意请求。\nXSS的防护\n输入校验\n输出编码\n为Cookie设置HttpOnly和Secure属性\nCRSF的防护\n验证HTTP头部的Referer字段\n在HTTP请求中添加Session Token\n要求用户输入验证码\n', 'D', 70);
INSERT INTO `option_info` VALUES (286, 'aa:0', 1, '这里finally的continue使得catch中的throw e无效了', 'A', 71);
INSERT INTO `option_info` VALUES (287, '抛出异常', 0, '这里finally的continue使得catch中的throw e无效了', 'B', 71);
INSERT INTO `option_info` VALUES (288, '编译错误', 0, '这里finally的continue使得catch中的throw e无效了', 'C', 71);
INSERT INTO `option_info` VALUES (289, '既打印aa:0 同时抛出异常', 0, '这里finally的continue使得catch中的throw e无效了', 'D', 71);
INSERT INTO `option_info` VALUES (290, '线程池不再接收新的任务，队列中等待任务不会执行', 0, 'shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。', 'A', 72);
INSERT INTO `option_info` VALUES (291, '线程池终止正在执行的线程', 0, 'shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。', 'B', 72);
INSERT INTO `option_info` VALUES (292, '线程池终止正在执行的线程，和B差不多', 0, 'shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。', 'C', 72);
INSERT INTO `option_info` VALUES (293, '线程池不再接收新的任务，队列中等待的任务会执行', 1, 'shutdown和shutdownnow区别？\n\n- shutdown()\n  - 将线程池状态置为SHUTDOWN,并不会立即停止\n  - 停止接收外部submit的任务\n  - 内部正在跑的任务和队列里等待的任务，会执行完\n- shutdownNow()\n  - 将线程池状态置为STOP。企图立即停止，事实上不一定：\n    - 跟shutdown()一样，先停止接收外部提交的任务\n    - 忽略队列里等待的任务\n    - 尝试将正在跑的任务interrupt中断\n    - 返回未执行的任务列表\n  - 它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。', 'D', 72);
INSERT INTO `option_info` VALUES (294, 'Thread.sleep()', 1, '在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', 'A', 73);
INSERT INTO `option_info` VALUES (295, 'java.net.Socket的阻塞方法', 0, '在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', 'B', 73);
INSERT INTO `option_info` VALUES (296, 'java.nio.channels.SocketChannel的阻塞方法', 1, '在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', 'C', 73);
INSERT INTO `option_info` VALUES (297, 'Thread.wait()', 1, '在编写需要中止的多线程程序时，必须选用能够响应interrupt的标准库或第三方库。Java标准库中的会阻塞的方法（如Thread.sleep()或者SocketChannel.write()）一般会在interrupt之后抛出InterruptedException。但有某些方法则不理会interrupt，如Socket.write()，必须回避这些方法。\n\n不好的例子：java.net.Socket类的方法阻塞时不响应interrupt！写多线程程序时必须回避这些类。', 'D', 73);
INSERT INTO `option_info` VALUES (298, 'staticA', 1, '', 'A', 74);
INSERT INTO `option_info` VALUES (299, 'CONSTANT', 1, '', 'B', 74);
INSERT INTO `option_info` VALUES (300, '“i am a string”', 1, '', 'C', 74);
INSERT INTO `option_info` VALUES (301, 'innerA', 1, '', 'D', 74);
INSERT INTO `option_info` VALUES (302, '动态链接', 1, '', 'A', 75);
INSERT INTO `option_info` VALUES (303, '局部变量表', 1, '', 'B', 75);
INSERT INTO `option_info` VALUES (304, '操作数栈', 1, '', 'C', 75);
INSERT INTO `option_info` VALUES (305, '方法返回地址', 1, '', 'D', 75);
INSERT INTO `option_info` VALUES (306, 'JITTest.doubleIndex被内联', 1, '默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行', 'A', 76);
INSERT INTO `option_info` VALUES (307, 'JITTest.doubleIndex会被编译成机器码执行', 1, '默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行', 'B', 76);
INSERT INTO `option_info` VALUES (308, 'JITTest.sum会被编译成机器码执行', 1, '默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行', 'C', 76);
INSERT INTO `option_info` VALUES (309, '拆箱和装箱', 0, '默认jvm参数时，jvm处在mixed模式运行，也就是部分代码解析执行，部分代码机器码执行', 'D', 76);
INSERT INTO `option_info` VALUES (310, '反射可以获取Method，通过invoke进行方法的调用；', 0, 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', 'A', 77);
INSERT INTO `option_info` VALUES (311, '反射不可以直接通过getField获取私有成员的值；', 0, 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', 'B', 77);
INSERT INTO `option_info` VALUES (312, '反射可以获取注解（@Target为Runtime）信息；', 1, 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', 'C', 77);
INSERT INTO `option_info` VALUES (313, '反射可以获取类的构造器；', 0, 'A 正确，可以通过getMethod获取该类或父类的公有方法，通过Method.invoke进行方法调用。\nB 正确，getField只能获取该类或父类的公有成员；\nC 错误，注解@Target没有Runtime，@Retention才有Runtime。\nD 正确，通过getConstructor获取公有构造器，通过getDeclaredConstructor获取所有构造器', 'D', 77);
INSERT INTO `option_info` VALUES (314, '抛出异常', 0, '这个暂时记住先。。。', 'A', 78);
INSERT INTO `option_info` VALUES (315, 'java', 0, '这个暂时记住先。。。', 'B', 78);
INSERT INTO `option_info` VALUES (316, 'java 抛出异常', 1, '这个暂时记住先。。。', 'C', 78);
INSERT INTO `option_info` VALUES (317, 'java java', 0, '这个暂时记住先。。。', 'D', 78);
INSERT INTO `option_info` VALUES (318, '1 3', 0, 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', 'A', 79);
INSERT INTO `option_info` VALUES (319, '3 1', 1, 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', 'B', 79);
INSERT INTO `option_info` VALUES (320, '1 1', 0, 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', 'C', 79);
INSERT INTO `option_info` VALUES (321, '3 3', 0, 'getFields方法获得某个类的所有的公共（public）的字段，包括父类中的字段；\ngetDeclaredFields方法获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。', 'D', 79);
INSERT INTO `option_info` VALUES (322, 'Optional可以被赋值为null', 0, 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', 'A', 80);
INSERT INTO `option_info` VALUES (323, 'Optional.of()可以用null做参数，返回Optional.empty()', 0, 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', 'B', 80);
INSERT INTO `option_info` VALUES (324, 'Optional.ofNullable(obj)，obj不为null时直接调用Optional.of(obj)', 1, 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', 'C', 80);
INSERT INTO `option_info` VALUES (325, 'Optiona.of()可以放置集合或对象。', 1, 'Optional不能被赋值为null，Optional.of()方法不能传null。但是Optional.ofNullable可以传null，但是底层存储的觉对不是null而是EMPTY对象', 'D', 80);
INSERT INTO `option_info` VALUES (326, '私有方法', 1, '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', 'A', 81);
INSERT INTO `option_info` VALUES (327, '属性', 0, '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', 'B', 81);
INSERT INTO `option_info` VALUES (328, '内部类', 0, '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', 'C', 81);
INSERT INTO `option_info` VALUES (329, '静态方法', 0, '一个属性、静态方法或内部类可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有属性、方法或内部类。上述成员被隐藏后，将阻止其被继承\n\n- 父类的实例方法会被子类的同名实例方法覆盖；父类的静态方法会被子类的同名静态方法隐藏\n- 父类的实例变量和类变量可以被子类的实例变量和类变量隐藏\n- 子类的方法可以通过super操作父类的成员变量\n- 通过父类引用可以暴露隐藏的变量和方法', 'D', 81);
INSERT INTO `option_info` VALUES (330, '123456 123456 123456', 0, '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'A', 82);
INSERT INTO `option_info` VALUES (331, '123456 123\\\\d 123456', 0, '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'B', 82);
INSERT INTO `option_info` VALUES (332, '123\\\\d 123456 123\\\\d', 0, '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'C', 82);
INSERT INTO `option_info` VALUES (333, '123\\d  123456 123\\d', 0, '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'D', 82);
INSERT INTO `option_info` VALUES (334, '456456456\\d 123456 123456', 1, '// strTxt = \"123\\d\"\nString strTxt = \"123\\\\d\";\n// regex = \"\\d\"\n// str1 = \"456456456\\d\"\nString str1 = strTxt.replaceAll(\"\\\\d\", \"456\");\n// Pattern.quote(\"\\\\d\") = \"\\Q\\d\\E\" 返回指定字符串的文字模式字符串\n// str2 = \"123456\"\nString str2 = strTxt.replaceAll(Pattern.quote(\"\\\\d\"), \"456\");\n// match one time from left to right\n// str3 = \"123456\"\nString str3 = strTxt.replace(\"\\\\d\", \"456\");\nSystem.out.println(str1);\nSystem.out.println(str2);\nSystem.out.println(str3);', 'E', 82);
INSERT INTO `option_info` VALUES (335, '重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常', 1, 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'A', 83);
INSERT INTO `option_info` VALUES (336, '重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同', 0, 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'B', 83);
INSERT INTO `option_info` VALUES (337, '重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类', 1, 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'C', 83);
INSERT INTO `option_info` VALUES (338, '声明为final或static的方法不能被重写', 1, 'A、重写是发生在父子类之间，方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常\nB、重载发生在一个类里面，必须为同名函数，且函数的参数类型不同或参数类型的顺序不同或返回值不同\nC、重写的返回类型与被重写的返回类型可以不相同，但必须是父类返回值的派生类\nD、声明为final或static的方法不能被重写', 'D', 83);
INSERT INTO `option_info` VALUES (339, '线程安全', 0, '', 'A', 84);
INSERT INTO `option_info` VALUES (340, '修改日期', 1, '', 'B', 84);
INSERT INTO `option_info` VALUES (341, '性能约束', 0, '', 'C', 84);
INSERT INTO `option_info` VALUES (342, 'api特性、原理', 0, '', 'D', 84);
INSERT INTO `option_info` VALUES (343, '避免文件过长，不超过2000行（非空非注释行）', 0, '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', 'A', 85);
INSERT INTO `option_info` VALUES (344, '一个源文件按顺序包含版权、package、import、顶层类，且用空行分隔', 0, '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', 'B', 85);
INSERT INTO `option_info` VALUES (345, 'import包应当按照先华为公司，安卓、其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', 1, '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', 'C', 85);
INSERT INTO `option_info` VALUES (346, '一个类或接口的声明部分应当按照类变量、实例变量、构造器、方法的顺序出现，且用空行分隔', 0, '建议3.1 import包应当按照先安卓，华为公司，其它商业组织，其它开源第三方、net/org开源组织、最后java的分类顺序出现，并用一个空行分组', 'D', 85);
INSERT INTO `option_info` VALUES (347, 'Integer i1 = 10; Integer i2 = 10; i1和i2指向同一个对象', 0, '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', 'A', 86);
INSERT INTO `option_info` VALUES (348, '整数型包装类型应使用equals做相等的比较', 0, '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', 'B', 86);
INSERT INTO `option_info` VALUES (349, '基本类型优于包装类型', 0, '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', 'C', 86);
INSERT INTO `option_info` VALUES (350, '浮点型包装类型建议使用equals或flt.compareTo(another)==0做相等的比较', 1, '选D，浮点型包装类型不应用equals或者flt.compareTo(another) == 0 作相等的比较。', 'D', 86);
INSERT INTO `option_info` VALUES (351, 'class Swan {\n    public static void fly() {\n        System.out.println(\"swan can fly ...\");\n    }\n}\nclass UglyDuck extends Swan {\n    public static void fly() {\n        System.out.println(\"ugly duck can\'t fly ...\");\n    }\n}\npublic class TestFly {\n    public static void main(String[] args) {\n        Swan swan = new Swan();\n        Swan uglyDuck = new UglyDuck();\n        swan.fly();\n        uglyDuck.fly();\n    }\n}\n输出：\nswan can fly …\nUglyDuck can fly …', 0, 'A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。', 'A', 87);
INSERT INTO `option_info` VALUES (352, 'class WhoKnows {\n    static String sentence = \"I don\'t know.\";\n    public static void main(String[] args) {\n        String sentence = \"I know!\";\n        System.out.println(sentence);\n    }\n}\n输出\"I know!\"', 1, 'A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。', 'B', 87);
INSERT INTO `option_info` VALUES (353, 'public class Obscure {\n    static String System;\n    public static void main(String[] args) {\n        System.out.println(\"hello, obscure world!\");\n    }\n}\n代码输出\"hello, obscure world!\"', 0, 'A：明显错误，程序里都没有“UglyDuck can fly”这个字符串。调用方法都是调实例真正类型的方法，new的是什么类型，就会运行那个类型的fly方法。\n\nB：sentence变量被作用域更小的本地变量遮蔽。\n\nC：System变量被类的域遮蔽，为String类型，没有out方法。', 'C', 87);
INSERT INTO `option_info` VALUES (354, 'String[] arr = new String[]{\"1\",\"2\",\"3\",\"4\",\"5\"};\nList<String> list =Arrays.asList(arr);\nlist.remove(\"5\");\nlist.add(\"6\");', 0, 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', 'A', 88);
INSERT INTO `option_info` VALUES (355, 'Map<String,String> map = new HashMap<>();\nmap.put(\"1\",\"a\");\nmap.put(\"2\",\"b\");\nList<String> list = new ArrayList<>();\nlist.addAll(map.values());\nlist.addAll(Collections.singleton(\"c\"));', 1, 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', 'B', 88);
INSERT INTO `option_info` VALUES (356, 'List<String> list = Collections.emptyList();\nlist.add(\"1\");', 0, 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', 'C', 88);
INSERT INTO `option_info` VALUES (357, 'List<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nArrayList<String> subList = (ArrayList<String>) list.subList(0,0);', 0, 'A：Arrays.asList只是给数组加上适配成List<>的部分读取接口，并未真正改变里面的数据结构，调用remove add方法时会抛异常。\n\nB：只要addAll参数是同泛型的Collection类或子类，就没有问题。\n\nC：Collections.emptyList()实际上是List的一个子类EmptyList，不能修改。\n\nD：ArrayList.subList()方法的真正实现是ArrayList的一个内部类java.util.ArrayList.SubList extends AbstractList<E> implements RandomAccess，而不是ArrayList。', 'D', 88);
INSERT INTO `option_info` VALUES (358, '0', 1, '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', 'A', 89);
INSERT INTO `option_info` VALUES (359, '1', 0, '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', 'B', 89);
INSERT INTO `option_info` VALUES (360, '2', 0, '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', 'C', 89);
INSERT INTO `option_info` VALUES (361, '3', 0, '传0进去会自动拷贝。\n public <T> T[] toArray(T[] a) {\n        if (a.length < size)\n            // Make a new array of a\'s runtime type, but my contents:\n            return (T[]) Arrays.copyOf(elementData, size, a.getClass());\n        System.arraycopy(elementData, 0, a, 0, size);\n        if (a.length > size)\n            a[size] = null;\n        return a;\n    }', 'D', 89);
INSERT INTO `option_info` VALUES (362, '建议使用String存储敏感数据，使用结束后立即赋为空', 0, 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', 'A', 90);
INSERT INTO `option_info` VALUES (363, '使用java.net.Socket类在不安全的传输通道中传输敏感数据', 0, 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', 'B', 90);
INSERT INTO `option_info` VALUES (364, '调用SecurityManager执行的安全检查，进行安全检查的方法必须声明为private或final', 1, 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', 'C', 90);
INSERT INTO `option_info` VALUES (365, '编写自定义类加载器时，需要复写getPermissions()方法时，可以忽略了基类的getPermissions()', 0, 'A：敏感数据需要使用char[]，用完马上销毁\n\nB：使用SSLSocket\n\nD：必须先调用基类的getPermissions()方法，不能忽略', 'D', 90);
INSERT INTO `option_info` VALUES (366, '[5,6,7,8,9]', 0, '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', 'A', 91);
INSERT INTO `option_info` VALUES (367, '[9,8,7,6,5]', 0, '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', 'B', 91);
INSERT INTO `option_info` VALUES (368, '[5,7,8,9,6]', 1, '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', 'C', 91);
INSERT INTO `option_info` VALUES (369, '[6,5,7,8,9]', 0, '注意构造方法的参数：16、0.75、true。通过源码得知最后一个参数控制顺序的策略\ntrue表示访问顺序即调用get方法后会将值插入到最后。\nfalse表示插入顺序\n\ninitialCapacity – the initial capacity\nloadFactor – the load factor\naccessOrder – the ordering mode - true for access-order, false for insertion-order', 'D', 91);
INSERT INTO `option_info` VALUES (370, '30 200 200', 0, '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', 'A', 92);
INSERT INTO `option_info` VALUES (371, '20 200 300', 0, '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', 'B', 92);
INSERT INTO `option_info` VALUES (372, '30 200 300', 1, '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', 'C', 92);
INSERT INTO `option_info` VALUES (373, '20 300 200', 0, '1：try-catch中间内容先执行，finallly后执行，全局变量最终结果以finallly设值为准\n2：try-catch中间内容先执行，在finallly未执行之时返回值已确定\n3：try-catch中间内容先执行，finallly后执行，若finallly中存在return，最终以finallly为准', 'D', 92);
INSERT INTO `option_info` VALUES (374, 'MaxDirectMemeorySize写满', 1, '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', 'A', 93);
INSERT INTO `option_info` VALUES (375, '永生代（Perm）或Metaspace被写满', 1, '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', 'B', 93);
INSERT INTO `option_info` VALUES (376, '年老代（tenured）被写满', 1, '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', 'C', 93);
INSERT INTO `option_info` VALUES (377, '显示调用System.gc', 1, '触发fullgc的可能性：\n\n1. 调用system.gc\n2. 老年代空间不足\n3. 永久带空间不足\n4. gc空间分配担保失败\n7、属于java并发库的线程同步类', 'D', 93);
INSERT INTO `option_info` VALUES (378, 'java.lang.OutOfMemoryError: java heap space 可能会导致所有用户线程暂停，不可以通过try/catch解决。', 1, '', 'A', 94);
INSERT INTO `option_info` VALUES (379, 'java.lang.StackOverflowError: 线程栈空间不足', 1, '', 'B', 94);
INSERT INTO `option_info` VALUES (380, 'java.lang.OutOfMemoryError: PermGen space 是指方法区（永久代）内存溢出', 1, '', 'C', 94);
INSERT INTO `option_info` VALUES (381, '当关闭断言时，会导致程序的运行结果不一致\nprivate ArrayList<String> names;\nvoid process(int index) {\nassert names.remove(null);\n// ...\n}', 0, 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', 'A', 95);
INSERT INTO `option_info` VALUES (382, '建议子类通过重载扩大方法的可访问性，这样可以拥有更大的访问权限', 1, 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', 'B', 95);
INSERT INTO `option_info` VALUES (383, '对于实现了java.lang.Cloneable接口的类，应该将方法clone()的可访问性从protected增加为public', 0, 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', 'C', 95);
INSERT INTO `option_info` VALUES (384, '如果忽略方法的返回值或对函数调用失败情况未正确处理，可能会导致安全风险。', 0, 'A:关闭断言时，names.remove(null);将无法执行，会导致运行结果不同。\nB:重写：发生在子类和父类之间，子类重写父类的方法，访问权限不能低于父类，抛出的异常不能多于父类，核心是要理解继承和里氏替换原则。\n重载：常用来解决功能类似而所处理的数据类型不同的问题，通常表现为同一个类里面的若干个同名函数之间，必须要有形参的不同，不能只有函数返回值类型的不同。\nC:类实现一个标记接口“Cloneable”，该接口中没有实际的方法和属性，只是作为一个标记，说明该类是可以被复制的. 当一个类实现了“Cloneable”接口后，就可以重写(override) Object 类的 clone() 方法来实现该类的克隆操作。希望在文章开头部分你就注意到该方法是被 “protect” 修饰的。因此在重写时只能使用比 “protect” 更高的权限。\nD：文件未找到错误，如果不进行处理，会存在文件目录暴露的安全风险。', 'D', 95);
INSERT INTO `option_info` VALUES (385, '使用不可信数据构造格式化字符串时，当转换参数与对应的格式符不匹配时，标准类库会抛出异常，不会造成系统信息泄露或拒绝服务', 1, 'A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png', 'A', 96);
INSERT INTO `option_info` VALUES (386, '用户可以通过输入一个回车符或一个换行符（CRLF）来将一条合法日志拆分成两条日志，使得日志内容可能令人误解', 0, 'A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png', 'B', 96);
INSERT INTO `option_info` VALUES (387, '尽可能使用“黑名单”策略来接收跨信任边界的数据，而不是使用白名单，白名单校验方式较弱', 1, 'A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png', 'C', 96);
INSERT INTO `option_info` VALUES (388, '对不可信数据校验建议使用断言的方式校验', 1, 'A 会信息泄露\nB 日志会被拆分，正确\nC 白名单方式净化不仅利于安全，他也允许接收和使用更宽泛的有效用户输入\nD http://image.huawei.com/tiny-lts/v1/images/ad87026bce1f93206b78_665x78.png@900-0-90-f.png', 'D', 96);
INSERT INTO `option_info` VALUES (389, '将含敏感数据的对象跨信任域传递前需要先加密后签名', 0, '', 'A', 97);
INSERT INTO `option_info` VALUES (390, '默认情况下，自动签名认证机制使用JAR文件中包含的公钥来验证签名，这就可以保证公钥和签名未被恶意篡改', 0, '', 'B', 97);
INSERT INTO `option_info` VALUES (391, '一些常用的JSON框架都具有type功能，它可以很方便的将java的对象类型和json数据格式之间进行转换，建议默认开启JSON框架的type功能', 0, '', 'C', 97);
INSERT INTO `option_info` VALUES (392, '非静态的内部类序列化时会隐式的对外部类实例的非transient对象进行序列化', 1, '', 'D', 97);
INSERT INTO `option_info` VALUES (393, 'java.lang.String.intern()', 0, '在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。', 'A', 98);
INSERT INTO `option_info` VALUES (394, 'java.lang.String.trim()', 0, '在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。', 'B', 98);
INSERT INTO `option_info` VALUES (395, 'java.text.Format.format()', 0, '在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。', 'C', 98);
INSERT INTO `option_info` VALUES (396, 'java.text.Normalizer.normalize()', 1, '在校验之前使用normalize方法对外部输入字符串做归一化/标准化，确保具有相同意义的字符串具有统一的二进制描述，推荐使用Normalizer.Form.NFKC参数进行归一化/标准化。', 'D', 98);
INSERT INTO `option_info` VALUES (397, '临时文件由于会定期被清理掉，所以不用显示的清理临时文件', 1, 'A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png', 'A', 99);
INSERT INTO `option_info` VALUES (398, 'java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改', 1, 'A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png', 'B', 99);
INSERT INTO `option_info` VALUES (399, '运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空', 0, 'A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png', 'C', 99);
INSERT INTO `option_info` VALUES (400, 'Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值', 1, 'A 临时文件使用完毕必须清理\nB wrap、slice、duplicate不会创建新的buffer对象\nC 正确，防止让外部进程阻塞在输入输出流上\nD http://image.huawei.com/tiny-lts/v1/images/84f5726bce3b263734e1_677x201.png@900-0-90-f.png', 'D', 99);
INSERT INTO `option_info` VALUES (401, 'short s = 1;s = s + 1;', 0, 'A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：', 'A', 100);
INSERT INTO `option_info` VALUES (402, 'int big = 1999999999;\nfloat one=1.0f;\nSystem.out.println(big * one);', 0, 'A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：', 'B', 100);
INSERT INTO `option_info` VALUES (403, 'int ni = 6789;\ndouble d1 = ni / 30;', 0, 'A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：', 'C', 100);
INSERT INTO `option_info` VALUES (404, 'long nl = 4664382371590123456L;\ndouble d2 = (double) nl * 2;', 1, 'A：编译报错应该为s++、s=(short)(s+ 1);\nB：不太懂..应该是精度问题？\nC：返回还是int，但是java会自动转型？不建议\nD：没啥毛病\nC：', 'D', 100);
INSERT INTO `option_info` VALUES (405, '可以接受指定类型的1个到多个参数', 0, '', 'A', 101);
INSERT INTO `option_info` VALUES (406, '不建议使用varargs重写使用一个固定长度数组作为参数的方法', 1, '', 'B', 101);
INSERT INTO `option_info` VALUES (407, 'JDK1.5引入Varargs（variable number of arguments）可变数量参数，应该在确实需要操作可变长度的值的序列时使用', 1, '', 'C', 101);
INSERT INTO `option_info` VALUES (408, '可变参数必须位于最后一项', 1, '', 'D', 101);
INSERT INTO `option_info` VALUES (409, '方法的参数个数不应超过5个', 1, '', 'A', 102);
INSERT INTO `option_info` VALUES (410, '构造方法如果参数较多，尽量重用', 1, '', 'B', 102);
INSERT INTO `option_info` VALUES (411, '方法的入参建议当做工作变量/临时变量', 0, '', 'C', 102);
INSERT INTO `option_info` VALUES (412, '避免方法过长，不超过50行（非空非注释）；避免方法的代码块嵌套过深，不要超过4层', 1, '', 'D', 102);
INSERT INTO `option_info` VALUES (413, 'Java 8使用Optional代替null作为返回值或者可能的缺失值;禁止对optional对象赋值为null', 1, '', 'A', 103);
INSERT INTO `option_info` VALUES (414, '禁止对optional对象赋值/返回为null，或与null比较', 1, '', 'B', 103);
INSERT INTO `option_info` VALUES (415, '不应该返回Optional<Integer> , Optional<Long> , Optional<Double> ,而用OptionalInt,OptionalLong,OptionalDouble', 1, '', 'C', 103);
INSERT INTO `option_info` VALUES (416, '枚举常量的序号生成建议依赖ordinal()方法', 0, '', 'D', 103);
INSERT INTO `option_info` VALUES (417, '不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符', 1, '', 'A', 104);
INSERT INTO `option_info` VALUES (418, '编码时尽量依赖平台默认的字符编码方式', 0, '', 'B', 104);
INSERT INTO `option_info` VALUES (419, 'String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换', 0, '', 'C', 104);
INSERT INTO `option_info` VALUES (420, '使用java.nio.charset中的类编码解码字符集', 1, '', 'D', 104);
INSERT INTO `option_info` VALUES (421, '接口中可包含静态方法和default方法', 1, '', 'A', 105);
INSERT INTO `option_info` VALUES (422, '接口中属性默认public static final修饰词', 1, '', 'B', 105);
INSERT INTO `option_info` VALUES (423, '方法已缺省具有public abstract修饰词', 1, '', 'C', 105);
INSERT INTO `option_info` VALUES (424, '攻击者可以访问受限目录和文件', 1, '', 'A', 106);
INSERT INTO `option_info` VALUES (425, '攻击者可以篡改系统的任意文件', 1, '', 'B', 106);
INSERT INTO `option_info` VALUES (426, '攻击可可以恶意删除系统中的文件', 1, '', 'C', 106);
INSERT INTO `option_info` VALUES (427, '攻击者可以窃取内存中数据', 0, '', 'D', 106);
INSERT INTO `option_info` VALUES (428, '进行正则匹配前，先对匹配的文本的长度进行校验', 1, '避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。', 'A', 107);
INSERT INTO `option_info` VALUES (429, '在编写正则时，尽量不要使用过于复杂的正则，越复杂越容易有缺陷', 1, '避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。', 'B', 107);
INSERT INTO `option_info` VALUES (430, '在编写正则时，尽量减少分组的使用', 1, '避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。', 'C', 107);
INSERT INTO `option_info` VALUES (431, '避免动态构建正则，当使用不可信数据构造正则时，要使用黑名单进行严格校验', 0, '避免动态构建正则，当使用不可信数据构造正则时，要使用白名单进行严格校验。', 'D', 107);
INSERT INTO `option_info` VALUES (432, '使用transient定义敏感数据', 1, '', 'A', 108);
INSERT INTO `option_info` VALUES (433, '使用serialPersistentFields定义非敏感数据', 1, '', 'B', 108);
INSERT INTO `option_info` VALUES (434, '重新定义Serializable接口的writeObject()、writeReplace()、writeExternal()这些函数，不将包含敏感信息的字段写到序列化字节流中。', 1, '', 'C', 108);
INSERT INTO `option_info` VALUES (435, '在在序列化与反序列化涉及的writeObject()和readObject()方法中使用安全管理器', 1, '', 'D', 108);
INSERT INTO `option_info` VALUES (436, '文件路径校验前必须先进行标准化处理，建议使用getAbsolutePath()', 0, '', 'A', 109);
INSERT INTO `option_info` VALUES (437, '未对程序输入做有效的校验与限制可能会导致zip炸弹攻击、SQL注入、OS命令注入、XML注入以及目录遍历等攻击', 1, '', 'B', 109);
INSERT INTO `option_info` VALUES (438, '数值运算，建议使用先决条件检查、Math.*Exact()方法、向上类型转换等方式防止溢出', 1, '', 'C', 109);
INSERT INTO `option_info` VALUES (439, '建议通过System.exit()函数来终止运行的程序和线程', 0, '', 'D', 109);
INSERT INTO `option_info` VALUES (440, 'ResultSet的fetchSize越大，数据库服务端消耗的内存越小，性能也越快', 0, '', 'A', 110);
INSERT INTO `option_info` VALUES (441, 'ResultSet的fetchSize越大，数据库服务端消耗的内存越大，性能也越快', 0, '', 'B', 110);
INSERT INTO `option_info` VALUES (442, 'ResultSet的fetchSize越大，JDBC client端消耗的内存越大，性能也越快', 1, '', 'C', 110);
INSERT INTO `option_info` VALUES (443, 'ResultSet的fetchSize越大，JDBC client端消耗的内存越小，性能也越快', 0, '', 'D', 110);
INSERT INTO `option_info` VALUES (444, 'getDeclaredFields', 0, '', 'A', 111);
INSERT INTO `option_info` VALUES (445, 'getDeclaredNames', 1, '', 'B', 111);
INSERT INTO `option_info` VALUES (446, 'getDeclaredMethods', 0, '', 'C', 111);
INSERT INTO `option_info` VALUES (447, 'getDeclaredConstructors', 0, '', 'D', 111);
INSERT INTO `option_info` VALUES (448, 'float f = 10f', 1, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'A', 112);
INSERT INTO `option_info` VALUES (449, 'char c = 10.0', 0, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'B', 112);
INSERT INTO `option_info` VALUES (450, 'byte b = 10b', 0, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'C', 112);
INSERT INTO `option_info` VALUES (451, 'double d = 10', 1, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'D', 112);
INSERT INTO `option_info` VALUES (452, 'float f = 10.0', 0, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'E', 112);
INSERT INTO `option_info` VALUES (453, 'double d = 10.0', 1, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'F', 112);
INSERT INTO `option_info` VALUES (454, 'HashMap使用的是数组+链表（或红黑树）的方式，查找key时，先判断key的equals是否相等，相等时再判断 hashCode是否一致', 0, 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', 'A', 113);
INSERT INTO `option_info` VALUES (455, 'HashMap和HashSet的默认值大小为16，HashTable的默认值大小为11', 1, 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', 'B', 113);
INSERT INTO `option_info` VALUES (456, 'LinkedHashMap保持插入的顺序，TreeMap保持key的自然顺序', 1, 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', 'C', 113);
INSERT INTO `option_info` VALUES (457, 'Collection的直接子类包含Set、List、Map和Queue', 0, 'A 后面半句话有问题，equals相等hascode也应该相等，反之则不一定\nD Collection和Map没有关系 Map是单独的接口，Set、List、Queue是Collection的子类。Map是单独接口\n简单记：Map有k，v  Collection只能提供一个', 'D', 113);
INSERT INTO `option_info` VALUES (458, 'byte', 1, '', 'A', 114);
INSERT INTO `option_info` VALUES (459, 'long', 0, '', 'B', 114);
INSERT INTO `option_info` VALUES (460, 'char', 1, '', 'C', 114);
INSERT INTO `option_info` VALUES (461, 'String', 1, '// 整型类型\nint i = 1;\nbyte b = 1;\nlong l = 1;\nshort s = 1;\n// 字符类型\nchar c = 1;\n// 浮点类型\nfloat f = 1;\ndouble d = 1;\n// 总结：都可以赋值整数\n// int i1 = 1.0;// 编译报错\n// byte b1 = 1.0;// 编译报错\n// long l1 = 1.0;// 编译报错\n// short s1 = 1.0;// 编译报错\n// char c1 = 1.0;// 编译报错\n// 总结：整型和浮点类型不能直接赋值小数\n// float f1 = 1.0;// 编译报错\nfloat f11 = 1.0F;\ndouble d1 = 1.0;\n// 总结：浮点类型只有double能直接赋值小数,float赋值小数后面必须跟F\n// int i2 = 1I;// 编译报错\n// byte b2 = 1B;// 编译报错\nlong l2 = 1L;\n// short s2 = 1S;// 编译报错\n// char c2 = 1C;// 编译报错\nfloat f2 = 1F;\ndouble d2 = 1D;\n// 总结：只有L F D三个字母可以在后面其余都报错\nswitch (i){}\nswitch (b){}\n// switch (l){}// 编译报错\nswitch (s){}\nswitch (c){}\n// switch (f){}// 编译报错\n// switch (d){}// 编译报错\n// 总结：浮点都不能switch，整数只有l不能switch', 'D', 114);
INSERT INTO `option_info` VALUES (462, 'Throwable是所有Error或Exception的超累', 1, 'B 纯属狗屁了，你把Throwable不放在眼里', 'A', 115);
INSERT INTO `option_info` VALUES (463, '只有是Exception或Exception子类，才能被catch', 0, 'B 纯属狗屁了，你把Throwable不放在眼里', 'B', 115);
INSERT INTO `option_info` VALUES (464, 'Error是正常的应用程序已无能为力的不应该试图捕获的严重问题，如OutOfMemoryError', 1, 'B 纯属狗屁了，你把Throwable不放在眼里', 'C', 115);
INSERT INTO `option_info` VALUES (465, '编译器会强制要求使用者捕获RuntimeException或申明抛出', 1, 'B 纯属狗屁了，你把Throwable不放在眼里', 'D', 115);
INSERT INTO `option_info` VALUES (466, 'Java多线程程序中，线程不允许抛出未捕获的Checked Exception', 1, '', 'A', 116);
INSERT INTO `option_info` VALUES (467, 'Java多线程程序中，线程允许抛出未捕获的Checked Exception', 0, '', 'B', 116);
INSERT INTO `option_info` VALUES (468, 'Java多线程程序中，建议使用Thread对象的setUncaughtExceptionHandler方法注册Runtime异常的处理者', 1, '', 'C', 116);
INSERT INTO `option_info` VALUES (469, 'Java多线程中，主线程可通过try catch捕获子线程异常', 0, '', 'D', 116);
INSERT INTO `option_info` VALUES (470, '在运行时判断任意一个对象所属的类。', 1, '', 'A', 117);
INSERT INTO `option_info` VALUES (471, '在运行时构造任意一个类的对象。', 1, '', 'B', 117);
INSERT INTO `option_info` VALUES (472, '在运行时判断任意一个类所具有的成员变量和方法。', 1, '', 'C', 117);
INSERT INTO `option_info` VALUES (473, '在运行时调用任意一个对象的方法。', 1, '', 'D', 117);
INSERT INTO `option_info` VALUES (474, 'SelectionKey.OP_ACCEPT', 1, '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', 'A', 118);
INSERT INTO `option_info` VALUES (475, 'SelectionKey.OP_CONNECT', 1, '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', 'B', 118);
INSERT INTO `option_info` VALUES (476, 'SelectionKey.OP_WRITE', 1, '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', 'C', 118);
INSERT INTO `option_info` VALUES (477, 'SelectionKey.OP_READ', 1, '有人看源码SocketChannel第213行 发现只有三个READ、WRITE、CONNECT。所有有争议 信源码得永生', 'D', 118);
INSERT INTO `option_info` VALUES (478, 'char', 0, '貌似包装类都是final class可能看看源码加深记忆', 'A', 119);
INSERT INTO `option_info` VALUES (479, 'Integer', 1, '貌似包装类都是final class可能看看源码加深记忆', 'B', 119);
INSERT INTO `option_info` VALUES (480, 'String', 1, '貌似包装类都是final class可能看看源码加深记忆', 'C', 119);
INSERT INTO `option_info` VALUES (481, 'short', 0, '貌似包装类都是final class可能看看源码加深记忆', 'D', 119);
INSERT INTO `option_info` VALUES (482, 'char', 1, 'https://blog.csdn.net/u012611878/article/details/52455576', 'A', 120);
INSERT INTO `option_info` VALUES (483, 'int', 0, 'https://blog.csdn.net/u012611878/article/details/52455576', 'B', 120);
INSERT INTO `option_info` VALUES (484, 'long', 1, 'https://blog.csdn.net/u012611878/article/details/52455576', 'C', 120);
INSERT INTO `option_info` VALUES (485, 'short', 1, 'https://blog.csdn.net/u012611878/article/details/52455576', 'D', 120);
INSERT INTO `option_info` VALUES (486, 'ABCDE', 0, '', 'A', 121);
INSERT INTO `option_info` VALUES (487, 'ABCDEABCDE', 1, '', 'B', 121);
INSERT INTO `option_info` VALUES (488, '什么都没有', 0, '', 'C', 121);
INSERT INTO `option_info` VALUES (489, 'EDCBAEDCBA', 0, '', 'D', 121);
INSERT INTO `option_info` VALUES (490, '100', 0, '', 'A', 122);
INSERT INTO `option_info` VALUES (491, '编译错误', 0, '', 'B', 122);
INSERT INTO `option_info` VALUES (492, '运行异常', 1, '', 'C', 122);
INSERT INTO `option_info` VALUES (493, 'aaaa', 0, '', 'D', 122);
INSERT INTO `option_info` VALUES (494, 'true true', 1, '', 'A', 123);
INSERT INTO `option_info` VALUES (495, 'true false', 0, '', 'B', 123);
INSERT INTO `option_info` VALUES (496, 'false true', 0, '', 'C', 123);
INSERT INTO `option_info` VALUES (497, 'false false', 0, '', 'D', 123);
INSERT INTO `option_info` VALUES (498, 'capacity', 0, '', 'A', 124);
INSERT INTO `option_info` VALUES (499, 'flag', 1, '', 'B', 124);
INSERT INTO `option_info` VALUES (500, 'position', 0, '', 'C', 124);
INSERT INTO `option_info` VALUES (501, 'limit', 0, '', 'D', 124);
INSERT INTO `option_info` VALUES (502, 'IO是面向流的，NIO是面向缓存的', 0, '', 'A', 125);
INSERT INTO `option_info` VALUES (503, 'IO是阻塞IO，NIO支持非阻塞IO', 0, '', 'B', 125);
INSERT INTO `option_info` VALUES (504, 'IO值能顺序读取数据，NIO可以通过缓存区前后移动获取数据', 0, '', 'C', 125);
INSERT INTO `option_info` VALUES (505, 'IO允许一个线程监听多个输入通道', 1, '', 'D', 125);
INSERT INTO `option_info` VALUES (506, 'Buffer', 0, '', 'A', 126);
INSERT INTO `option_info` VALUES (507, 'Channel', 0, '', 'B', 126);
INSERT INTO `option_info` VALUES (508, 'Selectors', 0, '', 'C', 126);
INSERT INTO `option_info` VALUES (509, 'Reader', 1, '', 'D', 126);
INSERT INTO `option_info` VALUES (510, 'volatile保证操作的修改可见性和原子性', 0, '', 'A', 127);
INSERT INTO `option_info` VALUES (511, 'volatile和synchronized则可以使用在变量、方法、和类级别的', 0, '', 'B', 127);
INSERT INTO `option_info` VALUES (512, 'synchronized和ReentrantLock都是可重入锁', 1, '', 'C', 127);
INSERT INTO `option_info` VALUES (513, 'synchronized适合一写多读场景', 0, '', 'D', 127);
INSERT INTO `option_info` VALUES (514, '0', 0, 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', 'A', 128);
INSERT INTO `option_info` VALUES (515, '1', 0, 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', 'B', 128);
INSERT INTO `option_info` VALUES (516, '-1', 1, 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', 'C', 128);
INSERT INTO `option_info` VALUES (517, '运行时异常', 0, 'false ? 1 : false ? 0 : -1\n第一个三元表达式false进入后面三元表达式false输出-1', 'D', 128);
INSERT INTO `option_info` VALUES (518, '启动程序的时候通过附加参数启动安全管理器：-Djava.security.manager', 0, '', 'A', 129);
INSERT INTO `option_info` VALUES (519, '若要同时指定配置文件 -Djava.security.manager -Djava.security.policy=\"E:/java.policy\"', 0, '', 'B', 129);
INSERT INTO `option_info` VALUES (520, '编码方式启动 System.setSecurityManager(new SecurityManager());', 0, '', 'C', 129);
INSERT INTO `option_info` VALUES (521, '编码方式启动 System.setProperty(“java.security.manager”, xxx);', 1, '', 'D', 129);
INSERT INTO `option_info` VALUES (522, 'OOM时，主动执行System.exit()', 0, '', 'A', 130);
INSERT INTO `option_info` VALUES (523, '进程发生不可预知的异常时，主动执行System.exit()', 0, '', 'B', 130);
INSERT INTO `option_info` VALUES (524, '命令行执行System.exit()', 0, '', 'C', 130);
INSERT INTO `option_info` VALUES (525, '服务出现不可恢复的异常时，主动执行System.exit()', 1, '', 'D', 130);
INSERT INTO `option_info` VALUES (526, '调用Thread.interrupt() 用于请求另外一个线程中止执行，而不是直接中止', 1, '', 'A', 131);
INSERT INTO `option_info` VALUES (527, '推荐使用Thread.current().isInterrupted()，而不是Thread.interrupted()检查自己是否被interrupt', 0, '', 'B', 131);
INSERT INTO `option_info` VALUES (528, '检测到当前线程被interrupt后，应抛出InterruptedException，并在finally或try-with-resource中清理执行状态', 1, '', 'C', 131);
INSERT INTO `option_info` VALUES (529, '调用线程的interrupt方法，只有当线程走到了sleep, wait, join等阻塞这些方法的时候，才会抛出InterruptedException。', 1, '', 'D', 131);
INSERT INTO `option_info` VALUES (530, 'LinkedList', 0, 'Stack<E> extend Vector<E> 故线程安全', 'A', 132);
INSERT INTO `option_info` VALUES (531, 'Vector', 1, 'Stack<E> extend Vector<E> 故线程安全', 'B', 132);
INSERT INTO `option_info` VALUES (532, 'Hashtable', 1, 'Stack<E> extend Vector<E> 故线程安全', 'C', 132);
INSERT INTO `option_info` VALUES (533, 'TreeMap', 0, 'Stack<E> extend Vector<E> 故线程安全', 'D', 132);
INSERT INTO `option_info` VALUES (534, 'TreeSet', 0, 'Stack<E> extend Vector<E> 故线程安全', 'E', 132);
INSERT INTO `option_info` VALUES (535, 'ConcurrentHashMap', 1, 'Stack<E> extend Vector<E> 故线程安全', 'F', 132);
INSERT INTO `option_info` VALUES (536, 'Stack', 1, 'Stack<E> extend Vector<E> 故线程安全', 'G', 132);
INSERT INTO `option_info` VALUES (537, 'Exchanger', 1, '', 'A', 133);
INSERT INTO `option_info` VALUES (538, 'Semaphore', 1, '', 'B', 133);
INSERT INTO `option_info` VALUES (539, 'CountDownLatch', 1, '', 'C', 133);
INSERT INTO `option_info` VALUES (540, 'CyclicBarrier', 1, '', 'D', 133);
INSERT INTO `option_info` VALUES (541, 'Phaser', 1, '', 'E', 133);
INSERT INTO `option_info` VALUES (542, 'DT FUZZ测试中，如果被测函数代码有修改，但被测函数被调用逻辑没有修改，不需要修改测试用例', 1, '', 'A', 134);
INSERT INTO `option_info` VALUES (543, '尽量选择模块外层函数为被测目标，编写测试用例，测试过程中，本模块内部函数可以随意打桩', 0, '', 'B', 134);
INSERT INTO `option_info` VALUES (544, 'DT FUZZ测试，编写测试用例可以不考虑函数的调用上下文', 0, '', 'C', 134);
INSERT INTO `option_info` VALUES (545, '结构化的参数DT FUZZ工具都可以构造', 0, '', 'D', 134);
INSERT INTO `option_info` VALUES (546, '新建', 0, '', 'A', 135);
INSERT INTO `option_info` VALUES (547, '阻塞', 0, '', 'B', 135);
INSERT INTO `option_info` VALUES (548, '运行', 0, '', 'C', 135);
INSERT INTO `option_info` VALUES (549, '就绪', 1, '', 'D', 135);
INSERT INTO `option_info` VALUES (550, 'jdk提供的序列化操作，会将Java对象序列化二进制流，可以有效防止信息泄露或恶意篡改', 0, '', 'A', 136);
INSERT INTO `option_info` VALUES (551, 'Java的反序列化操作，可以绕过对象构造函数的执行', 1, '', 'B', 136);
INSERT INTO `option_info` VALUES (552, '对象序列化后，即使包含敏感数据也不会产生风险', 0, '', 'C', 136);
INSERT INTO `option_info` VALUES (553, 'Java反序列化时，目标class与预期class不一致时，会导致类型转换错误，所以即使反序列化不可信数据也不会有安全风险', 0, '', 'D', 136);
INSERT INTO `option_info` VALUES (554, 'CSRF', 1, 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', 'A', 137);
INSERT INTO `option_info` VALUES (555, '敏感信息泄露', 0, 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', 'B', 137);
INSERT INTO `option_info` VALUES (556, 'ReDos攻击', 0, 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', 'C', 137);
INSERT INTO `option_info` VALUES (557, '正则注入', 0, 'CSRF：Cross-Site Request Forgery 跨站请求伪造\n攻击者可能会通过恶意构造的输入对初始化的正则表达式进行修改，比如导致正则表达式不符合程序规定要求。这种攻击称为正则注入(regex injection), 可能会影响控制流，导致信息泄漏，或导致ReDos攻击。\n\n ', 'D', 137);
INSERT INTO `option_info` VALUES (558, '做好日志访问权限控制，日志可以记录敏感信息', 0, '', 'A', 138);
INSERT INTO `option_info` VALUES (559, '敏感信息记录日志时，直接将信息内容替换等长的*即可', 0, '', 'B', 138);
INSERT INTO `option_info` VALUES (560, '日志中如果必须记录敏感信息，需要使用长度固定的*替代', 1, '', 'C', 138);
INSERT INTO `option_info` VALUES (561, '敏感信息加密后可以记录日志', 0, '', 'D', 138);
INSERT INTO `option_info` VALUES (562, 'xPath注入', 0, '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', 'A', 139);
INSERT INTO `option_info` VALUES (563, 'XXE', 1, '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', 'B', 139);
INSERT INTO `option_info` VALUES (564, '内部实体扩展', 1, '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', 'C', 139);
INSERT INTO `option_info` VALUES (565, 'xml注入', 0, '规则1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击\n\n \n\n规则1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击', 'D', 139);
INSERT INTO `option_info` VALUES (566, '避免使用shell方式执行命令，直接启动具体的进程', 0, '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', 'A', 140);
INSERT INTO `option_info` VALUES (567, '代码避免使用外部输入拼接命令行，代码中对命令进行硬编码', 0, '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', 'B', 140);
INSERT INTO `option_info` VALUES (568, '对于使用外部输入构造的命令行，在执行前进行转码处理', 1, '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', 'C', 140);
INSERT INTO `option_info` VALUES (569, '外部输入进行白名单校验，禁止使用&|>;等特殊字符', 0, '在拼接命令行前而不是执行前，需对不可信字段进行转码处理，转码后的字段拼接命令行可有效防止命令注入的产生。', 'D', 140);
INSERT INTO `option_info` VALUES (570, 'java.util.Random()', 0, '', 'A', 141);
INSERT INTO `option_info` VALUES (571, 'Math.random()', 0, '', 'B', 141);
INSERT INTO `option_info` VALUES (572, 'java.util.concurrent.ThreadLocalRandom()', 0, '', 'C', 141);
INSERT INTO `option_info` VALUES (573, 'java.Security.SecureRandom()', 1, '', 'D', 141);
INSERT INTO `option_info` VALUES (574, 'XMLDecoder是jdk原生类，提供了xml的反序列化操作，所以相对Xstream，更推荐使用XMLDecoder进行xml数据的反序列化操作', 1, 'java原生的XMLDecoder类常被用来序列化反序列化XML格式数据，但是这个类也存在严重安全问题，这里解析任意xml文件可以导致反序列化命令执行，oracle官方未提供任何针对此问题的安全措施，所以在反序列化不可信xml数据时，强烈建议不要使用此类。', 'A', 142);
INSERT INTO `option_info` VALUES (575, '使用jdk原生api进行反序列化操作，涉及不可信数据时，可以重载ObjectInputStream的resolveClass()方法，在该方法中对目标class进行白名单校验', 0, 'todo resolveClass方法是什么？', 'B', 142);
INSERT INTO `option_info` VALUES (576, '对不可信的XML数据进行反序列化操作，推荐使用XStream实现，该组件支持白名单检查，新版本也提供了默认安全校验机制', 0, '', 'C', 142);
INSERT INTO `option_info` VALUES (577, '对不可信的json数据进行反序列化操作，可通过禁止开启type功能进行防护', 0, 'todo 开启type功能指的是啥？', 'D', 142);
INSERT INTO `option_info` VALUES (578, '③', 1, '规则7.5 禁止序列化非静态的内部类', 'A', 143);
INSERT INTO `option_info` VALUES (579, '②', 1, '规则7.5 禁止序列化非静态的内部类', 'B', 143);
INSERT INTO `option_info` VALUES (580, '①', 0, '规则7.5 禁止序列化非静态的内部类', 'C', 143);
INSERT INTO `option_info` VALUES (581, 'CharBuffer.asReadOnlyBuffer();', 0, 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', 'A', 144);
INSERT INTO `option_info` VALUES (582, 'CharBuffer.duplicate();', 1, 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', 'B', 144);
INSERT INTO `option_info` VALUES (583, 'CharBuffer.subSequence();', 1, 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', 'C', 144);
INSERT INTO `option_info` VALUES (584, 'CharBuffer.wrap();', 1, 'http://3ms.huawei.com/km/blogs/details/5896699\n\n \n\njava.nio包中的Buffer类，如IntBuffer, CharBuffer，以及ByteBuffer定义了一系列的方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，但是修改这个新buffer对象会导致原始的封装数据也被修改，反之亦然。例如，wrap()方法将原始类型数组包装成一个buffer对象并返回。虽然这些方法会创建一个新的buffer对象，但是它后台封装的还是之前的给定数组，那么任何对buffer对象的修改也会导致封装的数组被修改，\n\n \n\n反之亦然。将这些buffer对象暴露给不可信代码，则会使其封装的数组面临恶意修改的风险。同样的，duplicate()方法会以原始buffer封装的数组来额外创建新的buffer对象，将此额外新建的buffer对象暴露给不可信代码同样会面临原始数据被恶意修改的风险。为了防止这种问题的发生，新建的buffer应该以只读视图asReadOnlyBuffer()或者拷贝的方式返回。', 'D', 144);
INSERT INTO `option_info` VALUES (585, 'Java中一般会使用同步方法或同步代码块实现线程同步操作', 0, '', 'A', 145);
INSERT INTO `option_info` VALUES (586, '对于单例模式的java类，即使该类对象可暴露给不可信代码，使用同步方法可以正确进行线程同步', 1, '', 'B', 145);
INSERT INTO `option_info` VALUES (587, '使用private final的锁对象更安全', 0, '', 'C', 145);
INSERT INTO `option_info` VALUES (588, '同步方法与基于this引用的同步代码块使用的是相同的锁', 0, '', 'D', 145);
INSERT INTO `option_info` VALUES (589, '反序列化漏洞', 0, '', 'A', 146);
INSERT INTO `option_info` VALUES (590, '日志注入', 1, '', 'B', 146);
INSERT INTO `option_info` VALUES (591, 'json注入共计', 0, '', 'C', 146);
INSERT INTO `option_info` VALUES (592, '缓冲区溢出', 0, '', 'D', 146);
INSERT INTO `option_info` VALUES (593, '③', 0, '解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'A', 147);
INSERT INTO `option_info` VALUES (594, '④', 1, '解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'B', 147);
INSERT INTO `option_info` VALUES (595, '①', 0, '解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'C', 147);
INSERT INTO `option_info` VALUES (596, '②', 0, '解析：4是防止外部实体攻击的\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'D', 147);
INSERT INTO `option_info` VALUES (597, 'Runtime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nerrorGobbler.start();\nint exitVal = proc.waitFor();', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上', 'A', 148);
INSERT INTO `option_info` VALUES (598, 'Runtime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nStreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream(), System.err);\nStreamGobbler outputGobbler = new StreamGobbler(proc.getInputStream(), System.out);\nerrorGobbler.start();\noutputGobbler.start();\nint exitVal = proc.waitFor();', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上', 'B', 148);
INSERT INTO `option_info` VALUES (599, 'Runtime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nint exitVal = proc.exitValue();', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上', 'C', 148);
INSERT INTO `option_info` VALUES (600, 'Runtime rt = Runtime.getRuntime();\nProcess proc = rt.exec(\"notemaker\");\nint exitVal = proc.waitFor();', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699\n规则6.3 防止让外部进程阻塞在输入输出流上', 'D', 148);
INSERT INTO `option_info` VALUES (601, '调用interrupt()后线程停止', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387', 'A', 149);
INSERT INTO `option_info` VALUES (602, 'interrupt()可以实现在线程受到阻塞时抛出一个中断信号', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387', 'B', 149);
INSERT INTO `option_info` VALUES (603, '中断线程推荐使用stop()函数', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387', 'C', 149);
INSERT INTO `option_info` VALUES (604, '线程会一直运行', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8300387', 'D', 149);
INSERT INTO `option_info` VALUES (605, '转码是优选的sql注入防护措施', 0, '解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。', 'A', 150);
INSERT INTO `option_info` VALUES (606, '转码仅对拼接sql语句中，单引号或双引号限制的字段生效', 1, '解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。', 'B', 150);
INSERT INTO `option_info` VALUES (607, '在拼接sql语句前进行转码，可以彻底解决sql注入问题', 0, '解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。', 'C', 150);
INSERT INTO `option_info` VALUES (608, '转码对表名、字段等不适用于参数化查询的场景是优选的方案', 0, '解析：\n对于转码，仅适用于sql语句中由单引号或双引号限制的字段。', 'D', 150);
INSERT INTO `option_info` VALUES (609, 'SAXParserFactory factory = SAXParserFactory.newInstance();\nSAXParser saxParser = factory.newSAXParser();\nsaxParser.parse(inStream, defaultHandler);', 1, '', 'A', 151);
INSERT INTO `option_info` VALUES (610, 'public static String DDD = \"http://apache.org/xml/features/disallow-doctype-decl\";\npublic static String EGE = \"http://xml.org/sax/features/external-general-entities\";\npublic static String EPE = \"http://xml.org/sax/features/external-parameter-entities\";\npublic static String LED = \"http://apache.org/xml/features/nonvalidating/load-external-dtd\";\nSAXReader reader = new SAXReader();\nreader.setFeature(LED, false);\nreader.setFeature(EGE, false);\nreader.setFeature(EPE, false);', 0, '', 'B', 151);
INSERT INTO `option_info` VALUES (611, 'XMLReader reader = saxParser.getXMLReader();\nreader.serEntityResolve(new CustomerResolver());\nreader.setErrorHandler(defaultHandler);', 0, '', 'C', 151);
INSERT INTO `option_info` VALUES (612, 'DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false)', 0, '', 'D', 151);
INSERT INTO `option_info` VALUES (613, 'AES-GCM', 0, '', 'A', 152);
INSERT INTO `option_info` VALUES (614, 'AES-ECB', 1, '', 'B', 152);
INSERT INTO `option_info` VALUES (615, 'DES', 1, '', 'C', 152);
INSERT INTO `option_info` VALUES (616, 'MD5', 1, '', 'D', 152);
INSERT INTO `option_info` VALUES (617, '使用不安全的XSLT转换XML文件', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753', 'A', 153);
INSERT INTO `option_info` VALUES (618, '对不可信数据进行反序列化操作', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753', 'B', 153);
INSERT INTO `option_info` VALUES (619, '使用不可信数据拼接sql语句', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753', 'C', 153);
INSERT INTO `option_info` VALUES (620, '使用不可信数据拼接命令行', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/8905753', 'D', 153);
INSERT INTO `option_info` VALUES (621, '外部实体注入(XXE)', 1, '', 'A', 154);
INSERT INTO `option_info` VALUES (622, '内部实体扩展', 1, '', 'B', 154);
INSERT INTO `option_info` VALUES (623, 'LDAP注入', 0, '', 'C', 154);
INSERT INTO `option_info` VALUES (624, 'XPath注入', 1, '', 'D', 154);
INSERT INTO `option_info` VALUES (625, '将属性声明为final', 0, '', 'A', 155);
INSERT INTO `option_info` VALUES (626, '将敏感数据声明为transient', 1, '', 'B', 155);
INSERT INTO `option_info` VALUES (627, '将属性声明为private', 0, '', 'C', 155);
INSERT INTO `option_info` VALUES (628, '特殊情况下正确加密了的数据可以被序列化', 1, '', 'D', 155);
INSERT INTO `option_info` VALUES (629, '同步方法或使用对象内置锁的同步代码块中，直接抛出异常', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'A', 156);
INSERT INTO `option_info` VALUES (630, '异常条件下没有正确释放锁', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'B', 156);
INSERT INTO `option_info` VALUES (631, '两个或多个线程以不同的顺序请求和释放锁', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'C', 156);
INSERT INTO `option_info` VALUES (632, '在产生阻塞的操作中持有锁', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'D', 156);
INSERT INTO `option_info` VALUES (633, '资源未正确释放', 1, '', 'A', 157);
INSERT INTO `option_info` VALUES (634, '敏感异常导致信息泄漏', 0, '', 'B', 157);
INSERT INTO `option_info` VALUES (635, 'sql注入', 0, '', 'C', 157);
INSERT INTO `option_info` VALUES (636, '配置文件中明文保存密码', 1, '', 'D', 157);
INSERT INTO `option_info` VALUES (637, '方法的局部变量表', 1, '', 'A', 158);
INSERT INTO `option_info` VALUES (638, '操作数栈', 1, '', 'B', 158);
INSERT INTO `option_info` VALUES (639, '动态连接', 1, '', 'C', 158);
INSERT INTO `option_info` VALUES (640, '方法返回地址', 1, '', 'D', 158);
INSERT INTO `option_info` VALUES (641, '堆区', 1, '', 'A', 159);
INSERT INTO `option_info` VALUES (642, '方法区', 1, '', 'B', 159);
INSERT INTO `option_info` VALUES (643, 'int', 0, '', 'A', 160);
INSERT INTO `option_info` VALUES (644, 'long', 0, '', 'B', 160);
INSERT INTO `option_info` VALUES (645, 'BigInteger', 1, '', 'C', 160);
INSERT INTO `option_info` VALUES (646, 'byte', 0, '', 'D', 160);
INSERT INTO `option_info` VALUES (647, '501', 1, '', 'A', 161);
INSERT INTO `option_info` VALUES (648, '1', 0, '', 'B', 161);
INSERT INTO `option_info` VALUES (649, '0', 0, '', 'C', 161);
INSERT INTO `option_info` VALUES (650, '5', 0, '', 'D', 161);
INSERT INTO `option_info` VALUES (651, '\\W', 1, '', 'A', 162);
INSERT INTO `option_info` VALUES (652, '\\w', 0, '', 'B', 162);
INSERT INTO `option_info` VALUES (653, '\\t', 0, '', 'C', 162);
INSERT INTO `option_info` VALUES (654, '\\v', 0, '', 'D', 162);
INSERT INTO `option_info` VALUES (655, 'reduce()', 0, '', 'A', 163);
INSERT INTO `option_info` VALUES (656, 'map()', 1, '', 'B', 163);
INSERT INTO `option_info` VALUES (657, 'forEach()', 0, '', 'C', 163);
INSERT INTO `option_info` VALUES (658, 'stream()', 0, '', 'D', 163);
INSERT INTO `option_info` VALUES (659, '0', 1, '', 'A', 164);
INSERT INTO `option_info` VALUES (660, '100', 0, '', 'B', 164);
INSERT INTO `option_info` VALUES (661, '1', 0, '', 'C', 164);
INSERT INTO `option_info` VALUES (662, '99', 0, '', 'D', 164);
INSERT INTO `option_info` VALUES (663, '内部基于指针形式可以随机读写文件', 0, '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', 'A', 165);
INSERT INTO `option_info` VALUES (664, '可以通过RandomAccessFile的FileChannel间进行mmap操作', 0, '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', 'B', 165);
INSERT INTO `option_info` VALUES (665, 'RandomAccessFile继承InputStream和OutputStream', 1, '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', 'C', 165);
INSERT INTO `option_info` VALUES (666, 'RandomAccessFile只能对文件进行操作', 0, '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', 'D', 165);
INSERT INTO `option_info` VALUES (667, '支持r,rw,rws,rwd四种模式', 0, '解析：\nRandomAccessFile父类：java.lang.Object。RandomAccessFile 虽然属于java.io下的类，但它不是InputStream或者OutputStream的子类；它也不同于FileInputStream和FileOutputStream。', 'E', 165);
INSERT INTO `option_info` VALUES (668, 'ABCDE', 0, '解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。', 'A', 166);
INSERT INTO `option_info` VALUES (669, 'ABCDEABCDEACBDE', 1, '解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。', 'B', 166);
INSERT INTO `option_info` VALUES (670, '编译报错', 0, '解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。', 'C', 166);
INSERT INTO `option_info` VALUES (671, 'ABCDE\nABCDE\nABCDE', 0, '解析：\nnew FileOutputStream构造器的第二个参数表示是否追加写入，如果为true，表示将文件内容追加到已存在文件，否则，覆盖掉已存在文件。', 'D', 166);
INSERT INTO `option_info` VALUES (672, 'BufferedReader', 1, '', 'A', 167);
INSERT INTO `option_info` VALUES (673, 'BufferedWriter', 0, '', 'B', 167);
INSERT INTO `option_info` VALUES (674, 'BufferedInputStream', 0, '', 'C', 167);
INSERT INTO `option_info` VALUES (675, 'BufferedOutputStream', 0, '', 'D', 167);
INSERT INTO `option_info` VALUES (676, 'FileChannel从文件读取数据，或将数据写入文件，无法设置为非阻塞模式', 1, '解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。', 'A', 168);
INSERT INTO `option_info` VALUES (677, 'DatagramChannel使用TCP协议通过网络来读写数据', 0, '解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。', 'B', 168);
INSERT INTO `option_info` VALUES (678, 'SocketChannel使用UDP协议通过网络来读写数据', 0, '解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。', 'C', 168);
INSERT INTO `option_info` VALUES (679, 'ServerSocketChannel可以监听新进来的TCP连接', 1, '解析：\nFileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。\nJava NIO中的DatagramChannel是一个能收发UDP包的通道。\nJava NIO中的SocketChannel是一个连接到TCP网络套接字的通道。', 'D', 168);
INSERT INTO `option_info` VALUES (680, '创建文件时指定合理的访问权限', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'A', 169);
INSERT INTO `option_info` VALUES (681, '对所有外部输入进行校验', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'B', 169);
INSERT INTO `option_info` VALUES (682, '记录日志时可以抛异常', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'C', 169);
INSERT INTO `option_info` VALUES (683, '禁止不受信任的代码直接终止JVM', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'D', 169);
INSERT INTO `option_info` VALUES (684, '临时文件由于会定期被清理掉，所以不用显示的清理临时文件', 0, '解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值', 'A', 170);
INSERT INTO `option_info` VALUES (685, 'java.nio包中的Buffer类定义了一系列方法，如wrap()、slice()、duplicate()，这些方法会创建一个新的buffer对象，修改这个新buffer对象不会导致原始的封装数据也被修改', 0, '解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值', 'B', 170);
INSERT INTO `option_info` VALUES (686, '运行一个外部进程时，如果此进程往其输出流发送任何数据，则必须将其输出流清空。类似的，如果进程会往其错误流发送数据，其错误流也必须被清空', 1, '解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值', 'C', 170);
INSERT INTO `option_info` VALUES (687, 'Java代码中常用的抽象方法Reader.read()方法用于从流中读取一个字节或字符，返回值的范围为0～65535，所以应定义char类型接收返回值', 0, '解析：\n规则6.1 临时文件使用完毕必须及时删除\n规则6.2 禁止将Buffer对象封装的数据暴露给不可信代码\n规则6.3 防止让外部进程阻塞在输入输出流上\n规则6.4 对于从流中读取一个字符或字节的方法，使用int类型的返回值', 'D', 170);
INSERT INTO `option_info` VALUES (688, 'NIO中的ServerSocketChannel可以同时监听TCP链接，每一个新来的链接都会创建一个SocketChannel', 0, '解析：\n一个选择器最多可以同时被63个通道一起注册使用。', 'A', 171);
INSERT INTO `option_info` VALUES (689, 'Java NIO中的一个选择器只能注册一个通道', 1, '解析：\n一个选择器最多可以同时被63个通道一起注册使用。', 'B', 171);
INSERT INTO `option_info` VALUES (690, 'NIO各种流是非阻塞的，如果没有数据可用也不会阻塞线程', 0, '解析：\n一个选择器最多可以同时被63个通道一起注册使用。', 'C', 171);
INSERT INTO `option_info` VALUES (691, 'Java普通IO是面向流的，NIO是面向缓冲区的', 0, '解析：\n一个选择器最多可以同时被63个通道一起注册使用。', 'D', 171);
INSERT INTO `option_info` VALUES (692, 'Linux的IO模型分为五种，阻塞IO，非阻塞IO，多路复用IO，信号驱动，异步IO', 0, '', 'A', 172);
INSERT INTO `option_info` VALUES (693, '大部分高性能的IO中间件，如nignx，都是使用多路复用IO', 0, '', 'B', 172);
INSERT INTO `option_info` VALUES (694, '多路复用IO没有一个线程需要被阻塞', 1, '', 'C', 172);
INSERT INTO `option_info` VALUES (695, '多路复用IO依赖操作系统的能力，具体而言就是select/poll/epoll', 0, '', 'D', 172);
INSERT INTO `option_info` VALUES (696, 'server socket的accpet()监听客户端连接', 1, '解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)', 'A', 173);
INSERT INTO `option_info` VALUES (697, '执行socket的输出流写数据', 1, '解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)', 'B', 173);
INSERT INTO `option_info` VALUES (698, '执行socket的输入流读取数据', 1, '解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)', 'C', 173);
INSERT INTO `option_info` VALUES (699, 'Socket的getOutputStream()，getInputStream()', 0, '解析：\n哪些Socket API会阻塞：\naccept、connect、recv(recvfrom)、send(sendto)、closesocket、select(poll或epoll)', 'D', 173);
INSERT INTO `option_info` VALUES (700, '内存泄漏', 1, '解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。', 'A', 174);
INSERT INTO `option_info` VALUES (701, '无任何问题', 0, '解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。', 'B', 174);
INSERT INTO `option_info` VALUES (702, '内存溢出', 0, '解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。', 'C', 174);
INSERT INTO `option_info` VALUES (703, '抛出异常', 0, '解析：\n如果一个对象存入Hash集合后hashcode随即发生变化，结果就是无法在集合内找到该对象，进而不能删除该对象，最终导致内存泄漏。', 'D', 174);
INSERT INTO `option_info` VALUES (704, 'Math.abs', 0, '', 'A', 175);
INSERT INTO `option_info` VALUES (705, 'num++', 0, '', 'B', 175);
INSERT INTO `option_info` VALUES (706, 'num%num1', 1, '', 'C', 175);
INSERT INTO `option_info` VALUES (707, 'num/num1', 0, '', 'D', 175);
INSERT INTO `option_info` VALUES (708, 'float f = 10f;', 1, '', 'A', 176);
INSERT INTO `option_info` VALUES (709, 'char c = 10.0;', 0, '', 'B', 176);
INSERT INTO `option_info` VALUES (710, 'byte b = 10b;', 0, '', 'C', 176);
INSERT INTO `option_info` VALUES (711, 'double d = 10;', 1, '', 'D', 176);
INSERT INTO `option_info` VALUES (712, 'float f = 10.0;', 0, '', 'E', 176);
INSERT INTO `option_info` VALUES (713, 'double d = 10.0;', 1, '', 'F', 176);
INSERT INTO `option_info` VALUES (714, 'float f1 = 3.123', 0, '', 'A', 177);
INSERT INTO `option_info` VALUES (715, 'char c1 = 1;', 1, '', 'B', 177);
INSERT INTO `option_info` VALUES (716, 'int x = 1.0', 0, '', 'C', 177);
INSERT INTO `option_info` VALUES (717, 'byte', 1, 'short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);', 'A', 178);
INSERT INTO `option_info` VALUES (718, 'float', 1, 'short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);', 'B', 178);
INSERT INTO `option_info` VALUES (719, 'String', 0, 'short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);', 'C', 178);
INSERT INTO `option_info` VALUES (720, 'long', 1, 'short s = 1;\nsqrt(s);\nbyte b = 1;\nsqrt(b);\nfloat f = 1F;\nsqrt(f);\nlong l = 1L;\nsqrt(l);\nint i = 1;\nsqrt(i);\nchar c = \'a\';\nsqrt(c);\nboolean bool = false;\n// sqrt(bool);\nString str=\"hello\";\n// sqrt(str);', 'D', 178);
INSERT INTO `option_info` VALUES (721, 'ConcurrentHashMap不允许有null的key、value', 0, '解析：\nTreeMap键可以为\'null\'，值不允许', 'A', 179);
INSERT INTO `option_info` VALUES (722, 'TreeMap可以有null的key、value', 1, '解析：\nTreeMap键可以为\'null\'，值不允许', 'B', 179);
INSERT INTO `option_info` VALUES (723, 'ConcurrentHashMap是线程安全的', 0, '解析：\nTreeMap键可以为\'null\'，值不允许', 'C', 179);
INSERT INTO `option_info` VALUES (724, 'HashMap线程不安全，但效率高', 0, '解析：\nTreeMap键可以为\'null\'，值不允许', 'D', 179);
INSERT INTO `option_info` VALUES (725, '多线程环境下使用CourrentHashMap和Collections. synchronizedMap实现同步效率差别不大', 0, '', 'A', 180);
INSERT INTO `option_info` VALUES (726, 'Collections. synchronizedMap不是线程安全的', 0, '', 'B', 180);
INSERT INTO `option_info` VALUES (727, '多线程环境下使用HashTable和Collections. synchronizedMap实现同步效率差别不大', 1, '', 'C', 180);
INSERT INTO `option_info` VALUES (728, 'ConcurrentHashMap的锁粒度较大', 0, '', 'D', 180);
INSERT INTO `option_info` VALUES (729, '往一个ArrayList或者Vector里插入一个元素时，如果内部数组空间不够，ArrayList或Vector会扩展它的大小。Vector在默认情况下增长一倍的大小，而ArrayList增加50%的大小', 1, '解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。', 'A', 181);
INSERT INTO `option_info` VALUES (730, 'ArrayList、Vector、HashMap、StringBuilder和StringBuffer都是线程不安全的', 0, '解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。', 'B', 181);
INSERT INTO `option_info` VALUES (731, 'Vector类实现了一个动态数组，默认不传参数时，构造容量为16的大小，也可以传参指定容量大小；ArrayList就是动态的数组，默认不传参数时，构造容量为10的大小，也可以传参指定容量大小', 0, '解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。', 'C', 181);
INSERT INTO `option_info` VALUES (732, 'ConcurrentHashMap、HashMap、HashSet都不支持key为null，且遍历使用的都是Iterator迭代器，其中只有HashTable是线程安全的', 0, '解析：\n1) 线程安全的集合：\nVector\nHashTable\nStringBuffer\nConcurrentHashMap\nStack\n2) 非线程安全的集合：\nArrayList\nLinkedList\nHashMap\nHashSet\nTreeMap\nTreeSet\nStringBulider\nLinkedHashSet\nLinkedHashMap\n3) DEFAULT_INITIAL_CAPACITY，比如ArrayList(默认10)、Vector(默认10)、StringBuilder(默认16)、StringBuffer(默认16)、HashMap(默认16)、HashSet(默认16)、XxxBlockingQueue(array的要手工指定，linked默认Integer.MAX_VALUE)等等。', 'D', 181);
INSERT INTO `option_info` VALUES (733, 'HashMap键、值均可以为null值', 1, '', 'A', 182);
INSERT INTO `option_info` VALUES (734, 'HashMap中的数据是无序的', 1, '', 'B', 182);
INSERT INTO `option_info` VALUES (735, 'TreeMap中的键是自动排序的，不允许为null值', 1, '', 'C', 182);
INSERT INTO `option_info` VALUES (736, 'LinkedHashMap插入元素是有序的', 1, '', 'D', 182);
INSERT INTO `option_info` VALUES (737, '把第parameterIndex-1的参数值设置为x', 0, '', 'A', 183);
INSERT INTO `option_info` VALUES (738, '把第parameterIndex的参数值设置为x', 1, '', 'B', 183);
INSERT INTO `option_info` VALUES (739, '把第x-1的参数值设置为parameterIndex', 0, '', 'C', 183);
INSERT INTO `option_info` VALUES (740, '把第x的参数值设置为parameterIndex', 0, '', 'D', 183);
INSERT INTO `option_info` VALUES (741, '保留表而删除所有数据的时候建议使用truncate', 1, '', 'A', 184);
INSERT INTO `option_info` VALUES (742, '删除部分数据行时，可以使用delete，并且带上where子句', 1, '', 'B', 184);
INSERT INTO `option_info` VALUES (743, 'drop delete truncate只删除表的数据，不会删除表的结构', 0, '', 'C', 184);
INSERT INTO `option_info` VALUES (744, 'truncate drop是dll，操作立即生效，原始数据不放到rollback segment中，不能回滚', 1, '', 'D', 184);
INSERT INTO `option_info` VALUES (745, 'DataSource是用于获取数据库链接的接口', 0, '解析：\nDataSource对象的属性在必要时可以修改。', 'A', 185);
INSERT INTO `option_info` VALUES (746, 'DataSource对象的属性不可以修改', 1, '解析：\nDataSource对象的属性在必要时可以修改。', 'B', 185);
INSERT INTO `option_info` VALUES (747, 'DataSource主要有三种类型实现：基本实现、连接池实现、分布式事务实现', 0, '解析：\nDataSource对象的属性在必要时可以修改。', 'C', 185);
INSERT INTO `option_info` VALUES (748, '通过DataSource对象访问的驱动程序本身不会向DriverManager注册', 0, '解析：\nDataSource对象的属性在必要时可以修改。', 'D', 185);
INSERT INTO `option_info` VALUES (749, '命令行', 1, '', 'A', 186);
INSERT INTO `option_info` VALUES (750, '用户输入', 1, '不可信数据定义：\n1) 文件（包括程序的配置文件）\n2) 注册表\n3) 网络\n4) 环境变量\n5) 命令行\n6) 用户输入（包括命令行、界面）\n7) 用户态数据（对于内核程序）\n8) 进程间通信（包括管道、消息、共享内存、socket等、RPC）\n9) 函数参数（对于API）\n10) 全局变量（在本函数内，其他线程会修改全局变量）', 'B', 186);
INSERT INTO `option_info` VALUES (751, '环境变量', 1, '', 'C', 186);
INSERT INTO `option_info` VALUES (752, '网络数据', 1, '', 'D', 186);
INSERT INTO `option_info` VALUES (753, '使用类名调用静态方法，而不要使用实例或表达式来调用', 0, '', 'A', 187);
INSERT INTO `option_info` VALUES (754, '方法的代码块不要嵌套过深，不能超过4层', 0, '', 'B', 187);
INSERT INTO `option_info` VALUES (755, '当返回类型为数组或者容器时，应返回长度为0的数组或者容器', 1, '', 'C', 187);
INSERT INTO `option_info` VALUES (756, 'personName变量需要判断是否为null', 0, '', 'D', 187);
INSERT INTO `option_info` VALUES (757, 'int a,b;', 1, '解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)', 'A', 188);
INSERT INTO `option_info` VALUES (758, 'int replacementLen = replacement.length();\nString string = sequence.toString();\nint pos = indexIn(string);\nif (replacementLen == 0) {\nreturn removeFrom(sequence);\n}\nif (replacementLen == 1) {\nreturn replaceFrom(sequence, replacement.charAt(0));\n}\nif (pos == -1) {\nreturn string;\n}', 1, '解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)', 'B', 188);
INSERT INTO `option_info` VALUES (759, 'String args[];', 1, '解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)', 'C', 188);
INSERT INTO `option_info` VALUES (760, 'public boolean matchs (char c) {\nswitch (c) {\ncase \'\\t\':\ncase \'\\n\':\ncase \'\\u205f\':\ncase \'\\u3000\':\nreturn true;\ncase \'\\u2007\':\nreturn false;\ndefault:\nreturn false;\n}\n}', 1, '解析：\nA错，违反了《华为Java语言通用编程规范-V4.6》规则3.7 每行声明一个变量\nB错，违反了《华为Java语言通用编程规范-V4.6》建议3.10 变量被声明在接近它们首次使用的行\nC错，违反了《华为Java语言通用编程规范-V4.6》规则3.8 禁止C风格的数组声明\nD错，违反了《华为Java语言通用编程规范-V4.6》规则3.9 case语句块结束时如果不加break，需要有注释说明\n(fall-through)', 'D', 188);
INSERT INTO `option_info` VALUES (761, 'Socket s = new Socket(\"10.116.123.112\", 6526);\nInputStream stream = s.getInputStream();\n// use thread read data', 1, '', 'A', 189);
INSERT INTO `option_info` VALUES (762, 'Socket s = new Socket(\"10.116.123.112\", 6526);\ns.setSoTimeout(2000)\nInputStream stream = s.getInputStream();\n// use thread read data', 0, '', 'B', 189);
INSERT INTO `option_info` VALUES (763, 'Socket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526), 1000);\nInputStream stream = s.getInputStream();\n// use thread read data', 0, '', 'C', 189);
INSERT INTO `option_info` VALUES (764, 'Socket s = new Socket();\ns.connect(new InetSocketAddress(\"10.116.123.112\", 6526));\nInputStream stream = s.getInputStream();\n// use thread read data', 1, '', 'D', 189);
INSERT INTO `option_info` VALUES (765, 'equals()', 0, '解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。', 'A', 190);
INSERT INTO `option_info` VALUES (766, 'writeObject()', 1, '解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。', 'B', 190);
INSERT INTO `option_info` VALUES (767, 'readObject()', 1, '解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。', 'C', 190);
INSERT INTO `option_info` VALUES (768, 'hashCode()', 0, '解析：\n规则7.3 防止序列化和反序列化被利用来绕过安全管理器\n错误示例中，安全管理器检查被应用在构造器中，但在序列化与反序列化涉及的writeObject()和readObject()方法中没有用到。这样会允许不可信代码恶意创建类实例。', 'D', 190);
INSERT INTO `option_info` VALUES (769, '1.8.0_45', 0, '解析：\npolicy文件里面java.version的权限是read，程序去write权限不足', 'A', 191);
INSERT INTO `option_info` VALUES (770, '不确定', 0, '解析：\npolicy文件里面java.version的权限是read，程序去write权限不足', 'B', 191);
INSERT INTO `option_info` VALUES (771, 'java.security.AccessControlException.access denied', 1, '解析：\npolicy文件里面java.version的权限是read，程序去write权限不足', 'C', 191);
INSERT INTO `option_info` VALUES (772, '1.7.0_45', 0, '解析：\npolicy文件里面java.version的权限是read，程序去write权限不足', 'D', 191);
INSERT INTO `option_info` VALUES (773, '序列化只能保存对象的非静态成员交量，不能保存任何的成员方法和静态的成员变量', 0, '解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。', 'A', 192);
INSERT INTO `option_info` VALUES (774, 'transient关键字的作用是：阻止实例中那些用此关键字声明的变量持久化', 0, '解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。', 'B', 192);
INSERT INTO `option_info` VALUES (775, '当一个父类实现序列化，子类若要实现序列化，需要显式实现Serializable接口', 1, '解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。', 'C', 192);
INSERT INTO `option_info` VALUES (776, '一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口', 0, '解析：\n当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口。\n一个子类实现了Serializable接口，它的父类都没有实现Serializable接口，要想将父类对象也序列化，就需要让父类也实现Serializable接口。', 'D', 192);
INSERT INTO `option_info` VALUES (777, '对象的序列化结果是可以在网络中进行传输的字节序列', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'A', 193);
INSERT INTO `option_info` VALUES (778, '反序列化的输入数据可以由外部输入指定', 1, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'B', 193);
INSERT INTO `option_info` VALUES (779, 'transient关键字可以阻止变量被序列化到文件中', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'C', 193);
INSERT INTO `option_info` VALUES (780, '不要序列化未经加密的敏感数据', 0, '解析：\nhttp://3ms.huawei.com/km/blogs/details/5896699', 'D', 193);
INSERT INTO `option_info` VALUES (781, '不能加finally', 0, '解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。', 'A', 194);
INSERT INTO `option_info` VALUES (782, '按照创建的资源顺序关闭', 0, '解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。', 'B', 194);
INSERT INTO `option_info` VALUES (783, 'try中创建的变量在catch和finally可见', 0, '解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。', 'C', 194);
INSERT INTO `option_info` VALUES (784, '资源关闭在catch和finally中语句执行之前', 1, '解析：\n使用try-with-resources优雅的关闭资源。try-with-resources语句保证了每个声明了的资源在语句结束的时候都会被关闭。\n任何实现了java.lang.AutoCloseable接口的对象，或者实现了java.io.Closeable接口的对象，都可以当做资源使用，Closeable继承了AutoCloseable，任何的catch和finally代码块都在所有被声明的资源被关闭后执行。', 'D', 194);
INSERT INTO `option_info` VALUES (785, 'InputStream in = ...;\nException ex = null;\ntry {\ntry {\n//code that might throw exceptions\n} catch (Exception e) {\nex = e;\nthrow e;\n}\n} finally {\ntry {\nin.close();\n} catch (Exception e) {\nif (ex == null) throw e;\n}\n}', 0, '', 'A', 195);
INSERT INTO `option_info` VALUES (786, 'try (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}', 1, '', 'B', 195);
INSERT INTO `option_info` VALUES (787, 'InputStream in = ...\ntry {\n//code that might throw exceptions\n} finally {\nin.close();\n}', 0, '', 'C', 195);
INSERT INTO `option_info` VALUES (788, 'DSA', 1, '解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA', 'A', 196);
INSERT INTO `option_info` VALUES (789, 'ECDSA', 1, '解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA', 'B', 196);
INSERT INTO `option_info` VALUES (790, 'RSA', 0, '解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA', 'C', 196);
INSERT INTO `option_info` VALUES (791, 'RC4', 0, '解析：\n推荐使用的数字签名算法有：\nDSA\nECDSA', 'D', 196);
INSERT INTO `option_info` VALUES (792, 'zip文件解压时，可以使用entry.getSize()对解压缩文件进行文件大小判断', 1, '解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。', 'A', 197);
INSERT INTO `option_info` VALUES (793, 'zip文件解压缩时，需判断文件名称中是否存在../这样的返回上层路径的情况', 0, '解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。', 'B', 197);
INSERT INTO `option_info` VALUES (794, 'zip文件解压时，需对解压缩的文件数量进行限制检查', 0, '解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。', 'C', 197);
INSERT INTO `option_info` VALUES (795, 'zip文件解压时，需通过边阅读文件内容边统计文件实际大小，对文件大小进行限制检查', 0, '解析：\n恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段，因此，getSize()方法的返回值是不可靠的，本地资源实际仍可能被过度消耗。', 'D', 197);
INSERT INTO `option_info` VALUES (796, 'public Image loadImage(String path) throws FileNotFoundException, EOFException', 0, '', 'A', 198);
INSERT INTO `option_info` VALUES (797, 'public Image loadImage(String path) throws IOException', 1, '', 'B', 198);
INSERT INTO `option_info` VALUES (798, 'public void drawImage(int num) throws ArrayIndexOutOfBoundsException', 0, '', 'C', 198);
INSERT INTO `option_info` VALUES (799, 'private final Object lock = SomeObject.class;', 0, '解析：\nA. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。\n\nC. 非信任域内，锁不能用public\n\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化', 'A', 199);
INSERT INTO `option_info` VALUES (800, 'private final Object lock = new Object();', 1, '解析：\nA. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。\n\nC. 非信任域内，锁不能用public\n\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化', 'B', 199);
INSERT INTO `option_info` VALUES (801, 'public final Object lock = new Object();', 0, '解析：\nA. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。\n\nC. 非信任域内，锁不能用public\n\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化', 'C', 199);
INSERT INTO `option_info` VALUES (802, 'transient final Object lock = new Object();', 0, '解析：\nA. 类锁，所有的实例化对象都共用一把锁，用来控制静态方法的同步。\n\nC. 非信任域内，锁不能用public\n\nD. transient修饰后的变量，变量如果是用户自定义变量，则类需要实现序列化接口，而变量本身不可以序列化', 'D', 199);
INSERT INTO `option_info` VALUES (803, 'private final String lock = new String(\"LOCK\").intern();\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}', 1, '解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例', 'A', 200);
INSERT INTO `option_info` VALUES (804, 'private final String lock = \"lock\"\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}', 1, '解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例', 'B', 200);
INSERT INTO `option_info` VALUES (805, 'private final String lock = new String(\"LOCK\");\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}', 0, '解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例', 'C', 200);
INSERT INTO `option_info` VALUES (806, 'private final Boolean = Boolean.TRUE;\npublic void doSomthing() {\nsynchronized(lock) {\n// ...\n}\n}', 1, '解析：\n规则5.2 禁止基于可被重用的对象进行同步\nA、B、D均为规则5.2的错误示例，C为正确示例', 'D', 200);
INSERT INTO `option_info` VALUES (807, 'volatile修饰的变量会优先读写线程工作内存', 0, '', 'A', 201);
INSERT INTO `option_info` VALUES (808, '使用volatile可以解决原子性问题', 0, '', 'B', 201);
INSERT INTO `option_info` VALUES (809, '使用volatile修改的变量，可以直接读取，不会有并发问题', 0, '', 'C', 201);
INSERT INTO `option_info` VALUES (810, 'volatile可以解决数据可见性问题，即对volatile变量的变更，可以直接写入主内存', 1, '', 'D', 201);
INSERT INTO `option_info` VALUES (811, 'AtomicReferenceArray', 0, '', 'A', 202);
INSERT INTO `option_info` VALUES (812, 'AtomicIntegerArray', 0, '', 'B', 202);
INSERT INTO `option_info` VALUES (813, 'AtomicReference', 1, '', 'C', 202);
INSERT INTO `option_info` VALUES (814, 'AtomicLongArray', 0, '', 'D', 202);
INSERT INTO `option_info` VALUES (815, '语义分析及生成字节码', 1, '', 'A', 203);
INSERT INTO `option_info` VALUES (816, '词法分析及填充符号表', 1, '', 'B', 203);
INSERT INTO `option_info` VALUES (817, 'Server Compiler', 0, '', 'C', 203);
INSERT INTO `option_info` VALUES (818, '注解处理', 1, '', 'D', 203);
INSERT INTO `option_info` VALUES (819, 'Client Compiler', 0, '', 'E', 203);
INSERT INTO `option_info` VALUES (820, '默认情况下，Java应用启动过程涉及三个ClassLoader：Boostrap, Extension, System', 0, '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', 'A', 204);
INSERT INTO `option_info` VALUES (821, '一般的情况不同ClassLoader装载的类是不相同的，但接口类例外，对于同一接口所有类装载器装载所获得的类是相同的', 1, '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', 'B', 204);
INSERT INTO `option_info` VALUES (822, '类装载器需要保证类装载过程的线程安全', 0, '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', 'C', 204);
INSERT INTO `option_info` VALUES (823, 'ClassLoader的loadClass在装载一个类时，如果该类不存在它将返回null', 1, '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', 'D', 204);
INSERT INTO `option_info` VALUES (824, 'ClassLoader的父子结构中，默认装载采用了父优先', 0, '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', 'E', 204);
INSERT INTO `option_info` VALUES (825, '所有ClassLoader装载的类都来自CLASSPATH环境指定的路径', 1, '解析：\nB：JVM在判定两个class是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM才认为这两个class是相同的\nD：ClassLoader的loadClass方法加载不存在的类会抛ClassNotFoundException\nF：自定义类加载器实现继承ClassLoader后重写了findClass方法加载指定路径上的class，Boostrap加载器加载核心库类，Extension加载器加载jre/lib/ext下的类，System加载器加载CLASSPATH环境指定路径的类', 'F', 204);
INSERT INTO `option_info` VALUES (826, '一个类被首次加载后，会长期驻留JVM，直到JVM退出', 0, '解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。', 'A', 205);
INSERT INTO `option_info` VALUES (827, '由用户自定义的类加载器加载的类是可以被卸载的', 1, '解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。', 'B', 205);
INSERT INTO `option_info` VALUES (828, '由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载', 1, '解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。', 'C', 205);
INSERT INTO `option_info` VALUES (829, '所有的java类都有一个静态属性class，它代表这个类的class对象', 1, '解析：\nA: 类的生命周期包括7个部分：加载-验证-准备-解析-初始化-使用-卸载\n当一个类被加载、连接和初始化后，它的生命周期就开始了。当代表某个类的Class对象不再被引用，即不可达时，Class对象就会结束生命周期，该类在方法区内的数据也会被卸载，从而结束该类的生命周期。由此可见，一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。\nB：由用户自定义的类加载器加载的类是可以被卸载的。\nC：因为Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。前面已经说过当某个类代表的Class对象被回收的时候，这个类才会被卸载。因为该类的Class对象一直被三种类加载器引用，所以这个类在JVM运行过程中永远不会被卸载。\nD：所有的Java类都有一个静态属性class，它代表这个类的Class对象。', 'D', 205);
INSERT INTO `option_info` VALUES (830, '抽象类必须包含一个抽象方法', 0, '', 'A', 206);
INSERT INTO `option_info` VALUES (831, '抽象类的方法必须是抽象的', 0, '', 'B', 206);
INSERT INTO `option_info` VALUES (832, '声明抽象类必须带有abstract', 1, '', 'C', 206);
INSERT INTO `option_info` VALUES (833, '抽象类可以被实例化', 0, '', 'D', 206);
INSERT INTO `option_info` VALUES (834, 'static class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<? super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}', 1, '解析：\n泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<? super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<? extends T>。\n- 2. 经常往里插入的，适合用<? super T>。\n<? extends T> = <subClass extends T> = T以及T的子类\n<? super T> = <superClass super T> = T以及T的父类', 'A', 207);
INSERT INTO `option_info` VALUES (835, 'static class Fruit{}\nstatic class Apple extends Fruit{}\npublic static void main(String[] args) {\nList<? extends Fruit> list = new ArrayList<>();\nlist.add(new Apple());\n}', 0, '解析：\n泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<? super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<? extends T>。\n- 2. 经常往里插入的，适合用<? super T>。\n<? extends T> = <subClass extends T> = T以及T的子类\n<? super T> = <superClass super T> = T以及T的父类', 'B', 207);
INSERT INTO `option_info` VALUES (836, 'public class ShowTest<T> {\npublic static void show(T t) {\nSystem.out.println(t.toString());\n}\n}', 0, '解析：\n泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<? super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<? extends T>。\n- 2. 经常往里插入的，适合用<? super T>。\n<? extends T> = <subClass extends T> = T以及T的子类\n<? super T> = <superClass super T> = T以及T的父类', 'C', 207);
INSERT INTO `option_info` VALUES (837, 'static class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}', 1, '解析：\n泛型通配符<? extends T>来接收返回的数据，此写法的泛型集合不能使用add方法， 而<? super T>不能使用get方法，作为接口调用赋值时易出错。\n- 1. 频繁往外读取内容的，适合用<? extends T>。\n- 2. 经常往里插入的，适合用<? super T>。\n<? extends T> = <subClass extends T> = T以及T的子类\n<? super T> = <superClass super T> = T以及T的父类', 'D', 207);
INSERT INTO `option_info` VALUES (838, '[0,0],[0,0]', 0, '', 'A', 208);
INSERT INTO `option_info` VALUES (839, '[5,5],[0,0]', 0, '', 'B', 208);
INSERT INTO `option_info` VALUES (840, '[0,0],[5,5]', 1, '', 'C', 208);
INSERT INTO `option_info` VALUES (841, '[5,5],[5,5]', 0, '', 'D', 208);
INSERT INTO `option_info` VALUES (842, '20 100', 1, '', 'A', 209);
INSERT INTO `option_info` VALUES (843, '20 200', 0, '', 'B', 209);
INSERT INTO `option_info` VALUES (844, '10 200', 0, '', 'C', 209);
INSERT INTO `option_info` VALUES (845, '10 100', 0, '', 'D', 209);
INSERT INTO `option_info` VALUES (846, '输出Base()', 0, '解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数', 'A', 210);
INSERT INTO `option_info` VALUES (847, '输出Base(int i)', 0, '解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数', 'B', 210);
INSERT INTO `option_info` VALUES (848, '什么都不输出', 0, '解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数', 'C', 210);
INSERT INTO `option_info` VALUES (849, '编译错误', 1, '解析：\n若父类构造函数有参数，则在子类构造函数中需显示调用该父类构造函数', 'D', 210);
INSERT INTO `option_info` VALUES (850, 'debug', 1, '', 'A', 211);
INSERT INTO `option_info` VALUES (851, 'warn', 0, '', 'B', 211);
INSERT INTO `option_info` VALUES (852, 'error', 0, '', 'C', 211);
INSERT INTO `option_info` VALUES (853, 'trace', 1, '', 'D', 211);
INSERT INTO `option_info` VALUES (854, '序列化敏感数据', 1, '解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）', 'A', 212);
INSERT INTO `option_info` VALUES (855, '传输敏感数据', 1, '解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）', 'B', 212);
INSERT INTO `option_info` VALUES (856, '没有使用类似于SSL传输通道', 1, '解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）', 'C', 212);
INSERT INTO `option_info` VALUES (857, '敏感数据需要长久保存（比如在硬盘驱动器上）', 1, '解析：\n规则7.2 将含敏感数据的对象跨信任域传递前必须进行签名并加密\n在以下场景中，需要对对象密封和数字签名来保证数据安全：\n1) 序列化或传输敏感数据\n2) 没有使用类似于SSL传输通道\n3) 敏感数据需要长久保存（比如在硬盘驱动器上）', 'D', 212);
INSERT INTO `option_info` VALUES (858, '仅加密', 0, '', 'A', 213);
INSERT INTO `option_info` VALUES (859, '仅签名', 0, '', 'B', 213);
INSERT INTO `option_info` VALUES (860, '先加密后签名', 0, '', 'C', 213);
INSERT INTO `option_info` VALUES (861, '先签名后加密', 1, '', 'D', 213);
INSERT INTO `option_info` VALUES (862, '++', 1, '', 'A', 214);
INSERT INTO `option_info` VALUES (863, '%', 0, '', 'B', 214);
INSERT INTO `option_info` VALUES (864, '+=', 1, '', 'C', 214);
INSERT INTO `option_info` VALUES (865, 'Java.lang.math.abs()', 1, '', 'D', 214);
INSERT INTO `option_info` VALUES (866, '子线程自身不必捕获异常，而是由主线程捕获即可', 0, '', 'A', 215);
INSERT INTO `option_info` VALUES (867, '对于运行时异常可调用Thread.setUncaughtExceptionHandler()方法设置运行时异常处理器来进行处理', 1, '', 'B', 215);
INSERT INTO `option_info` VALUES (868, '默认情况下，运行时异常从线程抛出时，会在控制台输出堆栈记录', 1, '', 'C', 215);
INSERT INTO `option_info` VALUES (869, '子线程须自己捕获异常处理', 1, '', 'D', 215);
INSERT INTO `option_info` VALUES (870, '字符向字节转换时，需要注意编码问题', 1, '', 'A', 216);
INSERT INTO `option_info` VALUES (871, '字节流继承于InputStream OutputStream，字符流继承于InputSteamReader OutputStreamWriter', 1, '', 'B', 216);
INSERT INTO `option_info` VALUES (872, '字符流使用了缓冲区(Buffer)，而字节流没有使用缓冲区', 1, '', 'C', 216);
INSERT INTO `option_info` VALUES (873, '字符是字节通过不同编码的包装，相同的字节代表相同的字符', 0, '', 'D', 216);
INSERT INTO `option_info` VALUES (874, 'ArrayList的默认长度值16', 1, '解析：ArrayList默认是10', 'A', 217);
INSERT INTO `option_info` VALUES (875, 'HashMap的默认长度值16', 0, '解析：ArrayList默认是10', 'B', 217);
INSERT INTO `option_info` VALUES (876, 'HashSet的默认长度值16', 0, '解析：ArrayList默认是10', 'C', 217);
INSERT INTO `option_info` VALUES (877, 'StringBuﬀer的默认长度值16', 0, '解析：ArrayList默认是10', 'D', 217);
INSERT INTO `option_info` VALUES (878, 'private final Boolean lock1 = Boolean.FALSE;', 0, '', 'A', 218);
INSERT INTO `option_info` VALUES (879, 'private final Integer lock2 = 0;', 0, '', 'B', 218);
INSERT INTO `option_info` VALUES (880, 'private final String lock3 = \"lock\";', 0, '', 'C', 218);
INSERT INTO `option_info` VALUES (881, 'private final Integer lock4 = new Integer(0);', 1, '', 'D', 218);
INSERT INTO `option_info` VALUES (882, 'Java.lang.OutOfMemoryError', 1, '', 'A', 219);
INSERT INTO `option_info` VALUES (883, 'Java.lang.StackOverflowError', 1, '', 'B', 219);
INSERT INTO `option_info` VALUES (884, 'JarException', 0, '', 'C', 219);
INSERT INTO `option_info` VALUES (885, 'InSufficientResourceException', 1, '', 'D', 219);
INSERT INTO `option_info` VALUES (886, 'JAVA进程出现OOM，主动调用System.exit()，结束进程', 0, '例外场景：\n在命令行应用中调用System.exit()函数是允许的。', 'A', 220);
INSERT INTO `option_info` VALUES (887, '服务出现不能自愈的异常，直接调用System.exit()，终止进程', 0, '例外场景：\n在命令行应用中调用System.exit()函数是允许的。', 'B', 220);
INSERT INTO `option_info` VALUES (888, '允许外部传入的命令中有System.exit()', 0, '例外场景：\n在命令行应用中调用System.exit()函数是允许的。', 'C', 220);
INSERT INTO `option_info` VALUES (889, '命令行工具使用System.exit()', 1, '例外场景：\n在命令行应用中调用System.exit()函数是允许的。', 'D', 220);
INSERT INTO `option_info` VALUES (890, '不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号，建议使用System.lineSeparator()方法获取运行时环境的换行符', 1, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', 'A', 221);
INSERT INTO `option_info` VALUES (891, '编码时尽量依赖平台默认的字符编码方式', 0, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', 'B', 221);
INSERT INTO `option_info` VALUES (892, 'String类的toUpperCase()和toLowerCase()方法、format()方法，建议使用默认的编码模式进行转换', 0, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', 'C', 221);
INSERT INTO `option_info` VALUES (893, '使用java.nio.charset中的类编码解码字符集', 1, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n规则8.9.2 不要依赖平台默认的字符编码方式，使用UTF-8\n规则8.9.3 字符串大小写转换、数字格式化为西方数字时，必须加上Locale.ROOT或Locale.ENGLISH', 'D', 221);
INSERT INTO `option_info` VALUES (894, '如果在传递异常的时候未对其中的敏感信息进行过滤，常常会导致信息泄露', 0, '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', 'A', 222);
INSERT INTO `option_info` VALUES (895, '重点关注异常中的文本消息，异常本身的类型不会泄露敏感信息', 1, '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', 'B', 222);
INSERT INTO `option_info` VALUES (896, '对出于问题定位目的，可将敏感异常信息记录到日志中，但必须做好日志的访问控制，防止日志被任意访问，导致敏感信息泄露给非授权用户。', 0, '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', 'C', 222);
INSERT INTO `option_info` VALUES (897, '可以通过限制输入. 安全策略方式过滤掉异常中的敏感信息', 0, '解析：\n不管是异常中的文本消息，还是异常本身的类型都可能泄露敏感信息。例如FileNotFoundException会透露文件系统的结构信息，而通过异常本身的类型，可以得知所请求的文件不存在。因此，当异常被传递到信任边界以外时，必须同时对敏感的异常消息和敏感的异常类型进行过滤。', 'D', 222);
INSERT INTO `option_info` VALUES (898, '456456456\\d\n123456\n456456456\\d', 0, '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', 'A', 223);
INSERT INTO `option_info` VALUES (899, '456456456\\d\n123456\n123456', 1, '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', 'B', 223);
INSERT INTO `option_info` VALUES (900, '123456\n123456\n123456', 0, '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', 'C', 223);
INSERT INTO `option_info` VALUES (901, '123456\n123456\n45623\\d', 0, '解析：\nString replaceAll(String regex, String replacement)\nString replace(CharSequence target, CharSequence replacement)\nPattern.quote:\nReturns a literal pattern String for the specified String.\nThis method produces a String that can be used to create a Pattern that would match the string s as if it were a literal pattern.', 'D', 223);
INSERT INTO `option_info` VALUES (902, '初始化', 0, '', 'A', 224);
INSERT INTO `option_info` VALUES (903, '准备', 0, '', 'B', 224);
INSERT INTO `option_info` VALUES (904, '解析', 0, '', 'C', 224);
INSERT INTO `option_info` VALUES (905, '加载', 1, '', 'D', 224);
INSERT INTO `option_info` VALUES (906, 'error', 0, '', 'A', 225);
INSERT INTO `option_info` VALUES (907, 'debug', 0, '', 'B', 225);
INSERT INTO `option_info` VALUES (908, 'warn', 0, '', 'C', 225);
INSERT INTO `option_info` VALUES (909, 'info', 1, '', 'D', 225);
INSERT INTO `option_info` VALUES (910, 'CPU运行时间内GC运行的次数', 0, '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', 'A', 226);
INSERT INTO `option_info` VALUES (911, 'CPU运行用户代码的时间与CPU总消耗时间的比值', 1, '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', 'B', 226);
INSERT INTO `option_info` VALUES (912, 'CPU运行时间内GC运行次数与所有运行线程次数的比值', 0, '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', 'C', 226);
INSERT INTO `option_info` VALUES (913, 'CPU运行GC线程的时间与用户代码的时间的比值', 0, '解析：\n吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)', 'D', 226);
INSERT INTO `option_info` VALUES (914, '存在空指针异常风险', 1, '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', 'A', 227);
INSERT INTO `option_info` VALUES (915, '存在数组越界风险', 0, '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', 'B', 227);
INSERT INTO `option_info` VALUES (916, '代码编译报错', 0, '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', 'C', 227);
INSERT INTO `option_info` VALUES (917, '代码无异常风险', 0, '解析：\n上面的错误代码，是Tomcat4.1.24中的一个bug。Cardinality方法中返回col集合中的obj对象出现的次数，当obj为null而elt对象不为null时，调用obj.equals()方法时，就会发生空指针的解引用。', 'D', 227);
INSERT INTO `option_info` VALUES (918, 'float f = 1.3;', 0, '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', 'A', 228);
INSERT INTO `option_info` VALUES (919, 'byte b = 257;', 0, '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', 'B', 228);
INSERT INTO `option_info` VALUES (920, 'boolean b = \"isStoped\";', 0, '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', 'C', 228);
INSERT INTO `option_info` VALUES (921, 'char i = 1;', 1, '解析：\nA错，应为float f = 1.3f;\nB错，byte范围是[-128, 127]\nC错，不是boolean值', 'D', 228);
INSERT INTO `option_info` VALUES (922, 'public void native XXX();', 0, '', 'A', 229);
INSERT INTO `option_info` VALUES (923, 'public native void XXX();', 1, '', 'B', 229);
INSERT INTO `option_info` VALUES (924, 'public native void XXX() {}', 0, '', 'C', 229);
INSERT INTO `option_info` VALUES (925, 'public void static native XXX();', 0, '', 'D', 229);
INSERT INTO `option_info` VALUES (926, '方法需要抽象', 1, '', 'A', 230);
INSERT INTO `option_info` VALUES (927, '功能不单一', 1, '', 'B', 230);
INSERT INTO `option_info` VALUES (928, '过于复杂', 1, '', 'C', 230);
INSERT INTO `option_info` VALUES (929, '不便于他人阅读和修改代码', 1, '', 'D', 230);
INSERT INTO `option_info` VALUES (930, '反射方法', 1, '', 'A', 231);
INSERT INTO `option_info` VALUES (931, '泛型', 1, '', 'B', 231);
INSERT INTO `option_info` VALUES (932, '集合中类型', 1, '', 'C', 231);
INSERT INTO `option_info` VALUES (933, 'POJO RPC某些不需要设置默认值的类型', 1, '', 'D', 231);
INSERT INTO `option_info` VALUES (934, 'writer', 0, '', 'A', 232);
INSERT INTO `option_info` VALUES (935, 'inputstream', 1, '', 'B', 232);
INSERT INTO `option_info` VALUES (936, 'outputstream', 1, '', 'C', 232);
INSERT INTO `option_info` VALUES (937, 'reader', 0, '', 'D', 232);
INSERT INTO `option_info` VALUES (938, 'DES', 1, '', 'A', 233);
INSERT INTO `option_info` VALUES (939, 'RSA', 0, '', 'B', 233);
INSERT INTO `option_info` VALUES (940, 'SKIPJACK', 0, '', 'C', 233);
INSERT INTO `option_info` VALUES (941, 'ECDSA', 0, '', 'D', 233);
INSERT INTO `option_info` VALUES (942, 'XSS', 0, '', 'A', 234);
INSERT INTO `option_info` VALUES (943, '无安全风险', 0, '', 'B', 234);
INSERT INTO `option_info` VALUES (944, '无SQL注入风险，但是将String转化为int型变量时可能会有NumberFormatException抛出', 1, '', 'C', 234);
INSERT INTO `option_info` VALUES (945, 'SQL注入', 0, '', 'D', 234);
INSERT INTO `option_info` VALUES (946, '内存溢出', 0, '', 'A', 235);
INSERT INTO `option_info` VALUES (947, '内存泄露', 0, '', 'B', 235);
INSERT INTO `option_info` VALUES (948, '空指针引用', 1, '', 'C', 235);
INSERT INTO `option_info` VALUES (949, '无安全风险', 0, '', 'D', 235);
INSERT INTO `option_info` VALUES (950, 'System.out.print(\"Hello, world!\\n\");', 0, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。', 'A', 236);
INSERT INTO `option_info` VALUES (951, 'System.out.print(\"Hello, world!\\n\\r\");', 0, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。', 'B', 236);
INSERT INTO `option_info` VALUES (952, 'stringBuilder.append(System.lineSeparator());', 1, '解析：\n规则8.8.1 不要在代码中硬编码\"\\n\"和\"\\r\"作为换行符号\n可以使用System.lineSeparator()获取运行时环境的换行符。', 'C', 236);
INSERT INTO `option_info` VALUES (953, '5', 0, 'fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34', 'A', 237);
INSERT INTO `option_info` VALUES (954, '2', 0, 'fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34', 'B', 237);
INSERT INTO `option_info` VALUES (955, '3', 0, 'fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34', 'C', 237);
INSERT INTO `option_info` VALUES (956, '4', 1, 'fst--是后做运算--fst是先做运算snd=3,fst=4snd=4,fst=34', 'D', 237);
INSERT INTO `option_info` VALUES (957, 'The input is 2\nThe input is 3', 0, 'switch没有break会执行完后面的如果\nint num = 2;\nswitch (num) {\n    case 2:\n        System.out.println(\"The input is 2\");\n    case 1:\n        System.out.println(\"The input is 1\");\n    case 3:\n        System.out.println(\"The input is 3\");\n    default:\n        System.out.println(\"Bad input\");\n}\n会输出 213 Bad input', 'A', 238);
INSERT INTO `option_info` VALUES (958, 'The input is 1', 0, 'switch没有break会执行完后面的如果\nint num = 2;\nswitch (num) {\n    case 2:\n        System.out.println(\"The input is 2\");\n    case 1:\n        System.out.println(\"The input is 1\");\n    case 3:\n        System.out.println(\"The input is 3\");\n    default:\n        System.out.println(\"Bad input\");\n}\n会输出 213 Bad input', 'B', 238);
INSERT INTO `option_info` VALUES (959, 'The input is 2', 0, 'switch没有break会执行完后面的如果\nint num = 2;\nswitch (num) {\n    case 2:\n        System.out.println(\"The input is 2\");\n    case 1:\n        System.out.println(\"The input is 1\");\n    case 3:\n        System.out.println(\"The input is 3\");\n    default:\n        System.out.println(\"Bad input\");\n}\n会输出 213 Bad input', 'C', 238);
INSERT INTO `option_info` VALUES (960, 'The input is 2\nThe input is 3\nBad input', 1, 'switch没有break会执行完后面的如果\nint num = 2;\nswitch (num) {\n    case 2:\n        System.out.println(\"The input is 2\");\n    case 1:\n        System.out.println(\"The input is 1\");\n    case 3:\n        System.out.println(\"The input is 3\");\n    default:\n        System.out.println(\"Bad input\");\n}\n会输出 213 Bad input', 'D', 238);
INSERT INTO `option_info` VALUES (961, 'final Stream<String> stream = Steam.of(\"Red\", \"Blue\", \"Green\");\nList<String> colors = stream.collection(Collector.toList());', 0, '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', 'A', 239);
INSERT INTO `option_info` VALUES (962, 'IntStream stream = IntStream.of(10, 20, 30, 40, 50);', 0, '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', 'B', 239);
INSERT INTO `option_info` VALUES (963, 'long count = Stream.of().count();', 0, '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', 'C', 239);
INSERT INTO `option_info` VALUES (964, 'final Stream<String> stream = Stream.of(\"Red\", \"Blue\", \"Green\");\nSet<String> colors = Stream.toSet();', 1, '解析：\nStream本身没有toSet()的方法，要转成Set，需要使用.collect(Collectors.toSet())', 'D', 239);
INSERT INTO `option_info` VALUES (965, '32位', 1, '', 'A', 240);
INSERT INTO `option_info` VALUES (966, '64位', 0, '', 'B', 240);
INSERT INTO `option_info` VALUES (967, '16位', 0, '', 'C', 240);
INSERT INTO `option_info` VALUES (968, '在32位系统上是32位，在64位系统上是64位', 0, '', 'D', 240);
INSERT INTO `option_info` VALUES (969, '编译错误', 0, '', 'A', 241);
INSERT INTO `option_info` VALUES (970, '123456', 1, '', 'B', 241);
INSERT INTO `option_info` VALUES (971, '运行时抛异常', 0, '', 'C', 241);
INSERT INTO `option_info` VALUES (972, '579', 0, '', 'D', 241);
INSERT INTO `option_info` VALUES (973, '345', 1, '', 'A', 242);
INSERT INTO `option_info` VALUES (974, '134', 0, '', 'B', 242);
INSERT INTO `option_info` VALUES (975, '2345', 0, '', 'C', 242);
INSERT INTO `option_info` VALUES (976, '1345', 0, '', 'D', 242);
INSERT INTO `option_info` VALUES (977, 'false,false,true,false', 1, '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', 'A', 243);
INSERT INTO `option_info` VALUES (978, 'false,false,true,true', 0, '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', 'B', 243);
INSERT INTO `option_info` VALUES (979, 'false,false,false,false', 0, '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', 'C', 243);
INSERT INTO `option_info` VALUES (980, 'true,false,false,false', 0, '解析：\n在Java 8中，Integer缓存池的大小默认为-128~127。', 'D', 243);
INSERT INTO `option_info` VALUES (981, '如果一个类或者一个包被遮掩了，那么不能通过其简单名引用到它，除非是这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字', 0, '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', 'A', 244);
INSERT INTO `option_info` VALUES (982, '遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式', 0, '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', 'B', 244);
INSERT INTO `option_info` VALUES (983, '一个变量不可以遮掩具有相同名字的一个类，即使它们都在同一个范围内', 1, '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', 'C', 244);
INSERT INTO `option_info` VALUES (984, '如果这个名字被用于变量与类都被许可的范围，那么它将引用到变量上', 0, '解析：\n一个变量可以遮掩具有相同名字的一个类，只要它们都在同一个范围内。\n例如：\npublic class Obscure {\nstatic String System; // Obscures type java.lang.System\npublic static void main(String[] args) {\n// Next line won\'t compile: System refers to static field\nSystem.out.println(\"hello, obscure world!\");\n}\n}', 'D', 244);
INSERT INTO `option_info` VALUES (985, '禁止使用主动GC(除非在密码，RMI等方面)，尤其是在频繁/周期性的逻辑中', 0, '', 'A', 245);
INSERT INTO `option_info` VALUES (986, '将对象作为key存入hashMap后，可以对该对象的任意属性进行赋值操作', 1, '', 'B', 245);
INSERT INTO `option_info` VALUES (987, '进行IO操作时，应该在try-with-resource或者finally里关闭资源', 0, '', 'C', 245);
INSERT INTO `option_info` VALUES (988, '可以在循环之外的节点主动GC', 0, '', 'D', 245);
INSERT INTO `option_info` VALUES (989, '仅运行test.bat，并将notepad.exe作为test.bat的参数', 0, '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', 'A', 246);
INSERT INTO `option_info` VALUES (990, '仅运行notepad.exe', 0, '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', 'B', 246);
INSERT INTO `option_info` VALUES (991, '仅运行test.bat', 0, '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', 'C', 246);
INSERT INTO `option_info` VALUES (992, '运行test.bat和notepad.exe', 1, '解析：\nRuntime.getRuntime().exec(\"test.bat & notepad.exe\")，由于bat文件默认是由命令行解释器cmd.exe来解释执行的，这里的“&”符号将会被cmd.exe当做一个命令分隔符，从而导致test.bat与notepad.exe都将会被执行。', 'D', 246);
INSERT INTO `option_info` VALUES (993, 'long test = Stream.of(\"1\",\"2\").count()', 0, '', 'A', 247);
INSERT INTO `option_info` VALUES (994, 'List testList = Stream.of(\"1\",\"2\").collect(Collectors.toList())', 0, '', 'B', 247);
INSERT INTO `option_info` VALUES (995, 'IntStream t = IntStream.of(10,20,30);', 0, '', 'C', 247);
INSERT INTO `option_info` VALUES (996, 'Stream.of(\"1\",\"2\").toSet()', 1, '', 'D', 247);
INSERT INTO `option_info` VALUES (997, 'byte', 1, '', 'A', 248);
INSERT INTO `option_info` VALUES (998, 'String', 0, '', 'B', 248);
INSERT INTO `option_info` VALUES (999, 'float', 1, '', 'C', 248);
INSERT INTO `option_info` VALUES (1000, 'long', 1, '', 'D', 248);
INSERT INTO `option_info` VALUES (1001, 'protected', 1, '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', 'A', 249);
INSERT INTO `option_info` VALUES (1002, 'final', 1, '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', 'B', 249);
INSERT INTO `option_info` VALUES (1003, 'public', 0, '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', 'C', 249);
INSERT INTO `option_info` VALUES (1004, 'private', 1, '解析：Illegal modifier for the interface InterfaceTest; only public & abstract are permitted', 'D', 249);
INSERT INTO `option_info` VALUES (1005, '必须定义前缀为abstract', 1, '', 'A', 250);
INSERT INTO `option_info` VALUES (1006, '所有方法必须定义为抽象', 0, '', 'B', 250);
INSERT INTO `option_info` VALUES (1007, '抽象类可以实例化', 0, '', 'C', 250);
INSERT INTO `option_info` VALUES (1008, '抽象类必须包含一个抽象方法', 0, '', 'D', 250);
INSERT INTO `option_info` VALUES (1009, '字节流关注流，不关注内容，字符流按行读取，关注文本', 0, 'A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。', 'A', 251);
INSERT INTO `option_info` VALUES (1010, '字节流的基类InputStream/OutputStream，字符流是Reader/Writer', 1, 'A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。', 'B', 251);
INSERT INTO `option_info` VALUES (1011, '字符流是对字节流的装饰，释放时反向逐一关闭', 0, 'A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。', 'C', 251);
INSERT INTO `option_info` VALUES (1012, '字符流最终都会按照字节流处理', 1, 'A：只要调用readLine()方法时才时行读取，人read方法时按字符读取，故错误\nB：基本常识\nC：没有这一说，字符流是单独的流，源码里可以看下，关闭流，两者没啥关系\nD：对的，因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查指定的码表。', 'D', 251);
INSERT INTO `option_info` VALUES (1013, '方法的返回值必须被正确解析或者使用', 0, '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', 'A', 252);
INSERT INTO `option_info` VALUES (1014, '方法可以没有返回值', 0, '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', 'B', 252);
INSERT INTO `option_info` VALUES (1015, '返回值可以没有被用到', 0, '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', 'C', 252);
INSERT INTO `option_info` VALUES (1016, '方法的返回值可被忽略', 1, '解析：\n《华为Java语言安全编程规范-V3.2.pdf》建议2.3 不要忽略方法的返回值', 'D', 252);
INSERT INTO `option_info` VALUES (1017, '类可以多重继承，接口可以多重继承', 0, '', 'A', 253);
INSERT INTO `option_info` VALUES (1018, '类可以多重继承，接口可以单重继承', 0, '', 'B', 253);
INSERT INTO `option_info` VALUES (1019, '类可以单重继承，接口可以多重继承', 1, '', 'C', 253);
INSERT INTO `option_info` VALUES (1020, '类可以单重继承，接口可以单重继承', 0, '', 'D', 253);
INSERT INTO `option_info` VALUES (1021, 'class Test implements ableA, ableB', 1, '', 'A', 254);
INSERT INTO `option_info` VALUES (1022, 'class Test implements ableA, implements ableB', 0, '', 'B', 254);
INSERT INTO `option_info` VALUES (1023, 'interface Test implements ableA, implements ableB', 0, '', 'C', 254);
INSERT INTO `option_info` VALUES (1024, 'interface Test implements ableA, ableB', 0, '', 'D', 254);
INSERT INTO `option_info` VALUES (1025, 'interface Test extends ableA, ableB', 1, '', 'E', 254);
INSERT INTO `option_info` VALUES (1026, 'Statement', 0, '', 'A', 255);
INSERT INTO `option_info` VALUES (1027, 'Connection', 1, '', 'B', 255);
INSERT INTO `option_info` VALUES (1028, 'DriverManager', 0, '', 'C', 255);
INSERT INTO `option_info` VALUES (1029, 'PreparedStatement', 0, '', 'D', 255);
INSERT INTO `option_info` VALUES (1030, 'Stream跟迭代器类似，再次遍历需要重新生成', 1, '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', 'A', 256);
INSERT INTO `option_info` VALUES (1031, 'Stream执行方式跟之前代码处理方式类似，中间操作立即执行', 0, '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', 'B', 256);
INSERT INTO `option_info` VALUES (1032, '对Stream修改体现到数据源上', 0, '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', 'C', 256);
INSERT INTO `option_info` VALUES (1033, 'Stream数据源只能是数组、容器或I/O', 0, '解析：\nStream的特点：\n1) 无存储，Stream不是一种数据结构，也不保存数据，数据源可以是数组、容器、I/O或Channel等；\n2) 为函数式编程而生，对Stream的任何修改都不会修改数据源；\n3) 惰性执行，Stream上的中间操作并不会立即执行，只有等到用户真正需要结果时才会执行；\n4) 一次消费，Stream只能被消费一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。', 'D', 256);
INSERT INTO `option_info` VALUES (1034, 'URLClassLoader的默认签名检查依赖jar包中的公钥，因此不能仅依赖该机制对jar包进行合法性检查', 1, '', 'A', 257);
INSERT INTO `option_info` VALUES (1035, '开发者不可以自定义类加载器', 0, '', 'B', 257);
INSERT INTO `option_info` VALUES (1036, '在JVM中，将不同ClassLoader实例加载的同一个类视为相同类', 0, '', 'C', 257);
INSERT INTO `option_info` VALUES (1037, '当自定义一个类加载器时，为了保证赋予权限的完整，应该直接覆写getPermissions()方法，无需调用基类的getPermission()方法', 0, '', 'D', 257);
INSERT INTO `option_info` VALUES (1038, 'char', 0, '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', 'A', 258);
INSERT INTO `option_info` VALUES (1039, 'String', 1, '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', 'B', 258);
INSERT INTO `option_info` VALUES (1040, 'short', 0, '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', 'C', 258);
INSERT INTO `option_info` VALUES (1041, 'Integer', 1, '解析：\n不可变类型有：\nBoolean, Byte, Character, Double, Float, Integer, Long, Short, String, BigDecimal', 'D', 258);
INSERT INTO `option_info` VALUES (1042, 'ExtensionClassLoader负责加载目录%JRE_HOME%/lib/ext目录下的jar包和类，或者java.ext.dirs系统变量所指定的路径下的jar包', 1, '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', 'A', 259);
INSERT INTO `option_info` VALUES (1043, 'AppClassLoader负责加载当前应用classpath下的所有jar包和类', 1, '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', 'B', 259);
INSERT INTO `option_info` VALUES (1044, 'BootstrapClassLoader负责加载%JAVA_HOME%/lib目录下的jar包和类或者被-Xbootclasspath参数指定的路径中的所有类', 1, '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', 'C', 259);
INSERT INTO `option_info` VALUES (1045, 'BootstrapClassLoader/ExtensionClassLoader/AppClassLoader都继承自java.lang.ClassLoader', 0, '解析：\nBootstrapClassLoader是用原生代码来实现的，并非继承自java.lang.ClassLoader', 'D', 259);
INSERT INTO `option_info` VALUES (1046, '1', 1, '', 'A', 260);
INSERT INTO `option_info` VALUES (1047, '2', 0, '', 'B', 260);
INSERT INTO `option_info` VALUES (1048, '3', 0, '', 'C', 260);
INSERT INTO `option_info` VALUES (1049, '4', 0, '', 'D', 260);
INSERT INTO `option_info` VALUES (1050, '5', 0, '', 'E', 260);
INSERT INTO `option_info` VALUES (1051, '6, 6', 0, '', 'A', 261);
INSERT INTO `option_info` VALUES (1052, '9, 6', 0, '', 'B', 261);
INSERT INTO `option_info` VALUES (1053, '3, 3', 0, '', 'C', 261);
INSERT INTO `option_info` VALUES (1054, '6, 3', 1, '', 'D', 261);
INSERT INTO `option_info` VALUES (1055, 'TreeMap可以有\'null\'的key和value', 1, '解析：\nTreeMap键可以为\'null\'，值不允许\nD:也很牵强，HashTable 不如ConcurentMap好呀', 'A', 262);
INSERT INTO `option_info` VALUES (1056, 'HashTable不允许有\'null\'的key和value', 0, '解析：\nTreeMap键可以为\'null\'，值不允许\nD:也很牵强，HashTable 不如ConcurentMap好呀', 'B', 262);
INSERT INTO `option_info` VALUES (1057, 'HashMap线程不安全，但效率高', 0, '解析：\nTreeMap键可以为\'null\'，值不允许\nD:也很牵强，HashTable 不如ConcurentMap好呀', 'C', 262);
INSERT INTO `option_info` VALUES (1058, 'HashTable是线程安全的，推荐使用', 0, '解析：\nTreeMap键可以为\'null\'，值不允许\nD:也很牵强，HashTable 不如ConcurentMap好呀', 'D', 262);
INSERT INTO `option_info` VALUES (1059, 'HashMap能够保证其中元素的顺序', 1, 'hashMap基本信息：\n1.初始大小：16\n2.每次扩容：\n3.可以存在一个key=null（todo 底层是存储对象吧？）\n4.value可以存储null\n5.线程不安全，无序\n6.todo hash计算原理（科目3貌似要考）', 'A', 263);
INSERT INTO `option_info` VALUES (1060, 'HashMap允许将\'null\'作为值', 0, '', 'B', 263);
INSERT INTO `option_info` VALUES (1061, 'HashMap允许将\'null\'用作键', 0, '', 'C', 263);
INSERT INTO `option_info` VALUES (1062, 'HashMap使用键值的形式保存数据', 0, '', 'D', 263);
INSERT INTO `option_info` VALUES (1063, '通道可以异步读写，流是同步读写', 1, '', 'A', 264);
INSERT INTO `option_info` VALUES (1064, '通道和流都可以支持Selector选择器多路复用', 0, '', 'B', 264);
INSERT INTO `option_info` VALUES (1065, '通道可以读也可以写，流一般来说是单向的', 1, '', 'C', 264);
INSERT INTO `option_info` VALUES (1066, '通道是面向缓冲区的，流是面向流的', 1, '', 'D', 264);
INSERT INTO `option_info` VALUES (1067, 'const', 0, '', 'A', 265);
INSERT INTO `option_info` VALUES (1068, 'synchronized', 1, '', 'B', 265);
INSERT INTO `option_info` VALUES (1069, 'protected', 0, '', 'C', 265);
INSERT INTO `option_info` VALUES (1070, 'volatile', 1, '', 'D', 265);
INSERT INTO `option_info` VALUES (1071, 'CountDownLatch.countDown()计数为0就会释放所有线程', 1, '', 'A', 266);
INSERT INTO `option_info` VALUES (1072, 'CountDownLatch计数为0后，无法重置', 0, '', 'B', 266);
INSERT INTO `option_info` VALUES (1073, 'CountDownLatch.countdown()为计数减控制', 1, '', 'C', 266);
INSERT INTO `option_info` VALUES (1074, 'CountDownLatch.await()只能触发阻塞等待，计数不会-1', 1, '', 'D', 266);
INSERT INTO `option_info` VALUES (1075, '使用PreparedStatement进行sql注入防护是优选方案', 1, '', 'A', 267);
INSERT INTO `option_info` VALUES (1076, '使用PreparedStatement多次执行同一条sql语句可以提升执行的效率', 1, '', 'B', 267);
INSERT INTO `option_info` VALUES (1077, '使用PreparedStatement可以有效解决所有的sql注入问题', 0, '', 'C', 267);
INSERT INTO `option_info` VALUES (1078, '正确使用PreparedStatement，可以有效防止sql注入的发生', 1, '', 'D', 267);
INSERT INTO `option_info` VALUES (1079, '\"select * from users where id=\" + request.getParameter(\"id\");', 1, '', 'A', 268);
INSERT INTO `option_info` VALUES (1080, '\"select * from users where username=\'\" + request.getParameter(\"username\") + \"\' and password=\'\" + request.getParameter(\"password\") + \"\' limit 1\";', 0, '', 'B', 268);
INSERT INTO `option_info` VALUES (1081, '\"select * from papers where title=\'\" + request.getParameter(\"title\") + \"\'\";', 0, '', 'C', 268);
INSERT INTO `option_info` VALUES (1082, '\"select * from papers where time=\'xxxxx\' order by \" + request.getParameter(\"columnName\");', 1, '', 'D', 268);
INSERT INTO `option_info` VALUES (1083, '~/test', 0, '', 'A', 269);
INSERT INTO `option_info` VALUES (1084, '/opt/oss/log', 1, '', 'B', 269);
INSERT INTO `option_info` VALUES (1085, '$ROOT/etc/conf', 0, '', 'C', 269);
INSERT INTO `option_info` VALUES (1086, '/opt/oss/../../etc', 0, '', 'D', 269);
INSERT INTO `option_info` VALUES (1087, '/(bab)(caca)/', 0, '', 'A', 270);
INSERT INTO `option_info` VALUES (1088, '/a(bab){2}(caac)*/', 0, '', 'B', 270);
INSERT INTO `option_info` VALUES (1089, '/a{2}/(*)', 1, '', 'C', 270);
INSERT INTO `option_info` VALUES (1090, '/a+(bab){0,1}(ca)+(ca)/', 0, '', 'D', 270);
INSERT INTO `option_info` VALUES (1091, '/a(^bab)+(caac){1,}/', 0, '', 'E', 270);
INSERT INTO `option_info` VALUES (1092, '/a+(babc){2,}(acc){1,}/', 0, '', 'F', 270);
INSERT INTO `option_info` VALUES (1093, '先签名再加密后传输', 1, '', 'A', 271);
INSERT INTO `option_info` VALUES (1094, '加密传输', 0, '', 'B', 271);
INSERT INTO `option_info` VALUES (1095, '先加密再签名后传输', 0, '', 'C', 271);
INSERT INTO `option_info` VALUES (1096, '签名传输', 0, '', 'D', 271);
INSERT INTO `option_info` VALUES (1097, '可以省去changePasword()方法中的同步块，直接将changePasword()方法声明为synchronized修饰的同步方法', 1, '', 'A', 272);
INSERT INTO `option_info` VALUES (1098, 'changePassport()方法中应该包含安全管理器检查，以确认调用代码是否具有该操作权限', 0, '', 'B', 272);
INSERT INTO `option_info` VALUES (1099, '将该lock成员变量的可见性声明为private', 0, '', 'C', 272);
INSERT INTO `option_info` VALUES (1100, 'changePassport()方法不应该抛出FileNotFoundException异常', 0, '', 'D', 272);
INSERT INTO `option_info` VALUES (1101, '提示用户输入', 0, '', 'A', 273);
INSERT INTO `option_info` VALUES (1102, '由环境变量获取:System.getenv(\"USER\")', 0, '', 'B', 273);
INSERT INTO `option_info` VALUES (1103, '由JVM属性获取:System.getProperty(\"user.name\")', 1, '', 'C', 273);
INSERT INTO `option_info` VALUES (1104, '启动程序的时候由程序参数传入', 0, '', 'D', 273);
INSERT INTO `option_info` VALUES (1105, 'Map<Integer, String> cityMap = new HashMap<>() {\n{\nput(1, \"Nanjing\");\nput(2, \"Beijing\");\nput(3, \"Shanghai\");\n}\n}', 0, '', 'A', 274);
INSERT INTO `option_info` VALUES (1106, 'for (Map.Entry<Integer, String> city : cityMap.entrySet()) {\nSystem.out.println(city.getValue());\n}', 0, '', 'B', 274);
INSERT INTO `option_info` VALUES (1107, 'Map<Integer, String> cityMap = new HashMap<>();\ncityMap.put(4, null);', 0, '', 'C', 274);
INSERT INTO `option_info` VALUES (1108, 'Map<Integer, String> unmodifiableMap = Collections.unmodifiableMap(cityMap);\nunmodifiableMap.clear();', 1, '', 'D', 274);
INSERT INTO `option_info` VALUES (1109, '程序员无法明确强制垃圾回收器运行', 1, '', 'A', 275);
INSERT INTO `option_info` VALUES (1110, '调用free()方法', 0, '', 'B', 275);
INSERT INTO `option_info` VALUES (1111, '赋值给该对象的引用为null', 0, '', 'C', 275);
INSERT INTO `option_info` VALUES (1112, '调用System.gc()方法', 0, '', 'D', 275);
INSERT INTO `option_info` VALUES (1113, 'public String getProductSummary(int index) {\nreturn products[index];\n}\n//该代码中index未校验，可能相起数组越界访问', 0, '', 'A', 276);
INSERT INTO `option_info` VALUES (1114, 'String userName = \"name\";\nResultSet rs = st.executeQuery(\"select * from user where name = \'\" + userName + \"\'\");\n//该代码可能会产生SQL注入漏洞', 1, '', 'B', 276);
INSERT INTO `option_info` VALUES (1115, 'Runtime.getRuntime().exec(\"cmd.exe /c dir \" + args[0]);\n//该代码可能会引起命令注入', 0, '', 'C', 276);
INSERT INTO `option_info` VALUES (1116, 'String command = System.getProPerty(\"command\");\nRuntime.getRuntime().exec(\"command\");\n//该代码可能会引起OS命令注入', 0, '', 'D', 276);
INSERT INTO `option_info` VALUES (1117, 'capacity：最大容量', 0, '', 'A', 277);
INSERT INTO `option_info` VALUES (1118, 'flag：读写状态位', 1, '', 'B', 277);
INSERT INTO `option_info` VALUES (1119, 'position：当前已经读到的字节数', 0, '', 'C', 277);
INSERT INTO `option_info` VALUES (1120, 'limit：剩下的字节数', 0, '', 'D', 277);
INSERT INTO `option_info` VALUES (1121, 'sleep不释放对象锁，wait放弃对象锁', 0, '', 'A', 278);
INSERT INTO `option_info` VALUES (1122, 'sleep暂停线程，但监控状态仍然保持，结束后会自动恢复', 0, '', 'B', 278);
INSERT INTO `option_info` VALUES (1123, 'wait后进入等待锁定池，只有针对此对象发出notify()方法后获得对象锁进入运行状态', 1, '', 'C', 278);
INSERT INTO `option_info` VALUES (1124, 'sleep是线程类（Thread）的方法，wait是Object类的方法', 0, '', 'D', 278);
INSERT INTO `option_info` VALUES (1125, '错误流', 1, '', 'A', 279);
INSERT INTO `option_info` VALUES (1126, '监控流', 0, '', 'B', 279);
INSERT INTO `option_info` VALUES (1127, '输出流', 1, '', 'C', 279);
INSERT INTO `option_info` VALUES (1128, '输入流', 1, '', 'D', 279);
INSERT INTO `option_info` VALUES (1129, 'TreeSet', 0, '', 'A', 280);
INSERT INTO `option_info` VALUES (1130, 'HashTable', 1, '', 'B', 280);
INSERT INTO `option_info` VALUES (1131, 'Vector', 1, '', 'C', 280);
INSERT INTO `option_info` VALUES (1132, 'LinkedList', 0, '', 'D', 280);
INSERT INTO `option_info` VALUES (1133, 'float f[][] = new float[6][6];', 0, '', 'A', 281);
INSERT INTO `option_info` VALUES (1134, 'float []f[] = new float[6][6];', 0, '', 'B', 281);
INSERT INTO `option_info` VALUES (1135, 'float f[][] = new float[][6];', 0, '', 'C', 281);
INSERT INTO `option_info` VALUES (1136, 'float[][] f = new float[6][6];', 1, '', 'D', 281);
INSERT INTO `option_info` VALUES (1137, 'float[][] f = new float[6][];', 1, '', 'E', 281);
INSERT INTO `option_info` VALUES (1138, 'int[] test = {1, 2, 3, 4, 5};', 0, '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', 'A', 282);
INSERT INTO `option_info` VALUES (1139, 'List list = new LinkedList<>();', 1, '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', 'B', 282);
INSERT INTO `option_info` VALUES (1140, 'Map<Integer, Integer> map = new HashMap<>();', 1, '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', 'C', 282);
INSERT INTO `option_info` VALUES (1141, 'List list = new ArrayList<>();', 1, '解析：\n数组是无法直接输出的，System.out.println(Arrays.toString(test))才能输出。', 'D', 282);
INSERT INTO `option_info` VALUES (1142, 'CountDownLatch', 1, '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', 'A', 283);
INSERT INTO `option_info` VALUES (1143, 'CyclicBarrier', 0, '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', 'B', 283);
INSERT INTO `option_info` VALUES (1144, 'Semaphore', 0, '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', 'C', 283);
INSERT INTO `option_info` VALUES (1145, 'BlockingQueue', 0, '解析：\nCountDownLatch这个类使一个线程等待其他线程各自执行完毕后再执行。', 'D', 283);
INSERT INTO `option_info` VALUES (1146, 'Semaphore信号量', 1, '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', 'A', 284);
INSERT INTO `option_info` VALUES (1147, 'CountDownLatch', 0, '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', 'B', 284);
INSERT INTO `option_info` VALUES (1148, 'CyclicBarrier', 0, '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', 'C', 284);
INSERT INTO `option_info` VALUES (1149, 'BlockingQueue', 0, '解析：\nSemaphore用来控制访问某资源的线程数，比如数据库连接', 'D', 284);
INSERT INTO `option_info` VALUES (1150, '当一个优先级高的线程进入就绪状态时', 0, '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', 'A', 285);
INSERT INTO `option_info` VALUES (1151, '当该线程调用sleep()方法时', 0, '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', 'B', 285);
INSERT INTO `option_info` VALUES (1152, '当创建一个新线程时', 0, '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', 'C', 285);
INSERT INTO `option_info` VALUES (1153, '抛出一个异常时', 1, '解析：\nA：并不会立即执行，等待时间片轮到的时候才会执行\nB：阻塞当前线程，直到阻塞时间达到，重新进入就绪队列\nC：同A选项一样，进入就绪队列，等待时间片轮到\nD对，抛出异常会终止当前线程的运行。', 'D', 285);
INSERT INTO `option_info` VALUES (1154, 'private final static int answer = 42;', 0, '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', 'A', 286);
INSERT INTO `option_info` VALUES (1155, 'public static int answer = 42;', 1, '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', 'B', 286);
INSERT INTO `option_info` VALUES (1156, 'final static answer = 42;', 0, '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', 'C', 286);
INSERT INTO `option_info` VALUES (1157, 'int answer;', 0, '解析：\nIllegal modifier for the interface field InterfaceTest.answer; only public, static & final are permitted\nThe blank final field answer may not have been initialized', 'D', 286);
INSERT INTO `option_info` VALUES (1158, 'StackOverflowError是堆栈内存溢出', 0, '解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足', 'A', 287);
INSERT INTO `option_info` VALUES (1159, 'OutOfMemoryError：Perm Gen是老年代内存溢出', 1, '解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足', 'B', 287);
INSERT INTO `option_info` VALUES (1160, 'Java Heap Space溢出时，会导致所有线程暂停工作', 0, '解析：\nOutOfMemoryError：Perm Gen永久保存区内存不足', 'C', 287);
INSERT INTO `option_info` VALUES (1161, '事件发生的时间、事件类型', 0, '', 'A', 288);
INSERT INTO `option_info` VALUES (1162, '密钥', 1, '', 'B', 288);
INSERT INTO `option_info` VALUES (1163, '明文口令', 1, '', 'C', 288);
INSERT INTO `option_info` VALUES (1164, '密文口令', 1, '', 'D', 288);
INSERT INTO `option_info` VALUES (1165, '类加载器之间是有层次结构的', 0, '', 'A', 289);
INSERT INTO `option_info` VALUES (1166, '加载不到类，会抛出ClassNotFoundException();', 0, '', 'B', 289);
INSERT INTO `option_info` VALUES (1167, '如果一个类加载器收到了类加载请求，先检查自己能不能加载，如果不能，向父加载器申请；', 1, '', 'C', 289);
INSERT INTO `option_info` VALUES (1168, '如果一个类加载器收到了类加载请求，先看父加载器能不能加载，一直如此到顶端加载器，顶端类加载器可以加载，则返回，如果不行本类加载器加载', 0, '', 'D', 289);
INSERT INTO `option_info` VALUES (1169, '后者能成功存储，且会覆盖前面的值', 0, 'hashMap底层是先判断hash是否相同，相同在判断equals方法\neg：\nclass Temp {\n    public static void main(String[] args) {\n        HashMap<Temp, Integer> map = new HashMap<>();\n        // 看hash相同，equals不同map的存储情况\n        Temp hash1 = new Temp(1, 2);\n        Temp hash2 = new Temp(1, 3);\n        map.put(hash1, 100);\n        map.put(hash2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash不同map的存储情况\n        Temp equals1 = new Temp(0, 1);\n        Temp equals2 = new Temp(1, 1);\n        map.put(equals1, 100);\n        map.put(equals2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash相同 map的存储情况\n        Temp hasAndEquals1 = new Temp(0, 0);\n        Temp hasAndEquals2 = new Temp(0, 0);\n        map.put(hasAndEquals1, 100);\n        map.put(hasAndEquals2, 200);\n        System.out.println(map);\n    }\n    private int code;\n    private int equals;\n    @Override\n    public String toString() {\n        return \"Temp{\" +\n            \"code=\" + code +\n            \", equals=\" + equals +\n            \'}\';\n    }\n    public Temp(int code, int equals) {\n        this.code = code;\n        this.equals = equals;\n    }\n    @Override\n    public int hashCode() {\n        System.out.println(\"调用了hash\");\n        return this.code;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"调用了equals\");\n        if (obj instanceof Temp) {\n            return ((Temp) obj).equals == this.equals;\n        }\n        return false;\n    }\n}', 'A', 290);
INSERT INTO `option_info` VALUES (1170, '其他选项都不行', 1, 'hashMap底层是先判断hash是否相同，相同在判断equals方法\neg：\nclass Temp {\n    public static void main(String[] args) {\n        HashMap<Temp, Integer> map = new HashMap<>();\n        // 看hash相同，equals不同map的存储情况\n        Temp hash1 = new Temp(1, 2);\n        Temp hash2 = new Temp(1, 3);\n        map.put(hash1, 100);\n        map.put(hash2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash不同map的存储情况\n        Temp equals1 = new Temp(0, 1);\n        Temp equals2 = new Temp(1, 1);\n        map.put(equals1, 100);\n        map.put(equals2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash相同 map的存储情况\n        Temp hasAndEquals1 = new Temp(0, 0);\n        Temp hasAndEquals2 = new Temp(0, 0);\n        map.put(hasAndEquals1, 100);\n        map.put(hasAndEquals2, 200);\n        System.out.println(map);\n    }\n    private int code;\n    private int equals;\n    @Override\n    public String toString() {\n        return \"Temp{\" +\n            \"code=\" + code +\n            \", equals=\" + equals +\n            \'}\';\n    }\n    public Temp(int code, int equals) {\n        this.code = code;\n        this.equals = equals;\n    }\n    @Override\n    public int hashCode() {\n        System.out.println(\"调用了hash\");\n        return this.code;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"调用了equals\");\n        if (obj instanceof Temp) {\n            return ((Temp) obj).equals == this.equals;\n        }\n        return false;\n    }\n}', 'B', 290);
INSERT INTO `option_info` VALUES (1171, '会抛出异常', 0, 'hashMap底层是先判断hash是否相同，相同在判断equals方法\neg：\nclass Temp {\n    public static void main(String[] args) {\n        HashMap<Temp, Integer> map = new HashMap<>();\n        // 看hash相同，equals不同map的存储情况\n        Temp hash1 = new Temp(1, 2);\n        Temp hash2 = new Temp(1, 3);\n        map.put(hash1, 100);\n        map.put(hash2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash不同map的存储情况\n        Temp equals1 = new Temp(0, 1);\n        Temp equals2 = new Temp(1, 1);\n        map.put(equals1, 100);\n        map.put(equals2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash相同 map的存储情况\n        Temp hasAndEquals1 = new Temp(0, 0);\n        Temp hasAndEquals2 = new Temp(0, 0);\n        map.put(hasAndEquals1, 100);\n        map.put(hasAndEquals2, 200);\n        System.out.println(map);\n    }\n    private int code;\n    private int equals;\n    @Override\n    public String toString() {\n        return \"Temp{\" +\n            \"code=\" + code +\n            \", equals=\" + equals +\n            \'}\';\n    }\n    public Temp(int code, int equals) {\n        this.code = code;\n        this.equals = equals;\n    }\n    @Override\n    public int hashCode() {\n        System.out.println(\"调用了hash\");\n        return this.code;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"调用了equals\");\n        if (obj instanceof Temp) {\n            return ((Temp) obj).equals == this.equals;\n        }\n        return false;\n    }\n}', 'C', 290);
INSERT INTO `option_info` VALUES (1172, '不能成功存储，但是也不抛异常', 0, 'hashMap底层是先判断hash是否相同，相同在判断equals方法\neg：\nclass Temp {\n    public static void main(String[] args) {\n        HashMap<Temp, Integer> map = new HashMap<>();\n        // 看hash相同，equals不同map的存储情况\n        Temp hash1 = new Temp(1, 2);\n        Temp hash2 = new Temp(1, 3);\n        map.put(hash1, 100);\n        map.put(hash2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash不同map的存储情况\n        Temp equals1 = new Temp(0, 1);\n        Temp equals2 = new Temp(1, 1);\n        map.put(equals1, 100);\n        map.put(equals2, 200);\n        System.out.println(map);\n        map.clear();\n        // 看equals相同，hash相同 map的存储情况\n        Temp hasAndEquals1 = new Temp(0, 0);\n        Temp hasAndEquals2 = new Temp(0, 0);\n        map.put(hasAndEquals1, 100);\n        map.put(hasAndEquals2, 200);\n        System.out.println(map);\n    }\n    private int code;\n    private int equals;\n    @Override\n    public String toString() {\n        return \"Temp{\" +\n            \"code=\" + code +\n            \", equals=\" + equals +\n            \'}\';\n    }\n    public Temp(int code, int equals) {\n        this.code = code;\n        this.equals = equals;\n    }\n    @Override\n    public int hashCode() {\n        System.out.println(\"调用了hash\");\n        return this.code;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        System.out.println(\"调用了equals\");\n        if (obj instanceof Temp) {\n            return ((Temp) obj).equals == this.equals;\n        }\n        return false;\n    }\n}', 'D', 290);
INSERT INTO `option_info` VALUES (1173, 'DatagramPacket', 1, 'http://3ms.huawei.com/km/groups/2032581/blogs/details/1829183', 'A', 291);
INSERT INTO `option_info` VALUES (1174, 'DatagramSocket', 0, 'http://3ms.huawei.com/km/groups/2032581/blogs/details/1829183', 'B', 291);
INSERT INTO `option_info` VALUES (1175, 'String', 0, 'http://3ms.huawei.com/km/groups/2032581/blogs/details/1829183', 'C', 291);
INSERT INTO `option_info` VALUES (1176, 'MulticastSocket', 0, 'http://3ms.huawei.com/km/groups/2032581/blogs/details/1829183', 'D', 291);
INSERT INTO `option_info` VALUES (1177, 'Statement stmt = null;\nResultSet rs = null;\ntry {\n    String userName = ctx.getAuthenticatedUserName(); // this is a constant\n    String sqlString = \"SELECT * FROM t_item WHERE owner=\'\" + userName + \"\' AND itemName=\'\"\n        + request.getParameter(\n        \"itemName\") + \"\'\";\n    stmt = connection.createStatement();\n    rs = stmt.executeQuery(sqlString);\n    // ... result set handling\n} catch (\n    SQLException se) {\n    // ... logging and error handling\n}', 0, 'A:拼接sql很明显sql注入\nB：使用的prepareStatement而且没有拼接安全\nC：有一说一，没看懂这段java程序，但是感觉也是拼接导致\nD：#{}表示占位符同?  而${}就算直接替换同拼接', 'A', 292);
INSERT INTO `option_info` VALUES (1178, 'PreparedStatement stmt = null;\nResultSet rs = null;\ntry {\n    String userName = ctx.getAuthenticatedUserName(); // this is a constant\n    String itemName = request.getParameter(\"itemName\");\n    // ...Ensure that the length of userName and itemName is legitimate\n    // ...\n    String sqlString = \"SELECT * FROM t_item WHERE owner=? AND itemName=?\";\n    stmt = connection.prepareStatement(sqlString);\n    stmt.setString(1, userName);\n    stmt.setString(2, itemName);\n    rs = stmt.executeQuery();\n    // ... result set handling\n} catch (\n    SQLException se) {\n    // ... logging and error handling\n}', 1, 'A:拼接sql很明显sql注入\nB：使用的prepareStatement而且没有拼接安全\nC：有一说一，没看懂这段java程序，但是感觉也是拼接导致\nD：#{}表示占位符同?  而${}就算直接替换同拼接', 'B', 292);
INSERT INTO `option_info` VALUES (1179, 'CREATE PROCEDURE\nsp_queryItem @userName varchar(50),\n    @itemName\n        varchar(50)\nAS\n    BEGIN\nDECLARE\n@sql nvarchar(500);\nSET\n@sql =\'SELECT * FROM t_item\nWHERE owner = \'\'\' + @userName + \'\'\'\nAND itemName = \'\'\' + @itemName + \'\'\'\';\nEXEC(@sql);\nEND\nGO\nCallableStatement = null;\nResultSet results = null;\ntry {\n    String userName = ctx.getAuthenticatedUserName(); // this is a constant\n    String itemName = request.getParameter(\"itemName\");\n    cs = connection.prepareCall(\"{call sp_queryItem(?,?)}\");\n    cs.setString(1, userName);\n    cs.setString(2, itemName);\n    results = cs.executeQuery();\n    // ... result set handling\n} catch (\n    SQLException se) {\n    // ... logging and error handling\n}', 0, 'A:拼接sql很明显sql注入\nB：使用的prepareStatement而且没有拼接安全\nC：有一说一，没看懂这段java程序，但是感觉也是拼接导致\nD：#{}表示占位符同?  而${}就算直接替换同拼接', 'C', 292);
INSERT INTO `option_info` VALUES (1180, '使用mybatis文件\n<select id = \"getItems\" parameterClass=\"MyClass\"resultClass=\"items\">\n    SELECT * FROM t_item WHERE owner = #{username} AND itemName = \'${itemName}\'\n</select>', 0, 'A:拼接sql很明显sql注入\nB：使用的prepareStatement而且没有拼接安全\nC：有一说一，没看懂这段java程序，但是感觉也是拼接导致\nD：#{}表示占位符同?  而${}就算直接替换同拼接', 'D', 292);
INSERT INTO `option_info` VALUES (1181, '同一次运行中，同一个对象如果equals方法中用到的信息没有改变，多次调用hashCode方法返回值必须相同；', 1, 'B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等', 'A', 293);
INSERT INTO `option_info` VALUES (1182, '如果两个对象调用equals方法时相等，则这两个对象的hashCode方法返回也相同；两个对象的hashCode方法返回值相等，则两个对象的equals也相等', 0, 'B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等', 'B', 293);
INSERT INTO `option_info` VALUES (1183, '如果两个对象调用equals方法时不相等，则这两个对象的hashCode方法，可以相同，也可以返回不同的值', 1, 'B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等', 'C', 293);
INSERT INTO `option_info` VALUES (1184, '覆写equals的时候，应同时覆写hashCode方法', 1, 'B：两个对象的hashCode方法返回值相等，两个对象的equals不一定相等', 'D', 293);
INSERT INTO `option_info` VALUES (1185, 'private', 1, '（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817', 'A', 294);
INSERT INTO `option_info` VALUES (1186, 'final', 1, '（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817', 'B', 294);
INSERT INTO `option_info` VALUES (1187, 'static', 1, '（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817', 'C', 294);
INSERT INTO `option_info` VALUES (1188, 'public', 0, '（1）Java中的覆写(override)、重载(overload)、隐藏(hide)、遮蔽(shadow)和遮掩(obscure)\n\n  http://3ms.huawei.com/km/blogs/details/8912349\n\n（2）重写、覆写与重载的区别 http://3ms.huawei.com/km/blogs/details/8742817', 'D', 294);
INSERT INTO `option_info` VALUES (1189, 'assert names.isEmpty();', 0, '这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;', 'A', 295);
INSERT INTO `option_info` VALUES (1190, 'assert names.remove(null);', 1, '这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;', 'B', 295);
INSERT INTO `option_info` VALUES (1191, 'assert names.add(null);', 1, '这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;', 'C', 295);
INSERT INTO `option_info` VALUES (1192, 'Boolean nullsRemoved = names.remove(null);\n   Assert nullsRemoved', 0, '这个断言的副作用是因为它修改了程序中变量的值并且未抛出错误，这样的错误如果不细心的检查是很难发现的。但是同时我们可以根据以上的副作用得到一个有用的特性，根据它来测试断言是否打开。\n一句话：断言不要修改值？\n// A.\nassert names.isEmpty();\n// B.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.remove(null);\n//\n// C.IDEA 提示 \'assert\' has side effects: call to \'add()\' mutates \'names\'\nassert names.add(null);\n// D.\nboolean nullsRemoved = names.remove(null);\nassert nullsRemoved;', 'D', 295);
INSERT INTO `option_info` VALUES (1193, '成长期', 1, '', 'A', 297);
INSERT INTO `option_info` VALUES (1194, '成熟期', 0, '', 'B', 297);
INSERT INTO `option_info` VALUES (1195, '衰退期', 0, '', 'C', 297);
INSERT INTO `option_info` VALUES (1196, '导入期', 0, '', 'D', 297);
INSERT INTO `option_info` VALUES (1197, '通过向系统注入在实际应用中可能发生的故障，观察系统功能性性能变化，故障检测、定位、隔离以及故障恢复清空，发现产品缺陷、评估系统可靠性的测试方法', 1, '', 'A', 298);
INSERT INTO `option_info` VALUES (1198, '通过设置逐级递增的加严的环境应力，来加速暴露试验样品的缺陷和薄弱点的一种测试方法', 0, '', 'B', 298);
INSERT INTO `option_info` VALUES (1199, '通过注入故障，对业务质量指标及系统可靠性指标进行测试，多维度进行可靠性评价，反应处系统的综合可靠性水平', 0, '', 'C', 298);
INSERT INTO `option_info` VALUES (1200, '通过采用温度循环加振动的应力来筛选生产阶段产品，剔除产品中有早期缺陷产品的测试方法', 0, '', 'D', 298);
INSERT INTO `option_info` VALUES (1201, '注重人而不是过程，开发团队的技能应当被成分认识和利用', 0, '', 'A', 299);
INSERT INTO `option_info` VALUES (1202, '要拥抱变化，期待系统需求变化，对系统进行设计以更好地融入这些变化', 0, '', 'B', 299);
INSERT INTO `option_info` VALUES (1203, '所有过程活动均事先计划，按照计划衡量进度', 1, '', 'C', 299);
INSERT INTO `option_info` VALUES (1204, '注重客户协作，客户应当在整个开发过程中紧密参与', 0, '', 'D', 299);
INSERT INTO `option_info` VALUES (1205, '第三方软件版本EOSS时间是华为根据华为软件版本的TR5时间来定义的', 1, '', 'A', 300);
INSERT INTO `option_info` VALUES (1206, '产品在第三方软件首次引入时，当第三方软件的生命周期无法匹配产品生命周期要求时，产品需提前规划第三方软件的升级替代策略', 0, '', 'B', 300);
INSERT INTO `option_info` VALUES (1207, '第三方软件生命周期关键管控点包含：EOSS、EOES', 0, '', 'C', 300);
INSERT INTO `option_info` VALUES (1208, '产品软件版本TR5/RR前需完成所有下层软件组件的配套关系验证，其中，第三方软件版EOSS时间不早于产品软件版本EOS时间', 0, '', 'D', 300);
INSERT INTO `option_info` VALUES (1209, '瀑布模型', 1, '', 'A', 301);
INSERT INTO `option_info` VALUES (1210, '极限编程', 0, '', 'B', 301);
INSERT INTO `option_info` VALUES (1211, 'Scrum', 0, '', 'C', 301);
INSERT INTO `option_info` VALUES (1212, '持续集成', 0, '', 'D', 301);
INSERT INTO `option_info` VALUES (1213, '系统配置类数据和动态业务的备份应有所区分，保证不同类数据的备份优先级顺序', 0, '', 'A', 302);
INSERT INTO `option_info` VALUES (1214, '采用数据平滑消除备份数据中的错误，不是软件可靠性设计的关键技术，不用投入精力进行设计', 1, '', 'B', 302);
INSERT INTO `option_info` VALUES (1215, '心跳检测定时器超时时长在资源允许的情况下 要尽可能短，以缩短故障检测时间，提高倒换速度', 0, '', 'C', 302);
INSERT INTO `option_info` VALUES (1216, '心跳检测的握手需要提供多条通道，以保证通道的可靠性', 0, '', 'D', 302);
INSERT INTO `option_info` VALUES (1217, '开发阶段，配置开源片段引用门禁扫描，将MR中的增量代码使用fossbot检测，若引用了开源代码，可以提醒用户，进行拦截', 0, '', 'A', 303);
INSERT INTO `option_info` VALUES (1218, '产品在系统设计阶段需要在架构层面上实现开源与自研解耦', 0, '', 'B', 303);
INSERT INTO `option_info` VALUES (1219, '开源软件使用声明包括：软件名称、软件版本、权利人声明、员工工号、许可证（license）', 1, '', 'C', 303);
INSERT INTO `option_info` VALUES (1220, '产品若对apache 2.0许可的开源软件进行了修改，建议在修改的源码文件头附上修改声明，说明修改人、修改时间、修改内容', 0, '', 'D', 303);
INSERT INTO `option_info` VALUES (1221, '因小红尚未离职，通过小明的回忆已经找到真实的修改人，所以没有违背配置管理原则，不存在网络安全风险', 1, '', 'A', 304);
INSERT INTO `option_info` VALUES (1222, '小红利用小明的账号进行代码合入存在代码修改无法追溯到真实的修改人的风险', 0, '', 'B', 304);
INSERT INTO `option_info` VALUES (1223, '存在植入恶意代码的风险，完整性保护无法得到保障', 0, '', 'C', 304);
INSERT INTO `option_info` VALUES (1224, '违背了网络安全红线关于禁止借用他人账号访问配置库的要求', 0, '', 'D', 304);
INSERT INTO `option_info` VALUES (1225, '分析客户需求的重要性', 0, '', 'A', 305);
INSERT INTO `option_info` VALUES (1226, '安全编码的重要性', 0, '', 'B', 305);
INSERT INTO `option_info` VALUES (1227, '应急响应的重要性', 0, '', 'C', 305);
INSERT INTO `option_info` VALUES (1228, '在研发过程中有效测试第三方组件安全性的重要性', 1, '', 'D', 305);
INSERT INTO `option_info` VALUES (1229, '安全架构设计', 0, '', 'A', 306);
INSERT INTO `option_info` VALUES (1230, 'PIA（隐私影响分析）', 0, '', 'B', 306);
INSERT INTO `option_info` VALUES (1231, 'STRIDE SD威胁建模', 1, '', 'C', 306);
INSERT INTO `option_info` VALUES (1232, 'ASTRIDE Low Level威胁建模', 0, '', 'D', 306);
INSERT INTO `option_info` VALUES (1233, '系统构建', 1, '', 'A', 307);
INSERT INTO `option_info` VALUES (1234, '变更管理', 0, '', 'B', 307);
INSERT INTO `option_info` VALUES (1235, '版本管理', 0, '', 'C', 307);
INSERT INTO `option_info` VALUES (1236, '发布管理', 0, '', 'D', 307);
INSERT INTO `option_info` VALUES (1237, '自研二进制仓无权限控制', 0, '', 'A', 308);
INSERT INTO `option_info` VALUES (1238, '归档在自研二进制仓的软件包在版本发布后可以变更', 0, '', 'B', 308);
INSERT INTO `option_info` VALUES (1239, '自研二进制仓取消了VMP采用的Windows share共享方式，不容易存留漏洞后门，确保了二进制完整性保护能力', 1, '', 'C', 308);
INSERT INTO `option_info` VALUES (1240, '自研二进制仓不是公司级的版本存储空间', 0, '', 'D', 308);
INSERT INTO `option_info` VALUES (1241, '客户澄清需求，可以使用原型开发', 0, '', 'A', 309);
INSERT INTO `option_info` VALUES (1242, '原型开发必须时间短、费用低', 0, '', 'B', 309);
INSERT INTO `option_info` VALUES (1243, '所有的原型都是抛弃式', 1, '', 'C', 309);
INSERT INTO `option_info` VALUES (1244, '搞清楚一个功能或方案是否可行，可以使用原型开发', 0, '', 'D', 309);
INSERT INTO `option_info` VALUES (1245, '对于片段引用进行整改，可自研重写，或采取申请整包使用、部分编译的方法，或其他软件替代方案', 1, '', 'A', 310);
INSERT INTO `option_info` VALUES (1246, '可通过修改函数名或变量名的方式规避fossbot扫描出片段代码', 0, '', 'B', 310);
INSERT INTO `option_info` VALUES (1247, '对产品全量代码进行分析，确保所有使用的开源软件是整包使用，对片段引用情况可借助fossbot扫描工具辅助分析', 1, '', 'C', 310);
INSERT INTO `option_info` VALUES (1248, 'fossbot扫描自研代码未匹配相似的开源代码，则说明自研代码中无片段引用', 0, '', 'D', 310);
INSERT INTO `option_info` VALUES (1249, '将开源软件部分函数拷贝到产品自研代码中使用', 0, '', 'E', 310);
INSERT INTO `option_info` VALUES (1250, '栈', 0, '', 'A', 311);
INSERT INTO `option_info` VALUES (1251, '二叉树', 1, '', 'B', 311);
INSERT INTO `option_info` VALUES (1252, '线性表', 0, '', 'C', 311);
INSERT INTO `option_info` VALUES (1253, '队列', 0, '', 'D', 311);
INSERT INTO `option_info` VALUES (1254, '二维数组', 1, '', 'E', 311);
INSERT INTO `option_info` VALUES (1255, '密钥用途单一化，即一个密钥应只用于一种用途', 1, '', 'A', 312);
INSERT INTO `option_info` VALUES (1256, '工作密钥在本地存储时需提供机密性保护', 1, '', 'B', 312);
INSERT INTO `option_info` VALUES (1257, '口令、默认设置的可见字符等，均不能直接作为密钥使用', 1, '', 'C', 312);
INSERT INTO `option_info` VALUES (1258, '不再使用的密钥，应当立即删除', 1, '', 'D', 312);
INSERT INTO `option_info` VALUES (1259, '为方便密钥的管理，应将密钥硬编码在代码中', 0, '', 'E', 312);
INSERT INTO `option_info` VALUES (1260, '基线与变更管理策略', 1, '', 'A', 313);
INSERT INTO `option_info` VALUES (1261, '版本管理策略', 1, '', 'B', 313);
INSERT INTO `option_info` VALUES (1262, '配置库策略', 1, '', 'C', 313);
INSERT INTO `option_info` VALUES (1263, '分支策略', 0, '', 'D', 313);
INSERT INTO `option_info` VALUES (1264, '配置项识别策略', 1, '', 'E', 313);
INSERT INTO `option_info` VALUES (1265, '产品在使用平台发布的文件前，应进行数字签名校验，确保产品使用的文件与平台发布的文件是一致的', 0, '', 'A', 315);
INSERT INTO `option_info` VALUES (1266, '平台版本不需要实施数字签名', 1, '', 'B', 315);
INSERT INTO `option_info` VALUES (1267, '平台版本通过正式的发布渠道发布', 0, '', 'C', 315);
INSERT INTO `option_info` VALUES (1268, '平台软件包在发布时，对软件包实施数字签名', 0, '', 'D', 315);
INSERT INTO `option_info` VALUES (1269, '该开发人员需要解决冲突，本例中开发人员可以通过和冲突文件的修改人共同确认函数类型以及返回结果，确保冲突解除', 0, '', 'A', 316);
INSERT INTO `option_info` VALUES (1270, '提交成功，提示的是需要更新配置库上的最新版本后再进行提交', 1, '', 'B', 316);
INSERT INTO `option_info` VALUES (1271, '该开发人员的修改再提交时与另一提交的修改内容产生了冲突', 0, '', 'C', 316);
INSERT INTO `option_info` VALUES (1272, '撤销本次修改，也是改开发解决本地冲突的方式之一', 0, '', 'D', 316);
INSERT INTO `option_info` VALUES (1273, '为了进行高效共享，老张应该在本地磁盘修改后，将架构设计文档的最新版本及时共享给项目组成员，而不需要提交到统一的配置库', 0, '', 'A', 317);
INSERT INTO `option_info` VALUES (1274, '老张应该将架构设计文档提交评审流程，评审通过后进行基线', 1, '', 'B', 317);
INSERT INTO `option_info` VALUES (1275, '架构设计文档是关键的配置项，老张应该对架构设计文档进行配置项识别，按照配置项管理要求归档在统一的配置库中', 1, '', 'C', 317);
INSERT INTO `option_info` VALUES (1276, '老张要按照配置项命名规范对架构设计文档进行规范化命名，而不能随意命名为相似的名称', 1, '', 'D', 317);
INSERT INTO `option_info` VALUES (1277, '版本管理', 0, '', 'A', 318);
INSERT INTO `option_info` VALUES (1278, '分支管理', 0, '', 'B', 318);
INSERT INTO `option_info` VALUES (1279, '配置状态发布', 1, '', 'C', 318);
INSERT INTO `option_info` VALUES (1280, '管理配置库', 0, '', 'D', 318);
INSERT INTO `option_info` VALUES (1281, 'Bepkit工具是为了提升二进制一致性差异消除的效率而开发的辅助工具', 0, '', 'A', 319);
INSERT INTO `option_info` VALUES (1282, 'BEP的目标是基于相同源码，相同环境，实现同一版本可重复构建，且构建结果完全一致', 0, '', 'B', 319);
INSERT INTO `option_info` VALUES (1283, '直接比较产品源代码编译构建的最终结果 (产品软件版本)，一般无法解析所产生的差异，需要从源代码，编译过程，直到最终发布得二进制包逐层分析产生二进制一致性差异的因', 0, '', 'C', 319);
INSERT INTO `option_info` VALUES (1284, '差异识别即基于相同环境，相同源代码编译两次，使用编译结果通过beyond compare进行比较，不完全一致即存在差异，由于时间戳引起的二进制一致性差异可以忽略', 1, '', 'D', 319);
INSERT INTO `option_info` VALUES (1285, '永久故障', 1, '解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】', 'A', 320);
INSERT INTO `option_info` VALUES (1286, '瞬时故障', 1, '解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】', 'B', 320);
INSERT INTO `option_info` VALUES (1287, '间歇故障', 1, '解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】', 'C', 320);
INSERT INTO `option_info` VALUES (1288, '突发性故障', 0, '解析：按故障的持续时问可将故障分为永久故障、瞬时故障和间歇故障；按故障的发生和发展过程可将故障分为突发性故障和渐发性故障；按故障发生的原因可将故障分为外因故障和内因故障。按故障的部件可将故障分为硬件故障和软件故障；按故障的严重程度可将故障分为破坏性故障和非破坏性故障】', 'D', 320);
INSERT INTO `option_info` VALUES (1289, '单板重启', 0, '', 'A', 321);
INSERT INTO `option_info` VALUES (1290, '软件复位', 0, '', 'B', 321);
INSERT INTO `option_info` VALUES (1291, '时间检查 (如：心跳检测)', 1, '', 'C', 321);
INSERT INTO `option_info` VALUES (1292, '隔离仓设计', 0, '', 'D', 321);
INSERT INTO `option_info` VALUES (1293, '降低攻击成功可能性', 1, '', 'A', 322);
INSERT INTO `option_info` VALUES (1294, '不利情况发生后恢复业务', 1, '', 'B', 322);
INSERT INTO `option_info` VALUES (1295, '限制不利情况发生时的损害', 1, '', 'C', 322);
INSERT INTO `option_info` VALUES (1296, '不利情况下维持核心业务', 1, '', 'D', 322);
INSERT INTO `option_info` VALUES (1297, '软件编码与构建', 1, '', 'A', 323);
INSERT INTO `option_info` VALUES (1298, '需求分析与设计', 1, '', 'B', 323);
INSERT INTO `option_info` VALUES (1299, '现网部署', 0, '', 'C', 323);
INSERT INTO `option_info` VALUES (1300, '验证发布', 1, '', 'D', 323);
INSERT INTO `option_info` VALUES (1301, '隐私保护', 1, '', 'A', 324);
INSERT INTO `option_info` VALUES (1302, '网络安全', 1, '', 'B', 324);
INSERT INTO `option_info` VALUES (1303, '最优惠的价格', 0, '', 'C', 324);
INSERT INTO `option_info` VALUES (1304, '设备平稳运行', 0, '', 'D', 324);
INSERT INTO `option_info` VALUES (1305, '只要注册时已对收集的数据获取了用户同意，后续可以直接新增收集和处理其他类型的个人数据', 0, '', 'A', 325);
INSERT INTO `option_info` VALUES (1306, '如果将用户个人数据转移给第三方，公司应获得用户同意或满足其他合法性基础', 1, '', 'B', 325);
INSERT INTO `option_info` VALUES (1307, '公司可以将用户个人数据转移给合作的第三方 (供应商，商业合作伙伴)，不需要告知客户', 0, '', 'C', 325);
INSERT INTO `option_info` VALUES (1308, '在经用户同意收集个人数据之后，用户无权干涉公司对这些个人数据的使用比如要求公司删除其个人数据', 0, '', 'D', 325);
INSERT INTO `option_info` VALUES (1309, '作为数据处理者的法国供应商，基于成本考虑将数据转移到德国处理', 1, '', 'A', 326);
INSERT INTO `option_info` VALUES (1310, '在中国的维护终端上，远程查看和分析德国服务器上的个人数据', 0, '', 'B', 326);
INSERT INTO `option_info` VALUES (1311, '德国子公司的个人数据传输到俄罗斯处理', 0, '', 'C', 326);
INSERT INTO `option_info` VALUES (1312, '德国子公司个人数据传输到美国处理', 0, '', 'D', 326);
INSERT INTO `option_info` VALUES (1313, '冗余系统中，主备用模块的故障都需要检测，避免静默故障', 0, '', 'A', 327);
INSERT INTO `option_info` VALUES (1314, '对于不引起系统故障只导致系统或服务KPI下降的亚健康异常不需要检测', 1, '', 'B', 327);
INSERT INTO `option_info` VALUES (1315, '故障定时检测的周期，需综合考虑对CPU占用率的影响和检测延迟对业务恢复速度的影响', 0, '', 'C', 327);
INSERT INTO `option_info` VALUES (1316, '应及时监控有特殊寿命 (如Flash有擦写次数限制等)要求的器件健康状态，通过提前预警采取维护措施', 0, '', 'D', 327);
INSERT INTO `option_info` VALUES (1317, '软件最为普通的缺陷就是来自客户端或者外部环境的数据没有进行正确的合法性校验，这种缺陷可以导致几乎所有的程序弱点', 0, '', 'A', 328);
INSERT INTO `option_info` VALUES (1318, '直接使用任意用户输入来构造格式化字符串会带来安全风险', 0, '', 'B', 328);
INSERT INTO `option_info` VALUES (1319, '当程序需要用户上传文件时，只需要校验用户上传的文件后缀名即可有效防止可执行文件上传漏洞', 1, '', 'C', 328);
INSERT INTO `option_info` VALUES (1320, '输入校验中如果没有特殊要求应该首先考虑采用“白名单”校验形式', 0, '', 'D', 328);
INSERT INTO `option_info` VALUES (1321, '最小限度', 0, '解析：收集数据原则： 合法、正当、透明 + 目的限制 + 数据最小化 + 准确性 + 存储期限最小化 + 完整性与保密性 + 可归责】', 'A', 329);
INSERT INTO `option_info` VALUES (1322, '机密性', 1, '解析：收集数据原则： 合法、正当、透明 + 目的限制 + 数据最小化 + 准确性 + 存储期限最小化 + 完整性与保密性 + 可归责】', 'B', 329);
INSERT INTO `option_info` VALUES (1323, '必要性', 0, '解析：收集数据原则： 合法、正当、透明 + 目的限制 + 数据最小化 + 准确性 + 存储期限最小化 + 完整性与保密性 + 可归责】', 'C', 329);
INSERT INTO `option_info` VALUES (1324, '目的相关性', 0, '解析：收集数据原则： 合法、正当、透明 + 目的限制 + 数据最小化 + 准确性 + 存储期限最小化 + 完整性与保密性 + 可归责】', 'D', 329);
INSERT INTO `option_info` VALUES (1325, '需要从系统架构层面来关注整个系统级别的安全防御机制', 1, '', 'A', 330);
INSERT INTO `option_info` VALUES (1326, '不能只依赖单一安全机制', 1, '', 'B', 330);
INSERT INTO `option_info` VALUES (1327, '采用多点，多重的安全校验机制', 1, '', 'C', 330);
INSERT INTO `option_info` VALUES (1328, '纵深防御就是对外部数据使用前必须校验', 0, '', 'D', 330);
INSERT INTO `option_info` VALUES (1329, '“Nov 1,2016,21:04:16”字符串', 1, '', 'A', 331);
INSERT INTO `option_info` VALUES (1330, '构建时刻距离1970/01/01秒数', 1, '', 'B', 331);
INSERT INTO `option_info` VALUES (1331, '“2017030418056”字符串', 1, '', 'C', 331);
INSERT INTO `option_info` VALUES (1332, '其他自定义格式：1990+月-日-天-小时-分-秒的偏移量', 1, '', 'D', 331);
INSERT INTO `option_info` VALUES (1333, '某云服务应该对涉及的个人数据处理场景进行隐私风险评估，针对风险制定消减措施并闭环', 1, '', 'A', 332);
INSERT INTO `option_info` VALUES (1334, '某网站在设计时，在重定向到第三方网页前，告知用户将会发生跳转', 1, '', 'B', 332);
INSERT INTO `option_info` VALUES (1335, '某云服务收集了个人数据入IMEI，IMSI，没有在隐私声明中列出', 0, '', 'C', 332);
INSERT INTO `option_info` VALUES (1336, '某云服务收集个人数据前，明确提示用户，并获得用户的同意', 1, '', 'D', 332);
INSERT INTO `option_info` VALUES (1337, '可以进入系统的隐藏快捷键', 1, '', 'A', 333);
INSERT INTO `option_info` VALUES (1338, '隐藏命令或参数', 1, '', 'B', 333);
INSERT INTO `option_info` VALUES (1339, '可绕过系统认证的访问接口', 1, '', 'C', 333);
INSERT INTO `option_info` VALUES (1340, '隐藏账号', 1, '', 'D', 333);
INSERT INTO `option_info` VALUES (1341, '认证绕过', 1, '解析：常见安全编码问题包括：缓冲区溢出、跨站脚本攻击、SQL注入和其他等等】', 'A', 334);
INSERT INTO `option_info` VALUES (1342, '缓冲区溢出', 0, '解析：常见安全编码问题包括：缓冲区溢出、跨站脚本攻击、SQL注入和其他等等】', 'B', 334);
INSERT INTO `option_info` VALUES (1343, '命令注入', 0, '解析：常见安全编码问题包括：缓冲区溢出、跨站脚本攻击、SQL注入和其他等等】', 'C', 334);
INSERT INTO `option_info` VALUES (1344, '整数溢出', 0, '解析：常见安全编码问题包括：缓冲区溢出、跨站脚本攻击、SQL注入和其他等等】', 'D', 334);
INSERT INTO `option_info` VALUES (1345, '资产的购买价值', 0, '', 'A', 335);
INSERT INTO `option_info` VALUES (1346, '已有的风险消减措施', 0, '', 'B', 335);
INSERT INTO `option_info` VALUES (1347, '社会工程', 0, '', 'C', 335);
INSERT INTO `option_info` VALUES (1348, '安全风险发生可能性和业务影响性', 1, '', 'D', 335);
INSERT INTO `option_info` VALUES (1349, '身份管理和访问控制，数据安全，信息保护流程和步骤，安全运维', 1, '解析：CSF：http://3ms.huawei.com/km/blogs/details/6437325】', 'A', 336);
INSERT INTO `option_info` VALUES (1350, '身份管理和访问控制，数据安全，信息保护流程和步骤，安全连续监控', 0, '解析：CSF：http://3ms.huawei.com/km/blogs/details/6437325】', 'B', 336);
INSERT INTO `option_info` VALUES (1351, '身份管理和访问控制，数据安全，安全运维，风险评估', 0, '解析：CSF：http://3ms.huawei.com/km/blogs/details/6437325】', 'C', 336);
INSERT INTO `option_info` VALUES (1352, '身份管理和访问控制，数据安全，安全运维，安全连续监控', 0, '解析：CSF：http://3ms.huawei.com/km/blogs/details/6437325】', 'D', 336);
INSERT INTO `option_info` VALUES (1353, '数据处理者', 0, '解析：只开发软件卖给客户，则买软件的客户是数据处理者，A公司什么也不是，只是个开发工具的人，不接触数据】', 'A', 337);
INSERT INTO `option_info` VALUES (1354, '既不是数据控制者也不是数据处理者', 1, '解析：只开发软件卖给客户，则买软件的客户是数据处理者，A公司什么也不是，只是个开发工具的人，不接触数据】', 'B', 337);
INSERT INTO `option_info` VALUES (1355, '数据主体', 0, '解析：只开发软件卖给客户，则买软件的客户是数据处理者，A公司什么也不是，只是个开发工具的人，不接触数据】', 'C', 337);
INSERT INTO `option_info` VALUES (1356, '数据控制者', 0, '解析：只开发软件卖给客户，则买软件的客户是数据处理者，A公司什么也不是，只是个开发工具的人，不接触数据】', 'D', 337);
INSERT INTO `option_info` VALUES (1357, '决定个人数据处理的目的及方式', 1, '解析：区分数据控制者与数据处理者的关键原则】', 'A', 338);
INSERT INTO `option_info` VALUES (1358, '管理数据分配时间', 0, '解析：区分数据控制者与数据处理者的关键原则】', 'B', 338);
INSERT INTO `option_info` VALUES (1359, '管理访问数据权限', 0, '解析：区分数据控制者与数据处理者的关键原则】', 'C', 338);
INSERT INTO `option_info` VALUES (1360, '决定数据存储方式', 0, '解析：区分数据控制者与数据处理者的关键原则】', 'D', 338);
INSERT INTO `option_info` VALUES (1361, '通过负荷分担保护业务', 0, '', 'A', 339);
INSERT INTO `option_info` VALUES (1362, '自动复位单板', 0, '', 'B', 339);
INSERT INTO `option_info` VALUES (1363, '现场更换单板', 1, '', 'C', 339);
INSERT INTO `option_info` VALUES (1364, '主备单板倒换', 0, '', 'D', 339);
INSERT INTO `option_info` VALUES (1365, 'FMEA分析表', 0, '', 'A', 340);
INSERT INTO `option_info` VALUES (1366, '软件故障管理需求', 0, '', 'B', 340);
INSERT INTO `option_info` VALUES (1367, '硬件故障管理需求', 0, '', 'C', 340);
INSERT INTO `option_info` VALUES (1368, '软件功能需求', 1, '', 'D', 340);
INSERT INTO `option_info` VALUES (1369, '拒绝所有业务', 0, '', 'A', 341);
INSERT INTO `option_info` VALUES (1370, '接入所有业务', 0, '', 'B', 341);
INSERT INTO `option_info` VALUES (1371, '服务降级', 1, '', 'C', 341);
INSERT INTO `option_info` VALUES (1372, '复位系统', 0, '', 'D', 341);
INSERT INTO `option_info` VALUES (1373, '减轻', 1, '', 'A', 342);
INSERT INTO `option_info` VALUES (1374, '接受', 0, '', 'B', 342);
INSERT INTO `option_info` VALUES (1375, '规避', 0, '', 'C', 342);
INSERT INTO `option_info` VALUES (1376, '转移', 0, '', 'D', 342);
INSERT INTO `option_info` VALUES (1377, '偶然失效期', 1, '', 'A', 343);
INSERT INTO `option_info` VALUES (1378, '早期失效期', 1, '', 'B', 343);
INSERT INTO `option_info` VALUES (1379, '生产失效期', 0, '', 'C', 343);
INSERT INTO `option_info` VALUES (1380, '损耗失效期', 1, '', 'D', 343);
INSERT INTO `option_info` VALUES (1381, '市场失效期', 0, '', 'E', 343);
INSERT INTO `option_info` VALUES (1382, '进程间通信 (包括管道，消息，共享内存，socket，RPC等)', 1, '', 'A', 344);
INSERT INTO `option_info` VALUES (1383, '函数参数 (对于API)，全局变量 (在本函数内，其他线程会修改全局变量)', 1, '', 'B', 344);
INSERT INTO `option_info` VALUES (1384, '用户输入 (包括命令行，界面)，用户动态数据 (对于内核程序)', 1, '', 'C', 344);
INSERT INTO `option_info` VALUES (1385, '文件 (包括程序的配置文件)，注册表，网络，环境变量', 1, '', 'D', 344);
INSERT INTO `option_info` VALUES (1386, '不可关联性', 0, '', 'A', 345);
INSERT INTO `option_info` VALUES (1387, '可干预性', 1, '', 'B', 345);
INSERT INTO `option_info` VALUES (1388, '透明性', 0, '', 'C', 345);
INSERT INTO `option_info` VALUES (1389, '机密性', 0, '', 'D', 345);
INSERT INTO `option_info` VALUES (1390, '非持久性是在有限时间内保留信息，服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会', 0, '', 'A', 346);
INSERT INTO `option_info` VALUES (1391, '分割可以根据系统的重要级别进行划分，以限制成功攻击的传播和损害', 0, '', 'B', 346);
INSERT INTO `option_info` VALUES (1392, '权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配用户和网络实体的权限，以最大限度地减少对手活动潜在的后果', 0, '', 'C', 346);
INSERT INTO `option_info` VALUES (1393, '多样性使用异构技术 (例如，硬件，软件，固件，协议)，这样增加了网络建设的成本，运维的难度，是不可取的', 0, '', 'D', 346);
INSERT INTO `option_info` VALUES (1394, '重试设计', 1, '', 'A', 347);
INSERT INTO `option_info` VALUES (1395, '故障域划分设计', 0, '', 'B', 347);
INSERT INTO `option_info` VALUES (1396, '隔离舱设计', 0, '', 'C', 347);
INSERT INTO `option_info` VALUES (1397, '断路器隔离设计', 0, '', 'D', 347);
INSERT INTO `option_info` VALUES (1398, '若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程 (需开源)，通过隔离层进行交互', 1, '', 'A', 348);
INSERT INTO `option_info` VALUES (1399, '在内核态中对Linux kernel进行调用，以避免GPL串扰', 1, '', 'B', 348);
INSERT INTO `option_info` VALUES (1400, '以动态链接的方式使用GPL软件，使产品代码不会被GPL传染', 0, '', 'C', 348);
INSERT INTO `option_info` VALUES (1401, '可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互', 0, '', 'D', 348);
INSERT INTO `option_info` VALUES (1402, '原则上，为区分自研与开源代码，确保使用和修改可追溯，开源修改的patch文件需要独立存放管理', 0, '解析：\n【规则】整包使用开源软件，版本名称与官网保持一致\n【规则】涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理\n【规则】开源修改的patch独立存放可管理\n【规则】禁止片段引用开源软件代码', 'A', 349);
INSERT INTO `option_info` VALUES (1403, '要求产品无代码片段引用，可借助FOSSID扫描工具辅助分析代码片段使用情况并进行整改', 0, '解析：\n【规则】整包使用开源软件，版本名称与官网保持一致\n【规则】涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理\n【规则】开源修改的patch独立存放可管理\n【规则】禁止片段引用开源软件代码', 'B', 349);
INSERT INTO `option_info` VALUES (1404, '整包使用开源软件，版本名称可以根据产品版本定制命名', 1, '解析：\n【规则】整包使用开源软件，版本名称与官网保持一致\n【规则】涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理\n【规则】开源修改的patch独立存放可管理\n【规则】禁止片段引用开源软件代码', 'C', 349);
INSERT INTO `option_info` VALUES (1405, '开源及第三方软件与自研代码独立存放，目录隔离，从产品代码目录结构区分出open_source目录，vendor目录，code自研目录', 0, '解析：\n【规则】整包使用开源软件，版本名称与官网保持一致\n【规则】涉及源代码交付，对开源原生代码进行修改的代码，使用Patch方式管理\n【规则】开源修改的patch独立存放可管理\n【规则】禁止片段引用开源软件代码', 'D', 349);
INSERT INTO `option_info` VALUES (1406, '供应商发布的软件正式版本，可以引入', 0, '解析：供应商发布的软件正式版本，需要评估才能引入】', 'A', 350);
INSERT INTO `option_info` VALUES (1407, '已EOSS/即将停止销售的第三方软件不建议引入', 1, '解析：供应商发布的软件正式版本，需要评估才能引入】', 'B', 350);
INSERT INTO `option_info` VALUES (1408, '未签署供应商网络安全协议的软件禁止引入', 1, '解析：供应商发布的软件正式版本，需要评估才能引入】', 'C', 350);
INSERT INTO `option_info` VALUES (1409, '业务无替代的第三方软件，可能存在供应风险，不建议引入', 1, '解析：供应商发布的软件正式版本，需要评估才能引入】', 'D', 350);
INSERT INTO `option_info` VALUES (1410, '判断原则是基于相似度，如果相似度很低，如低于5%可以判断为自研', 0, '', 'A', 351);
INSERT INTO `option_info` VALUES (1411, '判断原则是基于事实，编码前没阅读过开源代码写出的代码可以判定为自研，其他形式直接参考开源写的代码都属于开源', 1, '', 'B', 351);
INSERT INTO `option_info` VALUES (1412, '判断原则是基于工具，如果FOSSID无法扫描出来，则都是自研代码', 0, '', 'C', 351);
INSERT INTO `option_info` VALUES (1413, '判断原则是基于目录结构，自研目录下的都是自研代码，open_source目录下都是开源软件', 0, '', 'D', 351);
INSERT INTO `option_info` VALUES (1414, '修改的OpenSSL软件源码如果得到做着的认可，产品可以不用回馈社区直接引入选型OpenSSL', 0, '', 'A', 352);
INSERT INTO `option_info` VALUES (1415, 'openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入', 1, '', 'B', 352);
INSERT INTO `option_info` VALUES (1416, '从官网下载OpenSSL源码太麻烦，可以直接使用git命令下载github上而的openssl源码', 0, '', 'C', 352);
INSERT INTO `option_info` VALUES (1417, '可以从任意网址下载OpenSSL源码包，只要不扫描出病毒', 0, '', 'D', 352);
INSERT INTO `option_info` VALUES (1418, '代码库中的开源原始包需和开源社区原始包一致', 0, '解析：使用Patch方式管理—>正确】', 'A', 353);
INSERT INTO `option_info` VALUES (1419, '经评审不得随意修改开开开元源生代码，但基于开源定制的代码规模无限制', 1, '解析：使用Patch方式管理—>正确】', 'B', 353);
INSERT INTO `option_info` VALUES (1420, '涉及源代码交付，对开源源生代码进行修改的代码，使用Patch方式管理', 0, '解析：使用Patch方式管理—>正确】', 'C', 353);
INSERT INTO `option_info` VALUES (1421, '禁止片段引用开源软件', 0, '解析：使用Patch方式管理—>正确】', 'D', 353);
INSERT INTO `option_info` VALUES (1422, '法务层面来看，产品无法正确且完整地履行开源软件义务，导致引起法务诉讼', 1, '', 'A', 354);
INSERT INTO `option_info` VALUES (1423, '网络安全层面来看，产品无法完整地回合社区对应补丁或漏洞无法追溯', 1, '', 'B', 354);
INSERT INTO `option_info` VALUES (1424, '产品拷贝的来源可能是不可靠的', 1, '', 'C', 354);
INSERT INTO `option_info` VALUES (1425, '维护工作量来看，开源片段会大量地分布在产品的各个模块或特性中，网络安全的攻击面会增大，漏洞修复的投入成本也增大，且容易遗漏', 1, '', 'D', 354);
INSERT INTO `option_info` VALUES (1426, 'LGPL软件本身必须开源，且具有传染性，与其动态链接部分的代码也必须以LGPL许可开源；静态链接则不被传染', 0, '', 'A', 355);
INSERT INTO `option_info` VALUES (1427, 'BSD类license，如Apache/BSD/MIT等，原则上没有对外开源要求', 1, '', 'B', 355);
INSERT INTO `option_info` VALUES (1428, 'GPL软件本身必须开源，且具有传染性，与该软件在同一进程中运行的代码都必须对外开源', 1, '', 'C', 355);
INSERT INTO `option_info` VALUES (1429, 'MPL类软件若无修改，则无需对外开源', 1, '', 'D', 355);
INSERT INTO `option_info` VALUES (1430, '原则上，为区分自研与开源代码，确保使用和修改可追溯，开源修改的patch文件需要独立存放管理', 0, '', 'A', 356);
INSERT INTO `option_info` VALUES (1431, '华为修改开源软件的patch代码量，必须严格控制，修改代码建议不超过5%', 0, '', 'B', 356);
INSERT INTO `option_info` VALUES (1432, '基于开源软件修改的自研Patch中可以包含开源权利人声明', 0, '', 'C', 356);
INSERT INTO `option_info` VALUES (1433, '开源软件社区发布的补丁要和自研修改的补丁做成一个patch进行统一管理', 1, '', 'D', 356);
INSERT INTO `option_info` VALUES (1434, '通过修改变量名，宏名，使得FOSSID扫描不出来', 1, '', 'A', 357);
INSERT INTO `option_info` VALUES (1435, '通过修改函数名，使得FOSSID扫描不出来', 1, '', 'B', 357);
INSERT INTO `option_info` VALUES (1436, '不参考源代码，通过代码重构重新实现业务代码', 0, '', 'C', 357);
INSERT INTO `option_info` VALUES (1437, '通过删除注释，将宏替换为魔鬼数字等方式规避FOSSID扫描', 1, '', 'D', 357);
INSERT INTO `option_info` VALUES (1438, 'LGPL允许静态链接使用，但要履行对应代码开源义务', 1, '', 'A', 358);
INSERT INTO `option_info` VALUES (1439, '产品不链接GPL软件，而是将所需功能函数拷贝嵌入产品代码，则无需履行代码开源义务', 0, '', 'B', 358);
INSERT INTO `option_info` VALUES (1440, '若是独立进程使用GPL软件，则无需履行代码开源义务', 0, '', 'C', 358);
INSERT INTO `option_info` VALUES (1441, '若该产品使用了GPL软件，根据GPL license规定，该产品不得静态链接使用GPL软件', 0, '', 'D', 358);
INSERT INTO `option_info` VALUES (1442, '产品P引入XX开源软件，工程师小A分析&应用后认为将XX软件的其中几个接口再重新封装形成新接口，可以更好支撑业务，于是小A在XX软件代码文件中新增一个功能接口，并且归档到开源软件目录支撑产品编译发布', 0, '', 'A', 359);
INSERT INTO `option_info` VALUES (1443, '产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，将开源软件归档到开源代码目录，并通过部分编译的形式，仅编译需要的特性进行打包发布', 1, '', 'B', 359);
INSERT INTO `option_info` VALUES (1444, '产品P引入XX开源软件，工程师小A分析&应用后认为需要对开源代码进行少量修改才能满足产品需求，通过团队架构评审等确认后，将修改代码以Patch的 方式进行管理', 1, '', 'C', 359);
INSERT INTO `option_info` VALUES (1445, '产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，于是将其他特性代码删除后，归档到开源目录支撑产品编译发布', 0, '', 'D', 359);
INSERT INTO `option_info` VALUES (1446, '一种新的角色，同时具备开发和运维技能', 0, '', 'A', 360);
INSERT INTO `option_info` VALUES (1447, '一个专门的团队，同时具备开发和运维能力', 1, '', 'B', 360);
INSERT INTO `option_info` VALUES (1448, '是指开发和运维一起参与到整个软件生命周期的过程中，事件从开发、测试、部署上线到维护', 1, '', 'C', 360);
INSERT INTO `option_info` VALUES (1449, '和传统运维区别不大，只是使用了一些新的工具去实现自动化', 1, '', 'D', 360);
INSERT INTO `option_info` VALUES (1450, '极限编程', 0, '', 'A', 361);
INSERT INTO `option_info` VALUES (1451, '瀑布模型', 1, '', 'B', 361);
INSERT INTO `option_info` VALUES (1452, '持续集成', 0, '', 'C', 361);
INSERT INTO `option_info` VALUES (1453, 'Scrum', 0, '', 'D', 361);
INSERT INTO `option_info` VALUES (1454, '软件复用一定要复用代码，否则意义不大', 0, '', 'A', 362);
INSERT INTO `option_info` VALUES (1455, '软件复用一定能降低研发成本和风险，所以要尽可能地考虑复用', 0, '', 'B', 362);
INSERT INTO `option_info` VALUES (1456, '可复用的构件标准有利于复用', 1, '', 'C', 362);
INSERT INTO `option_info` VALUES (1457, '规划复用的时候要考虑很多因素，包括开发进度，所期望的软件生命周期，开发团队的经验等，所以是否复用经常是一个管理问题而非技术问题', 1, '', 'D', 362);
INSERT INTO `option_info` VALUES (1458, '需求跟踪说明书', 0, '', 'A', 363);
INSERT INTO `option_info` VALUES (1459, '需求变更管理文档', 0, '', 'B', 363);
INSERT INTO `option_info` VALUES (1460, '需求分析计划', 0, '', 'C', 363);
INSERT INTO `option_info` VALUES (1461, '需求基线', 1, '', 'D', 363);
INSERT INTO `option_info` VALUES (1462, '需求发现', 0, '', 'A', 364);
INSERT INTO `option_info` VALUES (1463, '需求变更', 1, '', 'B', 364);
INSERT INTO `option_info` VALUES (1464, '需求排序', 0, '', 'C', 364);
INSERT INTO `option_info` VALUES (1465, '需求评估', 0, '', 'D', 364);
INSERT INTO `option_info` VALUES (1466, '需求分析中对不明确的功能需求要进行细致调查后进行具体化', 1, '', 'A', 365);
INSERT INTO `option_info` VALUES (1467, '需求分析是对项目目标和场景涉及的问题都要考虑', 1, '', 'B', 365);
INSERT INTO `option_info` VALUES (1468, '需求分析过程中需要将需求转换为形式化的功能规约，如需求规格说明书', 1, '', 'C', 365);
INSERT INTO `option_info` VALUES (1469, '在敏捷流程中，需求分析后可以不用输出形式化的功能规约', 0, '', 'D', 365);
INSERT INTO `option_info` VALUES (1470, '对特殊的场景不做分析', 1, '', 'A', 366);
INSERT INTO `option_info` VALUES (1471, '特性的可交付性和服务代码要求的不一致', 1, '', 'B', 366);
INSERT INTO `option_info` VALUES (1472, '对性能的描述：整体系统的响应时间不小于2s', 1, '', 'C', 366);
INSERT INTO `option_info` VALUES (1473, '需求的来源对开发阶段的影响，通过IR/SR/AR进行了关联', 0, '', 'D', 366);
INSERT INTO `option_info` VALUES (1474, '用户可以根据图书名搜索到该图书', 1, '解析：产品需求：CE、组织需求：F】', 'A', 367);
INSERT INTO `option_info` VALUES (1475, '系统可以查询用户当前已经借到的图书', 1, '解析：产品需求：CE、组织需求：F】', 'B', 367);
INSERT INTO `option_info` VALUES (1476, '系统应该24H可用，宕机时间不超过5s', 0, '解析：产品需求：CE、组织需求：F】', 'C', 367);
INSERT INTO `option_info` VALUES (1477, '用户输入书名后。2s内查询到该书的信息', 1, '解析：产品需求：CE、组织需求：F】', 'D', 367);
INSERT INTO `option_info` VALUES (1478, '管理员再培训1H后可以使用该系统的管理功能', 0, '解析：产品需求：CE、组织需求：F】', 'E', 367);
INSERT INTO `option_info` VALUES (1479, '应将每个学生的学生编号作为该学生的唯一标识', 0, '解析：产品需求：CE、组织需求：F】', 'F', 367);
INSERT INTO `option_info` VALUES (1480, '更新风险清单并分析风险影响', 1, '', 'A', 368);
INSERT INTO `option_info` VALUES (1481, '更新项目管理计划', 0, '', 'B', 368);
INSERT INTO `option_info` VALUES (1482, '不采取任何措施', 0, '', 'C', 368);
INSERT INTO `option_info` VALUES (1483, '更新风险管理计划', 0, '', 'D', 368);
INSERT INTO `option_info` VALUES (1484, '客户对于软件产品的需求持续下降', 1, '解析：软件危机详解：http://3ms.huawei.com/hi/group/2025905/wiki_4400291.html】', 'A', 369);
INSERT INTO `option_info` VALUES (1485, '软件产品质量无法保证', 0, '解析：软件危机详解：http://3ms.huawei.com/hi/group/2025905/wiki_4400291.html】', 'B', 369);
INSERT INTO `option_info` VALUES (1486, '软件开发进度难以预测', 0, '解析：软件危机详解：http://3ms.huawei.com/hi/group/2025905/wiki_4400291.html】', 'C', 369);
INSERT INTO `option_info` VALUES (1487, '软件开发成本难以预测', 0, '解析：软件危机详解：http://3ms.huawei.com/hi/group/2025905/wiki_4400291.html】', 'D', 369);
INSERT INTO `option_info` VALUES (1488, '严酷度为 III 类的故障', 0, '', 'A', 370);
INSERT INTO `option_info` VALUES (1489, '严酷度为 I 类的故障', 0, '', 'B', 370);
INSERT INTO `option_info` VALUES (1490, '严酷度为 II 类的故障', 0, '', 'C', 370);
INSERT INTO `option_info` VALUES (1491, '严酷度为I类和 II 类的故障', 1, '', 'D', 370);
INSERT INTO `option_info` VALUES (1492, '采用规避策略降低风险出现的概率', 0, '解析：风险规避 + 转移 + 减轻；但是风险不能忽略】', 'A', 371);
INSERT INTO `option_info` VALUES (1493, '采用忽略策略应对具体风险概率', 1, '解析：风险规避 + 转移 + 减轻；但是风险不能忽略】', 'B', 371);
INSERT INTO `option_info` VALUES (1494, '采用应急计划处置风险转变为具体问题的事件', 1, '解析：风险规避 + 转移 + 减轻；但是风险不能忽略】', 'C', 371);
INSERT INTO `option_info` VALUES (1495, '采用最小化策略降低风险的影响', 1, '解析：风险规避 + 转移 + 减轻；但是风险不能忽略】', 'D', 371);
INSERT INTO `option_info` VALUES (1496, '保护开发团队免受外部干扰', 1, '解析：定义产品需求不属于Scrum Master的职责】', 'A', 372);
INSERT INTO `option_info` VALUES (1497, '引导团队正确应用敏捷实践', 1, '解析：定义产品需求不属于Scrum Master的职责】', 'B', 372);
INSERT INTO `option_info` VALUES (1498, '定义产品需求', 0, '解析：定义产品需求不属于Scrum Master的职责】', 'C', 372);
INSERT INTO `option_info` VALUES (1499, '促进团队紧密协作', 1, '解析：定义产品需求不属于Scrum Master的职责】', 'D', 372);
INSERT INTO `option_info` VALUES (1500, '用户培训是帮助用户理解产品并掌握系统的使用和操作', 0, '', 'A', 373);
INSERT INTO `option_info` VALUES (1501, '软件交付的主要工作是将程序代码和相关文档交给用户', 1, '', 'B', 373);
INSERT INTO `option_info` VALUES (1502, '持续集成是频繁持续地将团队成员的工作进行集成', 0, '', 'C', 373);
INSERT INTO `option_info` VALUES (1503, '软件部署是通过配置，安装和激活等活动保证软件系统的正常运行', 0, '', 'D', 373);
INSERT INTO `option_info` VALUES (1504, '提供的软件产品速度比同类产品快10%', 0, '', 'A', 374);
INSERT INTO `option_info` VALUES (1505, '公司的服务必须满足所有租车服务行业监管条例', 0, '', 'B', 374);
INSERT INTO `option_info` VALUES (1506, '提供叫车与车辆信息服务来满足司机车辆服务与乘客出行的要求', 1, '', 'C', 374);
INSERT INTO `option_info` VALUES (1507, '让客户将品牌与低价格联系在一起', 0, '', 'D', 374);
INSERT INTO `option_info` VALUES (1508, '软件工程的目的是支持专业化的软件开发，而不仅仅是个人数据', 0, '', 'A', 375);
INSERT INTO `option_info` VALUES (1509, '软件工程发展的目的就是希望找到合适的方法和即使适用于软件系统', 0, '', 'B', 375);
INSERT INTO `option_info` VALUES (1510, '软件工程仅指实现软件生产开发的活动序列', 1, '', 'C', 375);
INSERT INTO `option_info` VALUES (1511, '软件工程是一门研究用工程化方法构建和维护有效的，实用的和高质量的软件的学科，它涉及程序设计语言，数据库，软件开发工具，系统平台，标准，设计模式等方面', 0, '', 'D', 375);
INSERT INTO `option_info` VALUES (1512, '系统应该在2018年9月1日之前上线部署运行', 0, '', 'A', 376);
INSERT INTO `option_info` VALUES (1513, '系统可按照院系统计学生选课情况，指定统计范围后1s内返回统计结果', 0, '', 'B', 376);
INSERT INTO `option_info` VALUES (1514, '用户规模不超过5000人时，登陆密码验证时间不超过2秒，用户规模不超过2万人时，登陆密码验证不超过5秒', 1, '', 'C', 376);
INSERT INTO `option_info` VALUES (1515, '课程属性与学生专业属性不符时不允许选课', 0, '', 'D', 376);
INSERT INTO `option_info` VALUES (1516, '–Xmn50M', 1, '解析：-Xmn、-Xms、-Xmx、-Xss都是JVM对内存的配置参数：】\n-Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小\n-Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn\n-Xss设置每个线程可使用的内存大小', 'A', 377);
INSERT INTO `option_info` VALUES (1517, '–Xms50M', 0, '解析：-Xmn、-Xms、-Xmx、-Xss都是JVM对内存的配置参数：】\n-Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小\n-Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn\n-Xss设置每个线程可使用的内存大小', 'B', 377);
INSERT INTO `option_info` VALUES (1518, '–Xmx50M', 0, '解析：-Xmn、-Xms、-Xmx、-Xss都是JVM对内存的配置参数：】\n-Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小\n-Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn\n-Xss设置每个线程可使用的内存大小', 'C', 377);
INSERT INTO `option_info` VALUES (1519, '–Xss50M', 0, '解析：-Xmn、-Xms、-Xmx、-Xss都是JVM对内存的配置参数：】\n-Xms、-Xmx分配用来设置进程堆内存的最小大小和最大大小\n-Xmn用来设置堆内新生代的大小，老生代的大小= -Xmx减去-Xmn\n-Xss设置每个线程可使用的内存大小', 'D', 377);
INSERT INTO `option_info` VALUES (1520, 'jmap [options]', 1, '', 'A', 378);
INSERT INTO `option_info` VALUES (1521, 'jhat [options]', 0, '', 'B', 378);
INSERT INTO `option_info` VALUES (1522, 'jstack [options]', 0, '', 'C', 378);
INSERT INTO `option_info` VALUES (1523, 'jstat [options]', 0, '', 'D', 378);
INSERT INTO `option_info` VALUES (1524, '多个进程竞争资源出现了循环等待', 1, '', 'A', 379);
INSERT INTO `option_info` VALUES (1525, '一个进程进入死循环', 0, '', 'B', 379);
INSERT INTO `option_info` VALUES (1526, '进程资源释放', 0, '', 'C', 379);
INSERT INTO `option_info` VALUES (1527, '多个进程竞争使用共享的设备', 0, '', 'D', 379);
INSERT INTO `option_info` VALUES (1528, '使用jmap可以查看堆中对象的统计信息，包括类名，对象数量和内存大小', 0, '', 'A', 380);
INSERT INTO `option_info` VALUES (1529, '使用jmap可以把java堆中的对象dump到本地文件', 0, '', 'B', 380);
INSERT INTO `option_info` VALUES (1530, '使用jmap可以定位线程死锁的问题', 1, '', 'C', 380);
INSERT INTO `option_info` VALUES (1531, '使用jmap可以打印java堆的配置情况和使用情况，还有使用的GC算法', 0, '', 'D', 380);
INSERT INTO `option_info` VALUES (1532, '互斥', 0, '', 'A', 381);
INSERT INTO `option_info` VALUES (1533, '占有并请求', 1, '', 'B', 381);
INSERT INTO `option_info` VALUES (1534, '循环等待', 0, '', 'C', 381);
INSERT INTO `option_info` VALUES (1535, '非剥夺', 0, '', 'D', 381);
INSERT INTO `option_info` VALUES (1536, 'jps', 0, '', 'A', 382);
INSERT INTO `option_info` VALUES (1537, 'javah', 0, '', 'B', 382);
INSERT INTO `option_info` VALUES (1538, 'jmap', 1, '', 'C', 382);
INSERT INTO `option_info` VALUES (1539, 'jstack', 0, '', 'D', 382);
INSERT INTO `option_info` VALUES (1540, 'suspend指明是否支持断点', 0, '解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】', 'A', 383);
INSERT INTO `option_info` VALUES (1541, '使用-Xrunjdwp后，将以调试模式启动java进程', 1, '解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】', 'B', 383);
INSERT INTO `option_info` VALUES (1542, 'transport类型可以是dt_socket和dt_shmem，其中dt_shmem只适用于window平台', 1, '解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】', 'C', 383);
INSERT INTO `option_info` VALUES (1543, 'onthrow指明是否在发生指定异常时中断执行，进行调试', 1, '解析：-Xrunjdwp：通知JVM使用(java debug wire protocol)来运行调试环境】\n【-Xrunjdwp：指定了调试数据的传送方式，dt_socket是指用SOCKET模式，另有dt_shmem指用共享内存方式，其中，dt_shmem只适用于Windows平台】\n【suspend：指明是否在调试客户端建立起来后，再执行JVM】\n【onthrow：指明当产生该类型的Exception时，JVM就会中断下来进行调式该参数可选】\n【launch：指明当JVM被中断下来时，执行的可执行程序该参数可选】\n【server：指是否支持在server模式的VM中】', 'D', 383);
INSERT INTO `option_info` VALUES (1544, 'Thread.join()', 1, '解析：start()方法不会引起切换】', 'A', 384);
INSERT INTO `option_info` VALUES (1545, 'Object.wait()', 1, '解析：start()方法不会引起切换】', 'B', 384);
INSERT INTO `option_info` VALUES (1546, 'Thread.yeild()', 1, '解析：start()方法不会引起切换】', 'C', 384);
INSERT INTO `option_info` VALUES (1547, 'Thread.start()', 0, '解析：start()方法不会引起切换】', 'D', 384);
INSERT INTO `option_info` VALUES (1548, 'Thread.sleep()', 1, '解析：start()方法不会引起切换】', 'E', 384);
INSERT INTO `option_info` VALUES (1549, '可以查看某个JVM参数', 0, '解析：可以查看/修改JVM参数，java系统参数】', 'A', 385);
INSERT INTO `option_info` VALUES (1550, '可以查看java系统参数', 0, '解析：可以查看/修改JVM参数，java系统参数】', 'B', 385);
INSERT INTO `option_info` VALUES (1551, '可以调整JVM参数', 0, '解析：可以查看/修改JVM参数，java系统参数】', 'C', 385);
INSERT INTO `option_info` VALUES (1552, '可以查看java程序的内存使用情况', 1, '解析：可以查看/修改JVM参数，java系统参数】', 'D', 385);
INSERT INTO `option_info` VALUES (1553, 'jmap –histo 17212', 1, '解析：jmap：查看内存占用情况】', 'A', 386);
INSERT INTO `option_info` VALUES (1554, 'top –Hp 1721', 0, '解析：jmap：查看内存占用情况】', 'B', 386);
INSERT INTO `option_info` VALUES (1555, 'jstat –gcutil 17212', 0, '解析：jmap：查看内存占用情况】', 'C', 386);
INSERT INTO `option_info` VALUES (1556, 'jstack 17212', 0, '解析：jmap：查看内存占用情况】', 'D', 386);
INSERT INTO `option_info` VALUES (1557, '相比server模式，JVM client模式可以获得更好的性能', 1, '', 'A', 387);
INSERT INTO `option_info` VALUES (1558, '通过-Xms和-Xmx可以设置Java堆的大小', 0, '', 'B', 387);
INSERT INTO `option_info` VALUES (1559, '通过-XX:ThreadStackSize可以设置线程堆栈的大小', 0, '', 'C', 387);
INSERT INTO `option_info` VALUES (1560, '通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize可以设置元数据区(Metaspace)的大小\nserver模式性能更好，cleint模式更适合GUI界面的交互应用', 0, '', 'D', 387);
INSERT INTO `option_info` VALUES (1561, '参数混乱导致测试失效时难以定位实际错误', 0, '', 'A', 388);
INSERT INTO `option_info` VALUES (1562, '测试用例执行永不失败', 0, '', 'B', 388);
INSERT INTO `option_info` VALUES (1563, '信息分散导致测试意图不清晰', 0, '', 'C', 388);
INSERT INTO `option_info` VALUES (1564, '单个测试用例体现了多个功能点测试', 1, '', 'D', 388);
INSERT INTO `option_info` VALUES (1565, '静态测试是由开发人员执行的，而动态测试是由专门的测试人员完成的', 0, '', 'A', 389);
INSERT INTO `option_info` VALUES (1566, '静态测试需要借助于专门的测试工具，而动态测试不需要', 0, '', 'B', 389);
INSERT INTO `option_info` VALUES (1567, '静态测试并没有真正运行软件，而动态测试需要真正运行软件', 1, '', 'C', 389);
INSERT INTO `option_info` VALUES (1568, '静态测试主要是为了增加测试人员对软件的理解，而动态测试是为了发现缺陷', 0, '', 'D', 389);
INSERT INTO `option_info` VALUES (1569, '尽可能多的', 1, '', 'A', 390);
INSERT INTO `option_info` VALUES (1570, '尽可能少的', 0, '', 'B', 390);
INSERT INTO `option_info` VALUES (1571, '一半的', 0, '', 'C', 390);
INSERT INTO `option_info` VALUES (1572, '1个', 0, '', 'D', 390);
INSERT INTO `option_info` VALUES (1573, '测试用例发现过多的系统缺陷，说明测试用例设计的质量较差', 0, '', 'A', 391);
INSERT INTO `option_info` VALUES (1574, '测试用例越多越好，意味着测试越完善', 0, '', 'B', 391);
INSERT INTO `option_info` VALUES (1575, '测试数据属于测试用例的组成部分', 1, '', 'C', 391);
INSERT INTO `option_info` VALUES (1576, '单个测试用例覆盖的测试点越多越好', 0, '', 'D', 391);
INSERT INTO `option_info` VALUES (1577, '因为执行频率高，因此回归测试需要尽可能的自动化，甚至纳入持续集成', 0, '', 'A', 392);
INSERT INTO `option_info` VALUES (1578, '开发者具有熟悉系统的优势，因此应该尽量让开发者完成整个IPD测试过程', 1, '', 'B', 392);
INSERT INTO `option_info` VALUES (1579, '测试应当从基本的软件组件开始，然后主键想向外直到整个软件系统都完成了集成', 0, '', 'C', 392);
INSERT INTO `option_info` VALUES (1580, '从理论上讲，测试永远不可能完备', 0, '', 'D', 392);
INSERT INTO `option_info` VALUES (1581, '集成测试', 0, '', 'A', 393);
INSERT INTO `option_info` VALUES (1582, '系统测试', 0, '', 'B', 393);
INSERT INTO `option_info` VALUES (1583, '回归测试', 0, '', 'C', 393);
INSERT INTO `option_info` VALUES (1584, '单元测试', 1, '', 'D', 393);
INSERT INTO `option_info` VALUES (1585, '1,2,5,3,4', 0, '解析：注意栈后进先出的特点即可，每个选项带入栈推导下)', 'A', 394);
INSERT INTO `option_info` VALUES (1586, '3,1,2,5,4', 0, '解析：注意栈后进先出的特点即可，每个选项带入栈推导下)', 'B', 394);
INSERT INTO `option_info` VALUES (1587, '3,2,5,4,1', 1, '解析：注意栈后进先出的特点即可，每个选项带入栈推导下)', 'C', 394);
INSERT INTO `option_info` VALUES (1588, '1,4,2,3,5', 0, '解析：注意栈后进先出的特点即可，每个选项带入栈推导下)', 'D', 394);
INSERT INTO `option_info` VALUES (1589, '计数排序', 1, '解析：数组几乎有序/短数组时，插入排序效率高，因为此场景下每个元素离它最终排定的位置都不会太远】', 'A', 395);
INSERT INTO `option_info` VALUES (1590, '冒泡排序', 0, '解析：数组几乎有序/短数组时，插入排序效率高，因为此场景下每个元素离它最终排定的位置都不会太远】', 'B', 395);
INSERT INTO `option_info` VALUES (1591, '插入排序', 0, '解析：数组几乎有序/短数组时，插入排序效率高，因为此场景下每个元素离它最终排定的位置都不会太远】', 'C', 395);
INSERT INTO `option_info` VALUES (1592, '选择排序', 0, '解析：数组几乎有序/短数组时，插入排序效率高，因为此场景下每个元素离它最终排定的位置都不会太远】', 'D', 395);
INSERT INTO `option_info` VALUES (1593, '2', 0, '', 'A', 396);
INSERT INTO `option_info` VALUES (1594, '1', 0, '', 'B', 396);
INSERT INTO `option_info` VALUES (1595, '3', 1, '', 'C', 396);
INSERT INTO `option_info` VALUES (1596, '6', 0, '', 'D', 396);
INSERT INTO `option_info` VALUES (1597, 'n/2', 1, '', 'A', 397);
INSERT INTO `option_info` VALUES (1598, 'n-1', 0, '', 'B', 397);
INSERT INTO `option_info` VALUES (1599, 'n', 0, '', 'C', 397);
INSERT INTO `option_info` VALUES (1600, 'logn', 0, '', 'D', 397);
INSERT INTO `option_info` VALUES (1601, '顺序表插入变动的时间复杂度为O (n)', 1, '', 'A', 398);
INSERT INTO `option_info` VALUES (1602, '顺序表按下标查找的时间复杂度是O (1)', 1, '', 'B', 398);
INSERT INTO `option_info` VALUES (1603, '顺序表在使用时，长度可随意变动', 0, '', 'C', 398);
INSERT INTO `option_info` VALUES (1604, '顺序表存储空间连续，即允许元素的随机访问', 1, '', 'D', 398);
INSERT INTO `option_info` VALUES (1605, '密码算法的安全强度由算法本身和使用的密钥长度决定', 0, '', 'A', 399);
INSERT INTO `option_info` VALUES (1606, '现阶段在选择对称密码算法时推荐安全强度至少为128位', 0, '', 'B', 399);
INSERT INTO `option_info` VALUES (1607, '安全强度就是密钥长度', 1, '', 'C', 399);
INSERT INTO `option_info` VALUES (1608, '安全强度是对称破解密码算法或者系统所需要的工作量的一个数值度量，用来衡量密码算法或者密码系统的安全性', 0, '', 'D', 399);
INSERT INTO `option_info` VALUES (1609, '排序算法', 0, '', 'A', 400);
INSERT INTO `option_info` VALUES (1610, '对计算机上执行的计算过程得具体描述', 1, '', 'B', 400);
INSERT INTO `option_info` VALUES (1611, '方法调度', 0, '', 'C', 400);
INSERT INTO `option_info` VALUES (1612, '计算方法', 0, '', 'D', 400);
INSERT INTO `option_info` VALUES (1613, '5', 0, '', 'A', 401);
INSERT INTO `option_info` VALUES (1614, '3', 0, '', 'B', 401);
INSERT INTO `option_info` VALUES (1615, '1或者5', 1, '', 'C', 401);
INSERT INTO `option_info` VALUES (1616, '1', 0, '', 'D', 401);
INSERT INTO `option_info` VALUES (1617, '92,20,91,34,88,35', 0, '解析：对于当前节点，它要么比后面的节点都大，要么比后面的节点都小】', 'A', 402);
INSERT INTO `option_info` VALUES (1618, '12,25,71,68,33,34', 0, '解析：对于当前节点，它要么比后面的节点都大，要么比后面的节点都小】', 'B', 402);
INSERT INTO `option_info` VALUES (1619, '21,89,77,29,36,38', 0, '解析：对于当前节点，它要么比后面的节点都大，要么比后面的节点都小】', 'C', 402);
INSERT INTO `option_info` VALUES (1620, '95,22,91,24,94,71', 1, '解析：对于当前节点，它要么比后面的节点都大，要么比后面的节点都小】', 'D', 402);
INSERT INTO `option_info` VALUES (1621, '若v不是T1的叶节点，则T1与T3相同', 0, '解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】', 'A', 403);
INSERT INTO `option_info` VALUES (1622, '若v是T1的叶节点，则T1与T3相同', 1, '解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】', 'B', 403);
INSERT INTO `option_info` VALUES (1623, '若v不是T1的叶节点，则T1与T3可能不同', 1, '解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】', 'C', 403);
INSERT INTO `option_info` VALUES (1624, '若v是T1的叶节点，则T1与T3可能不同', 0, '解析：前提：删除和再插入后，重新形成的都还是二叉排序树，所以】\n【如果删除的是叶子节点，则无需触发树的旋转，再次插入后树结构不会变】\n【如果删除的不是叶子节点，为了形成的仍是二叉排序树，会触发树的旋转，故再次插入原先的节点后树结构可能与原先的不同】', 'D', 403);
INSERT INTO `option_info` VALUES (1625, '108', 0, '解析：5个位置放5个字符= 54321=120】', 'A', 404);
INSERT INTO `option_info` VALUES (1626, '96', 0, '解析：5个位置放5个字符= 54321=120】', 'B', 404);
INSERT INTO `option_info` VALUES (1627, '64', 0, '解析：5个位置放5个字符= 54321=120】', 'C', 404);
INSERT INTO `option_info` VALUES (1628, '120', 1, '解析：5个位置放5个字符= 54321=120】', 'D', 404);
INSERT INTO `option_info` VALUES (1629, '2的k次方-1', 0, '', 'A', 405);
INSERT INTO `option_info` VALUES (1630, '2的(k-1)次方', 1, '', 'B', 405);
INSERT INTO `option_info` VALUES (1631, '2k-1', 0, '', 'C', 405);
INSERT INTO `option_info` VALUES (1632, '2k+1', 0, '', 'D', 405);
INSERT INTO `option_info` VALUES (1633, '在社区邮件列表/issue列表里充分交流提交的方案，并根据意见反复修改', 0, '', 'A', 407);
INSERT INTO `option_info` VALUES (1634, '在社区线下会议上介绍自己的方案，赢得社区的认可', 0, '', 'B', 407);
INSERT INTO `option_info` VALUES (1635, '和社区维护者进行沟通，理解对方的规划思路', 0, '', 'C', 407);
INSERT INTO `option_info` VALUES (1636, '由于社区一直未采纳提交补丁，自己在社区中fork一个新项目出来维护', 1, '', 'D', 407);
INSERT INTO `option_info` VALUES (1637, '差异不解决，内核引起差异，不需要与认证机构、客户说明原因', 0, '', 'A', 408);
INSERT INTO `option_info` VALUES (1638, '通过修改源代码方式解决', 0, '', 'B', 408);
INSERT INTO `option_info` VALUES (1639, '使用辅助工具BepKit消除', 1, '', 'C', 408);
INSERT INTO `option_info` VALUES (1640, '无需确认，直接删除该功能', 0, '', 'D', 408);
INSERT INTO `option_info` VALUES (1641, '将系统进行划分，以限制成功攻击的传播和损害', 1, '', 'A', 409);
INSERT INTO `option_info` VALUES (1642, '消耗攻击者的攻击能力和时间，为联动防御或反制等提供时间差', 0, '', 'B', 409);
INSERT INTO `option_info` VALUES (1643, '发现正在进行的攻击和潜在实施的攻击', 0, '', 'C', 409);
INSERT INTO `option_info` VALUES (1644, '为反击取证和提供支撑', 0, '', 'D', 409);
INSERT INTO `option_info` VALUES (1645, '2的k次方-1', 0, '', 'A', 410);
INSERT INTO `option_info` VALUES (1646, '2k-1', 0, '', 'B', 410);
INSERT INTO `option_info` VALUES (1647, '2的k-1次方', 1, '', 'C', 410);
INSERT INTO `option_info` VALUES (1648, '2k+1', 0, '', 'D', 410);
INSERT INTO `option_info` VALUES (1649, '差分隐私', 1, '', 'A', 411);
INSERT INTO `option_info` VALUES (1650, '枚举', 0, '', 'B', 411);
INSERT INTO `option_info` VALUES (1651, '截断', 0, '', 'C', 411);
INSERT INTO `option_info` VALUES (1652, '掩码', 0, '', 'D', 411);
INSERT INTO `option_info` VALUES (1653, 'O(N^1/2)', 0, '', 'A', 412);
INSERT INTO `option_info` VALUES (1654, 'O(N)', 0, '', 'B', 412);
INSERT INTO `option_info` VALUES (1655, 'O(N^2)', 0, '', 'C', 412);
INSERT INTO `option_info` VALUES (1656, 'O(logN)', 1, '', 'D', 412);
INSERT INTO `option_info` VALUES (1657, '软件工程发展的目的就是希望找到合适的方法和技术适用软件系统', 0, '', 'A', 413);
INSERT INTO `option_info` VALUES (1658, '软件工程仅指实现软件生产开发的活动序列', 1, '', 'B', 413);
INSERT INTO `option_info` VALUES (1659, '软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科，它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式灯方面', 0, '', 'C', 413);
INSERT INTO `option_info` VALUES (1660, '软件工程的目的是支持专业化的软件开发、而不仅仅是个人编程', 0, '', 'D', 413);
INSERT INTO `option_info` VALUES (1661, '113', 1, '', 'A', 414);
INSERT INTO `option_info` VALUES (1662, '120', 0, '', 'B', 414);
INSERT INTO `option_info` VALUES (1663, '51', 0, '', 'C', 414);
INSERT INTO `option_info` VALUES (1664, '38', 0, '', 'D', 414);
INSERT INTO `option_info` VALUES (1665, '系统之系统中的系统的不同部分可分别对应不同的管理和控制策略和规则', 0, '', 'A', 415);
INSERT INTO `option_info` VALUES (1666, '系统之系统中并不存在一个对系统各个部分进行管理的管理者', 0, '', 'B', 415);
INSERT INTO `option_info` VALUES (1667, '系统之系统是两个或以上独立管理和治理的系统的集合', 0, '', 'C', 415);
INSERT INTO `option_info` VALUES (1668, '系统之系统不可能是最小规模系统，如包含不同提供商提供的服务的较小的系统，大规模系统经常是系统之系统', 1, '', 'D', 415);
INSERT INTO `option_info` VALUES (1669, '自保恢复原则：负荷下降到设计能力范围之内后，网元可以立即恢复处理能力', 0, '', 'A', 416);
INSERT INTO `option_info` VALUES (1670, '业务保证原则：确保在出现大流量冲击时所有业务不被丢弃', 1, '', 'B', 416);
INSERT INTO `option_info` VALUES (1671, '及早控制原则：应尽可能在业务流程处理前端或业务处理较早的处理单元（网元/单板/芯片等）或底层协议层次上控制业务接入', 0, '', 'C', 416);
INSERT INTO `option_info` VALUES (1672, '优先级保证原则：系统过载时保证高优先级的业务能够优先获得资源，优先得到处理', 0, '', 'D', 416);
INSERT INTO `option_info` VALUES (1673, '-relro,-z,now', 0, '', 'A', 417);
INSERT INTO `option_info` VALUES (1674, '-Wl,-z,relro\nC,-Wl,-z,relro,-z,now', 0, '', 'B', 417);
INSERT INTO `option_info` VALUES (1675, '-Wl,-z,now', 1, '', 'C', 417);
INSERT INTO `option_info` VALUES (1676, '级联故障', 1, '', 'A', 418);
INSERT INTO `option_info` VALUES (1677, '随机故障', 0, '', 'B', 418);
INSERT INTO `option_info` VALUES (1678, '间歇性故障', 0, '', 'C', 418);
INSERT INTO `option_info` VALUES (1679, '单点故障', 0, '', 'D', 418);
INSERT INTO `option_info` VALUES (1680, '非持久性是在有限的时间内保留信息、服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会', 0, '', 'A', 419);
INSERT INTO `option_info` VALUES (1681, '权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配给用户和网络实体的权限，以最大限度的减少对手活动的潜在后果', 0, '', 'B', 419);
INSERT INTO `option_info` VALUES (1682, '多样性使用异构技术（例如 硬件、软件、固件、协议），这样增加了网络建设的成本，运维的难度，是不可取的', 1, '', 'C', 419);
INSERT INTO `option_info` VALUES (1683, '分割可以根据系统的重要级别进行划分，以限制成功攻击的传播或损害', 0, '', 'D', 419);
INSERT INTO `option_info` VALUES (1684, '6', 0, '', 'A', 420);
INSERT INTO `option_info` VALUES (1685, '5', 1, '', 'B', 420);
INSERT INTO `option_info` VALUES (1686, '4', 0, '', 'C', 420);
INSERT INTO `option_info` VALUES (1687, '3', 0, '', 'D', 420);
INSERT INTO `option_info` VALUES (1688, '主用单元和备用单元的故障检测率都直接影响冗余系统可用度', 0, '', 'A', 421);
INSERT INTO `option_info` VALUES (1689, '系统的冗余设计是硬件独立完成的，与软件关系不大', 1, '', 'B', 421);
INSERT INTO `option_info` VALUES (1690, '电信产品要求具备高可用性，但同时也需要考虑成本等多方面的因素，所有冗余设计并不是使用的越多越好', 0, '', 'C', 421);
INSERT INTO `option_info` VALUES (1691, '资源池冗余设计中要考虑负载均衡', 0, '', 'D', 421);
INSERT INTO `option_info` VALUES (1692, '-Wextra', 0, '', 'A', 422);
INSERT INTO `option_info` VALUES (1693, '-Wall', 0, '', 'B', 422);
INSERT INTO `option_info` VALUES (1694, '-Werror', 1, '', 'C', 422);
INSERT INTO `option_info` VALUES (1695, '-Wformat', 0, '', 'D', 422);
INSERT INTO `option_info` VALUES (1696, 'ADAPDX master', 0, '', 'A', 423);
INSERT INTO `option_info` VALUES (1697, 'Apache Struts 1.1rc2', 0, '', 'B', 423);
INSERT INTO `option_info` VALUES (1698, 'cryptojs 3.19', 1, '', 'C', 423);
INSERT INTO `option_info` VALUES (1699, 'Apache ZooKeeper 3.5.4-beta', 0, '', 'D', 423);
INSERT INTO `option_info` VALUES (1700, '20', 1, '', 'A', 424);
INSERT INTO `option_info` VALUES (1701, '25', 0, '', 'B', 424);
INSERT INTO `option_info` VALUES (1702, '15', 0, '', 'C', 424);
INSERT INTO `option_info` VALUES (1703, '10', 0, '', 'D', 424);
INSERT INTO `option_info` VALUES (1704, '92,20,91,34,88,35', 0, '', 'A', 425);
INSERT INTO `option_info` VALUES (1705, '12,25,71,68,33,34', 0, '', 'B', 425);
INSERT INTO `option_info` VALUES (1706, '21,89,77,29,36,38', 0, '', 'C', 425);
INSERT INTO `option_info` VALUES (1707, '95,22,91,24,94,71', 1, '', 'D', 425);
INSERT INTO `option_info` VALUES (1708, '站会的要求是高效，并且让每个人都集中精力', 0, '', 'A', 426);
INSERT INTO `option_info` VALUES (1709, 'Scrum Master应该对成员所描述的任务内容进行评价', 1, '', 'B', 426);
INSERT INTO `option_info` VALUES (1710, '它是一个简短的团队会议，由所有团队成员在每天固定的时间和地点进行', 0, '', 'C', 426);
INSERT INTO `option_info` VALUES (1711, '它不是一个汇报会议，而是开发团队内部的沟通会议，以便快速发现问题', 0, '', 'D', 426);
INSERT INTO `option_info` VALUES (1712, '判断原则是基于事实，编码前没阅读过开源代码编写出的代码可判定为自研，其他任何形式直接参考开源写的代码是属于开源', 1, '', 'A', 427);
INSERT INTO `option_info` VALUES (1713, '判断原则是基于工具，如果FOSSID无法扫描出来，则都是自研代码', 0, '', 'B', 427);
INSERT INTO `option_info` VALUES (1714, '判断原则是相似度，如果相似度很低，如低于5%可以判断为自研', 0, '', 'C', 427);
INSERT INTO `option_info` VALUES (1715, '判断原则是基于目录结构，自研目录下的都是自研代码，open_source目录下都是开源软件', 0, '', 'D', 427);
INSERT INTO `option_info` VALUES (1716, 'BepKit工具是为了提升二进制一致性差异消除的效率而开发的辅助工具', 0, '', 'A', 428);
INSERT INTO `option_info` VALUES (1717, 'BEP的目标是基于相同的源码、相同的环境，实现同一版本可重复构建，且构建结果完全一致', 0, '', 'B', 428);
INSERT INTO `option_info` VALUES (1718, '差异识别即基于相同的环境、相同的源代码编译两次，对两次编译结果通过beyond compare进行比较，不完全一致即存在差异，由于时间戳引起的二进制一致性差异可以忽略', 1, '', 'C', 428);
INSERT INTO `option_info` VALUES (1719, '直接比较产品软件源代码统一构建的最终结果（产品软件版本），一般无法解释所产生的差异，需要从源代码、编译过程，直到最终发布的二进制包逐层分析产生二进制一致性差异的原因', 0, '', 'D', 428);
INSERT INTO `option_info` VALUES (1720, '遵循社区规则，及时提交社区讨论互动', 1, '', 'A', 429);
INSERT INTO `option_info` VALUES (1721, '为了避免暴露公司员工的身份，用个人邮箱提交给社区', 0, '', 'B', 429);
INSERT INTO `option_info` VALUES (1722, '若华为规范与社区规范冲突，认为华为的规范更加合理，提交过程保留了华为的规范要求', 0, '', 'C', 429);
INSERT INTO `option_info` VALUES (1723, '为了抓紧特性修改被社区合入，未经评审往社区提交', 0, '', 'D', 429);
INSERT INTO `option_info` VALUES (1724, '9', 1, '', 'A', 430);
INSERT INTO `option_info` VALUES (1725, '10', 1, '', 'B', 430);
INSERT INTO `option_info` VALUES (1726, '11', 1, '', 'C', 430);
INSERT INTO `option_info` VALUES (1727, '8', 0, '', 'D', 430);
INSERT INTO `option_info` VALUES (1728, 'A平台二进制及源码没有进行配置标识及基线，导致源码缺失', 1, '', 'A', 431);
INSERT INTO `option_info` VALUES (1729, '产品正式发布的版本应配套使用A平台的正式发布版本，不应使用A平台的联调版本', 1, '', 'B', 431);
INSERT INTO `option_info` VALUES (1730, '联调版本没有通过联调版本发布流程发布，而是通过文件共享方式私下进行传递', 1, '', 'C', 431);
INSERT INTO `option_info` VALUES (1731, '具备在任意时刻都能交付二进制对应的准确源代码的能力', 1, '', 'D', 431);
INSERT INTO `option_info` VALUES (1732, '最优惠的价格', 0, '', 'A', 432);
INSERT INTO `option_info` VALUES (1733, '设备平稳运行', 0, '', 'B', 432);
INSERT INTO `option_info` VALUES (1734, '网络安全', 1, '', 'C', 432);
INSERT INTO `option_info` VALUES (1735, '隐私保护', 1, '', 'D', 432);
INSERT INTO `option_info` VALUES (1736, '某产品开发一款仅给内部一线行销员工使用的APP，并上架华为手机应用市场开放下载（但必须华为员工账号产能登录使用），该AAPP通过静态编译方式使用了一款AGPL开源软件，由于只是内部一线行销员工才能登录使用，可以不需要履行开源义务', 1, '', 'A', 433);
INSERT INTO `option_info` VALUES (1737, '公有云服务产品A通过静态链接的方式集成使用了license为GPL V2.0的开源软件，服务产品A可以不履行代码开源义务', 1, '', 'B', 433);
INSERT INTO `option_info` VALUES (1738, '某员工在业余时间以个人名义，在github开源了X项目，该员工在公司办公环境下载该X项目代码集成到产品A中使用，产品A不需要履行开源义务', 0, '', 'C', 433);
INSERT INTO `option_info` VALUES (1739, '产品A自研开发且对外开源XXComb软件，并捐献到Apache基金会成为顶级项目，产品B选用社区XXComb软件，仍应认定XXComb软件为自研软件', 1, '', 'D', 433);
INSERT INTO `option_info` VALUES (1740, '329', 0, '', 'A', 434);
INSERT INTO `option_info` VALUES (1741, '137', 1, '', 'B', 434);
INSERT INTO `option_info` VALUES (1742, '201', 0, '', 'C', 434);
INSERT INTO `option_info` VALUES (1743, '491', 1, '', 'D', 434);
INSERT INTO `option_info` VALUES (1744, '验证发布', 1, '', 'A', 435);
INSERT INTO `option_info` VALUES (1745, '现网部署', 1, '', 'B', 435);
INSERT INTO `option_info` VALUES (1746, '需求分析与设计', 1, '', 'C', 435);
INSERT INTO `option_info` VALUES (1747, '软件编码与构建', 1, '', 'D', 435);
INSERT INTO `option_info` VALUES (1748, '-fPIE -pie用于可执行程序', 1, '', 'A', 436);
INSERT INTO `option_info` VALUES (1749, '两者作用相似可以互相替换', 0, '', 'B', 436);
INSERT INTO `option_info` VALUES (1750, '-fPIC用于静态库', 0, '', 'C', 436);
INSERT INTO `option_info` VALUES (1751, '-fPIC是编译选项', 1, '', 'D', 436);
INSERT INTO `option_info` VALUES (1752, '已EOSS/即将停止销售的第三方软件不建议引入', 0, '', 'A', 437);
INSERT INTO `option_info` VALUES (1753, '业界无替代的第三方软件，可能存在供应风险', 1, '', 'B', 437);
INSERT INTO `option_info` VALUES (1754, '未签署供应商网络安全协议的软件禁止引入', 1, '', 'C', 437);
INSERT INTO `option_info` VALUES (1755, '供应商发布的软件正式版本，可以引入', 0, '', 'D', 437);
INSERT INTO `option_info` VALUES (1756, '铲平A使用一款tinyxml软件，内存分配和解析速度均可满足产品要求，且现网已稳定运行10+年，社区近期发布了tinyxml2，且社区也表示后续主要在tinyxml2上进行维护，其解析速度为tinyxml的5倍，但综合考虑升级成本及新版本的影响，产品确定继续使用tinyxml', 0, '', 'A', 438);
INSERT INTO `option_info` VALUES (1757, 'Json-lib软件社区2013年后社区已无人贡献，建议产品独臂Jackson、fastJson、Gson等同类软件，结合产品使用场景，选择生态、license较友好的开源软件', 1, '', 'B', 438);
INSERT INTO `option_info` VALUES (1758, 'XML解析开源软件SAX性能比Dom4j快10倍，SAX 2004年发布最后一个稳定版本，当前平均每周下载量34+次，对性能要求较高，且使用场景为只读不写（文件）的产品可以考虑选择此软件', 0, '', 'C', 438);
INSERT INTO `option_info` VALUES (1759, 'Log4j日志组件的作者2015年发布log4j2.X和logback；性能比log4j1.X高10倍，建议使用log4j1.X的产品考虑切换到log2.X或logback', 1, '', 'D', 438);
INSERT INTO `option_info` VALUES (1760, '功能测试自动化', 1, '', 'A', 439);
INSERT INTO `option_info` VALUES (1761, '自动化部署', 1, '', 'B', 439);
INSERT INTO `option_info` VALUES (1762, '软件开发过程引入敏捷、精益思维，最小化需求范围(MVP)', 1, '', 'C', 439);
INSERT INTO `option_info` VALUES (1763, '微服务拆分', 0, '', 'D', 439);
INSERT INTO `option_info` VALUES (1764, '不利情况发生后恢复业务', 1, '', 'A', 440);
INSERT INTO `option_info` VALUES (1765, '不利情况下维持核心业务', 1, '', 'B', 440);
INSERT INTO `option_info` VALUES (1766, '限制不利情况发生时的损害', 1, '', 'C', 440);
INSERT INTO `option_info` VALUES (1767, '降低攻击成功可能性', 1, '', 'D', 440);
INSERT INTO `option_info` VALUES (1768, '坚持不懈的追求技术卓越和良好设计', 0, '', 'A', 441);
INSERT INTO `option_info` VALUES (1769, '严格遵循计划和流程', 1, '', 'B', 441);
INSERT INTO `option_info` VALUES (1770, '尽早和持续的交付有价值软件', 0, '', 'C', 441);
INSERT INTO `option_info` VALUES (1771, '要面对面进行交流', 0, '', 'D', 441);
INSERT INTO `option_info` VALUES (1772, '观察者是各个不同的显示视图，被观察者是铁路实时订票数据', 1, '', 'A', 442);
INSERT INTO `option_info` VALUES (1773, '观察者是铁路实时订票数据，被观察者是各个不同的显示视图', 0, '', 'B', 442);
INSERT INTO `option_info` VALUES (1774, '观察者是整个实时监控界面，被观察者是铁路实时订票数据', 0, '', 'C', 442);
INSERT INTO `option_info` VALUES (1775, '观察者是铁路实时订票数据，被观察者是整个实时监控界面', 0, '', 'D', 442);
INSERT INTO `option_info` VALUES (1776, '为增强团队对产品的敬畏心，防止类似事故出现，引发事故的产品经理，开发，测试已经实施变更运维人员全年绩效不得超过B+', 0, '', 'A', 443);
INSERT INTO `option_info` VALUES (1777, '引入灰度发布，功能先对小范围用户开放，然后增量开放给其他用户', 1, '', 'B', 443);
INSERT INTO `option_info` VALUES (1778, '引入自动化测试，减少测试人员手工测试可能导致的错误', 0, '', 'C', 443);
INSERT INTO `option_info` VALUES (1779, '自动化产品的部署和回滚，降低失败对用户的影响时间', 1, '', 'D', 443);
INSERT INTO `option_info` VALUES (1780, '预生产环境数据准备要接近生产环境，可以更好的针对生产环境数据进行验证', 1, '', 'E', 443);
INSERT INTO `option_info` VALUES (1781, '用户规模不超过5千人时，登录密码验证时间不超过2秒，用户规模不超过2万人时，登录密码验证不超过5秒', 1, '', 'A', 444);
INSERT INTO `option_info` VALUES (1782, '课程属性与学生专业属性不符时不允许选课', 0, '', 'B', 444);
INSERT INTO `option_info` VALUES (1783, '系统应当在2018年9月1日之前上线部署运行', 0, '', 'C', 444);
INSERT INTO `option_info` VALUES (1784, '系统可按照院系统计学生选课请款个，指定统计范围后1秒内返回统计结果', 0, '', 'D', 444);
INSERT INTO `option_info` VALUES (1785, '基于故障机理模型的故障预测', 1, '', 'A', 445);
INSERT INTO `option_info` VALUES (1786, '基于代码的故障预测', 0, '', 'B', 445);
INSERT INTO `option_info` VALUES (1787, '基于文档的故障预测', 0, '', 'C', 445);
INSERT INTO `option_info` VALUES (1788, '基于数据驱动的故障预测', 1, '', 'D', 445);
INSERT INTO `option_info` VALUES (1789, '威胁建模', 0, '', 'A', 446);
INSERT INTO `option_info` VALUES (1790, '软件包完整性保护', 0, '', 'B', 446);
INSERT INTO `option_info` VALUES (1791, '设计架构审查', 0, '', 'C', 446);
INSERT INTO `option_info` VALUES (1792, '代码检视', 1, '', 'D', 446);
INSERT INTO `option_info` VALUES (1793, '截断：舍弃属性值的后几位信息来保证数据的模糊性', 1, '', 'A', 447);
INSERT INTO `option_info` VALUES (1794, '置换：在表中某字段各记录的数据随机进行打乱(shuffling)', 1, '', 'B', 447);
INSERT INTO `option_info` VALUES (1795, '掩码：将属性值的部分字符替换为固定的特殊字符（例如*）', 1, '', 'C', 447);
INSERT INTO `option_info` VALUES (1796, '加噪：对原始数据增加一个随机值', 1, '', 'D', 447);
INSERT INTO `option_info` VALUES (1797, '修改声明是指公司做出的对修改过的开源软件就修改时间，修改的代码以及修改过的文件做出的声明，但建议产品在修改GPL/LGPL类开源软件时，履行该义务', 0, '', 'A', 448);
INSERT INTO `option_info` VALUES (1798, '不同该许可证的开源代码不存在兼容性问题（如GPL License与BDS License），只要申请后即可按规范使用', 1, '', 'B', 448);
INSERT INTO `option_info` VALUES (1799, '代码对外开源义务是指按照开源许可证要求将一定范围内的代码对外开源，开源范围视具体许可证的要求和产品具体使用方式而定', 0, '', 'C', 448);
INSERT INTO `option_info` VALUES (1800, '原则上只要使用了开源软件，就需要履行开源使用声明义务', 0, '', 'D', 448);
INSERT INTO `option_info` VALUES (1801, '服务提供商会公开服务的信息，任何获得授权的用户都可以使用相应服务', 1, '', 'A', 449);
INSERT INTO `option_info` VALUES (1802, '组织内部或外部的服务提供商都可以提供服务', 1, '', 'B', 449);
INSERT INTO `option_info` VALUES (1803, '服务的用户能根据使用而不是提供商提供的服务来付费', 1, '', 'C', 449);
INSERT INTO `option_info` VALUES (1804, '应用能够延迟服务绑定直到这些服务被部署或执行', 1, '', 'D', 449);
INSERT INTO `option_info` VALUES (1805, '动态分析和Fuzz测试', 0, '', 'A', 450);
INSERT INTO `option_info` VALUES (1806, '测试方案设计', 1, '', 'B', 450);
INSERT INTO `option_info` VALUES (1807, '总体测试策略', 0, '', 'C', 450);
INSERT INTO `option_info` VALUES (1808, '静态分析', 0, '', 'D', 450);
INSERT INTO `option_info` VALUES (1809, '7', 0, '', 'A', 451);
INSERT INTO `option_info` VALUES (1810, '8', 1, '', 'B', 451);
INSERT INTO `option_info` VALUES (1811, '10', 0, '', 'C', 451);
INSERT INTO `option_info` VALUES (1812, '5', 0, '', 'D', 451);
INSERT INTO `option_info` VALUES (1813, '组织每日站立会议', 0, '', 'A', 452);
INSERT INTO `option_info` VALUES (1814, '引导团队正确应用敏捷实践', 0, '', 'B', 452);
INSERT INTO `option_info` VALUES (1815, '定义产品需求', 1, '', 'C', 452);
INSERT INTO `option_info` VALUES (1816, '促进团队紧密协作', 0, '', 'D', 452);
INSERT INTO `option_info` VALUES (1817, '通过负荷分担保护业务', 0, '', 'A', 453);
INSERT INTO `option_info` VALUES (1818, '主备单板倒换', 0, '', 'B', 453);
INSERT INTO `option_info` VALUES (1819, '现场更换单板', 1, '', 'C', 453);
INSERT INTO `option_info` VALUES (1820, '自动复位单板', 0, '', 'D', 453);
INSERT INTO `option_info` VALUES (1821, '涉及加密算法选择时，多使用业界公开标准的成熟算法，而不要设计私有的，自以为安全可靠的算法', 0, '', 'A', 454);
INSERT INTO `option_info` VALUES (1822, '设计不应该是秘密的，不应依赖对设计和实现的保密，以及攻击者的无知', 0, '', 'B', 454);
INSERT INTO `option_info` VALUES (1823, '加密秘钥要公开开放', 1, '', 'C', 454);
INSERT INTO `option_info` VALUES (1824, '密钥禁止硬编码', 0, '', 'D', 454);
INSERT INTO `option_info` VALUES (1825, 'Maven、npm、Pypi', 0, '', 'A', 455);
INSERT INTO `option_info` VALUES (1826, '开源软件发布的官方网站，或官方指定的获取渠道', 1, '', 'B', 455);
INSERT INTO `option_info` VALUES (1827, 'GitHub', 0, '', 'C', 455);
INSERT INTO `option_info` VALUES (1828, '华军软件园', 0, '', 'D', 455);
INSERT INTO `option_info` VALUES (1829, '可以从任意网址下载OpenSSL源码包，只要扫描不出病毒', 0, '', 'A', 456);
INSERT INTO `option_info` VALUES (1830, '修改的OpenSSL软件源码如果得到作者的认可，产品可以不用回馈社区直接引入选型OpenSSL', 0, '', 'B', 456);
INSERT INTO `option_info` VALUES (1831, '从官网下载OpenSSL源码太麻烦，可以直接使用git命令下载github上的openssl源码', 0, '', 'C', 456);
INSERT INTO `option_info` VALUES (1832, 'openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入', 1, '', 'D', 456);
INSERT INTO `option_info` VALUES (1833, '原则上，为区分自研与开源代码，确保使用和修改可追溯，开源修改的patch文件需要独立存放管理', 0, '', 'A', 457);
INSERT INTO `option_info` VALUES (1834, '开源及第三方软件与自研代码独立存放，目录隔离，从该产品代码目录结构区分出open_source目录、vendor目录、code自研目录', 0, '', 'B', 457);
INSERT INTO `option_info` VALUES (1835, '要求产品无代码片段引用，可借助FOSSID扫描工具辅助分析代码片段使用情况，并进行整改', 0, '', 'C', 457);
INSERT INTO `option_info` VALUES (1836, '整包使用开源软件，版本名称可以根据产品版本定制命名', 1, '', 'D', 457);
INSERT INTO `option_info` VALUES (1837, '分支管理', 0, '', 'A', 458);
INSERT INTO `option_info` VALUES (1838, '版本管理', 0, '', 'B', 458);
INSERT INTO `option_info` VALUES (1839, '配置状态发布', 1, '', 'C', 458);
INSERT INTO `option_info` VALUES (1840, '管理配置库', 0, '', 'D', 458);
INSERT INTO `option_info` VALUES (1841, '通过BepKit辅助消除python编译pyc文件时引入的时间差异', 0, '', 'A', 459);
INSERT INTO `option_info` VALUES (1842, '为消除自验代码中时间宏引入的二进制差异，可以选择删除DATE/TIME宏，并测试删除后是否影响业务功能', 0, '', 'B', 459);
INSERT INTO `option_info` VALUES (1843, '对于arj等压缩引入二进制差异的情况，可以通过反解的方式辅助进行差异消除', 0, '', 'C', 459);
INSERT INTO `option_info` VALUES (1844, 'gcc lto优化引入二进制差异，直接删除lto优化选项消除差异，无需对业务性能进行测试', 1, '', 'D', 459);
INSERT INTO `option_info` VALUES (1845, '通过故障预测预防，用户可以根据故障出现的概率以及出现的位置，采取相应的手段提前避免这些有可能出现的故障', 0, '', 'A', 460);
INSERT INTO `option_info` VALUES (1846, '故障预测预防是一种被动故障处理技术', 1, '', 'B', 460);
INSERT INTO `option_info` VALUES (1847, '故障预测预防技术是一种有效的主动故障处理技术', 0, '', 'C', 460);
INSERT INTO `option_info` VALUES (1848, '故障预测可以在系统故障出现之前，通过分析系统的状态得到故障可能出现的概率以及出现的故障种类', 0, '', 'D', 460);
INSERT INTO `option_info` VALUES (1849, '切换第三方版本X的新版本，确保能享受供应商完整的保障能力', 1, '', 'A', 461);
INSERT INTO `option_info` VALUES (1850, '由于不是新产品，不考虑升级第三方软件X新版本', 0, '', 'B', 461);
INSERT INTO `option_info` VALUES (1851, '考虑测试成本，通过购买供应商延长维保服务，继续使用X的老版本', 0, '', 'C', 461);
INSERT INTO `option_info` VALUES (1852, '由于架构未调整，不考虑升级第三方软件X新版本', 0, '', 'D', 461);
INSERT INTO `option_info` VALUES (1853, '软件产品工程SPLE', 1, '', 'A', 462);
INSERT INTO `option_info` VALUES (1854, '分布式系统', 0, '', 'B', 462);
INSERT INTO `option_info` VALUES (1855, '应用框架', 0, '', 'C', 462);
INSERT INTO `option_info` VALUES (1856, '应用系统复用', 0, '', 'D', 462);
INSERT INTO `option_info` VALUES (1857, '若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程（需开源），通过隔离层进行交互', 1, '', 'A', 463);
INSERT INTO `option_info` VALUES (1858, '在内核态中对Linux kernel进行调用，以避免GPL传染', 0, '', 'B', 463);
INSERT INTO `option_info` VALUES (1859, '可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互', 1, '', 'C', 463);
INSERT INTO `option_info` VALUES (1860, '以动态链接的方式使用GPL软件，使产品代码不会被GPL传染', 0, '', 'D', 463);
INSERT INTO `option_info` VALUES (1861, '静态工具扫描', 1, '', 'A', 464);
INSERT INTO `option_info` VALUES (1862, '关键字扫描', 1, '', 'B', 464);
INSERT INTO `option_info` VALUES (1863, '根因分析法', 0, '', 'C', 464);
INSERT INTO `option_info` VALUES (1864, '自上而下分析法', 1, '', 'D', 464);
INSERT INTO `option_info` VALUES (1865, '在研发过程中对各个环节的关键基础设施落地严格的风险应对措施，如对代码仓尽心更严格的访问、完整性方案设计，保障产品软件开发过程的完整性，一致性，不因恶意篡改导致最终的功能特性与客户预期不相符，设置损害客户利益', 1, '', 'A', 465);
INSERT INTO `option_info` VALUES (1866, '产品要做到结果风险可控，须通过有效执行研发过程的安全活动控制项要求。', 1, '', 'B', 465);
INSERT INTO `option_info` VALUES (1867, '产品要做到具备威胁无处不在的视角，通过有效的基础设施及环境保护应对研发过程恶意篡改风险。', 1, '', 'C', 465);
INSERT INTO `option_info` VALUES (1868, '通过后端测试保证产品质量即可，研发过程风险无须过多关注', 0, '', 'D', 465);
INSERT INTO `option_info` VALUES (1869, '合法合规', 1, '', 'A', 466);
INSERT INTO `option_info` VALUES (1870, '网络安全风险', 1, '', 'B', 466);
INSERT INTO `option_info` VALUES (1871, '生命周期情况', 1, '', 'C', 466);
INSERT INTO `option_info` VALUES (1872, '开源软件的技术生态', 1, '', 'D', 466);
INSERT INTO `option_info` VALUES (1873, '需求跟踪说明', 0, '', 'A', 467);
INSERT INTO `option_info` VALUES (1874, '需求变更管理文档', 0, '', 'B', 467);
INSERT INTO `option_info` VALUES (1875, '需求分析设计', 0, '', 'C', 467);
INSERT INTO `option_info` VALUES (1876, '需求基线', 1, '', 'D', 467);
INSERT INTO `option_info` VALUES (1877, '需求发现', 0, '', 'A', 468);
INSERT INTO `option_info` VALUES (1878, '需求变更控制', 1, '', 'B', 468);
INSERT INTO `option_info` VALUES (1879, '需求排序', 0, '', 'C', 468);
INSERT INTO `option_info` VALUES (1880, '需求评估', 0, '', 'D', 468);
INSERT INTO `option_info` VALUES (1881, '需求分析中，对不明确的功能需求，要进行细致调查后进行具体化。', 1, '', 'A', 469);
INSERT INTO `option_info` VALUES (1882, '需求分析时，对项目目标，涉及的问题和场景，都需要考虑。', 1, '', 'B', 469);
INSERT INTO `option_info` VALUES (1883, '需求分析过程中，需要将需求转化成形式化的功能规约，如需求规格说明书。', 1, '', 'C', 469);
INSERT INTO `option_info` VALUES (1884, '采用敏捷流程后，需求分析完成后，可以不用输出形式化的功能规约。', 0, '', 'D', 469);
INSERT INTO `option_info` VALUES (1885, '对特殊的异常场景，不做分析。', 1, '', 'A', 470);
INSERT INTO `option_info` VALUES (1886, '特性的可交付性和服务代表要求不一致。', 1, '', 'B', 470);
INSERT INTO `option_info` VALUES (1887, '对性能的描述：整体系统的响应时间不小于2秒。', 1, '', 'C', 470);
INSERT INTO `option_info` VALUES (1888, '需求的来源和开发阶段的影响，通过IR/SR/AR进行了关联。', 0, '', 'D', 470);
INSERT INTO `option_info` VALUES (1889, '用户可以根据图书名搜索到该图书', 1, '', 'A', 471);
INSERT INTO `option_info` VALUES (1890, '系统可以查询到某用户当前已借的图书', 1, '', 'B', 471);
INSERT INTO `option_info` VALUES (1891, '系统应该24小时可用，宕机时间不超过5秒', 0, '', 'C', 471);
INSERT INTO `option_info` VALUES (1892, '用户输入书名后应在2秒内查询到该书信息', 0, '', 'D', 471);
INSERT INTO `option_info` VALUES (1893, '管理员应该在1H培训后可以使用该系统的管理功能', 0, '', 'E', 471);
INSERT INTO `option_info` VALUES (1894, '应将每个学生的学生编号作为该学生的唯一标识', 0, '', 'F', 471);
INSERT INTO `option_info` VALUES (1895, '顺序图', 0, '', 'A', 472);
INSERT INTO `option_info` VALUES (1896, '类图', 1, '', 'B', 472);
INSERT INTO `option_info` VALUES (1897, '状态图', 0, '', 'C', 472);
INSERT INTO `option_info` VALUES (1898, '活动图', 0, '', 'D', 472);
INSERT INTO `option_info` VALUES (1899, '适配器模式(ADAPTER)', 0, '', 'A', 473);
INSERT INTO `option_info` VALUES (1900, '迭代器模式(ITERATOR)', 0, '', 'B', 473);
INSERT INTO `option_info` VALUES (1901, '访问者模式(VISITOR)', 1, '', 'C', 473);
INSERT INTO `option_info` VALUES (1902, '观察者模式(OBSERVER)', 0, '', 'D', 473);
INSERT INTO `option_info` VALUES (1903, '结构型模式可以在不破坏类封装性的基础上，实现新的功能。', 1, '', 'A', 474);
INSERT INTO `option_info` VALUES (1904, '结构型模式主要用于创建一组对象。', 0, '', 'B', 474);
INSERT INTO `option_info` VALUES (1905, '结构型模式可以创建一组类的统一访问接口。', 1, '', 'C', 474);
INSERT INTO `option_info` VALUES (1906, '结构型模式可以在不破坏类封装性的基础上，使得类可以同不曾估计到的系统进行交互。', 1, '', 'D', 474);
INSERT INTO `option_info` VALUES (1907, '必须提供工厂方法的默认实现', 0, '', 'A', 475);
INSERT INTO `option_info` VALUES (1908, '参数化工厂方法', 1, '', 'B', 475);
INSERT INTO `option_info` VALUES (1909, '所有语言的特点', 1, '', 'C', 475);
INSERT INTO `option_info` VALUES (1910, '使用模板以避免创建子类', 1, '', 'D', 475);
INSERT INTO `option_info` VALUES (1911, '从类A派生出子类B和C，在类B和C中均有ChangeName的操作，将ChangeName提取到类A中。', 0, '', 'A', 476);
INSERT INTO `option_info` VALUES (1912, '将类A中的接口InterfaceA和InterfaceB搬移到一个单独的新类B中。', 0, '', 'B', 476);
INSERT INTO `option_info` VALUES (1913, '当发现类A某个函数不仅仅适用于当前类，还适用于其他的类时，将该函数抽取为独立函数放入工具类中，供其他类使用。', 1, '', 'C', 476);
INSERT INTO `option_info` VALUES (1914, '类A和类B均对同一对象做相同的设置操作，通过提取一个基类消除这部分重复的数据及相关操作。', 0, '', 'D', 476);
INSERT INTO `option_info` VALUES (1915, '根据函数处理流程方法，即怎么做。', 0, '', 'A', 477);
INSERT INTO `option_info` VALUES (1916, '根据函数所要达到的目的，即做什么。', 1, '', 'B', 477);
INSERT INTO `option_info` VALUES (1917, '根据函数的使用场景，即何时用。', 0, '', 'C', 477);
INSERT INTO `option_info` VALUES (1918, '根据函数的输入参数决定，即对哪些。', 0, '', 'D', 477);
INSERT INTO `option_info` VALUES (1919, '提取接口(Extract Interface)和提取超类(Extract Superclass)本质上是一回事，均可提取通用代码。', 1, '', 'A', 478);
INSERT INTO `option_info` VALUES (1920, '隐藏委托关系会使代码层次更清晰，因此委托类的功能越多越好。', 1, '', 'B', 478);
INSERT INTO `option_info` VALUES (1921, '当发现某个子类并未带来该有的派生价值时，就需要考虑把他和父类合并(折叠)起来。', 0, '', 'C', 478);
INSERT INTO `option_info` VALUES (1922, '将值域上移到父类会有效减少子类的成员变量，只需要做搬移值域，不需要搬移对该值域的操作方法。', 1, '', 'D', 478);
INSERT INTO `option_info` VALUES (1923, '重构尽量以微小的步伐修改程序，直接重构一个模块是非常冒险的行为，需要谨慎应对。', 0, '', 'A', 479);
INSERT INTO `option_info` VALUES (1924, '程序\"如果没有坏(功能可用)，就不要去修复它\"，是代码是否需要选择重构的必要条件。', 1, '', 'B', 479);
INSERT INTO `option_info` VALUES (1925, '重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。', 1, '', 'C', 479);
INSERT INTO `option_info` VALUES (1926, '重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。', 1, '', 'D', 479);
INSERT INTO `option_info` VALUES (1927, '使用各种有利于解耦的设计模式常常会导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。', 1, '', 'E', 479);
INSERT INTO `option_info` VALUES (1928, '开发初期如果类中有一个字段location标识位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。', 1, '', 'A', 480);
INSERT INTO `option_info` VALUES (1929, '对象取代数据值：就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。', 0, '', 'B', 480);
INSERT INTO `option_info` VALUES (1930, '对于数据结构，要求封装出增删改查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。', 0, '', 'C', 480);
INSERT INTO `option_info` VALUES (1931, '我们可以通过关闭Connection，就顺带着关闭ResultSet和Statement，不需要在代码中显示地关闭ResultSet和Statement，保持代码简单和简洁。', 1, '', 'A', 481);
INSERT INTO `option_info` VALUES (1932, '我们需要先关闭Connection，接着显示地关闭ResultSet和Statement。', 1, '', 'B', 481);
INSERT INTO `option_info` VALUES (1933, '我们需要先关闭Connection，接着显示地关闭Statement和ResultSet。', 1, '', 'C', 481);
INSERT INTO `option_info` VALUES (1934, '我们需要先关闭ResultSet和Statement，然后Connection就自动关闭了，不需要显示地关闭Connection。', 1, '', 'D', 481);
INSERT INTO `option_info` VALUES (1935, '同一个预共享秘钥，既可以用于认证，又可以用于完整性保护。', 1, '', 'A', 482);
INSERT INTO `option_info` VALUES (1936, '一个秘钥可以通过算法派生两个秘钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性。', 0, '', 'B', 482);
INSERT INTO `option_info` VALUES (1937, '分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务', 0, '', 'C', 482);
INSERT INTO `option_info` VALUES (1938, '数字签名可以同时提供身份认证，数据完整性以及抗抵赖服务', 0, '', 'D', 482);
INSERT INTO `option_info` VALUES (1939, '机密性', 0, '', 'A', 483);
INSERT INTO `option_info` VALUES (1940, '完整性', 1, '', 'B', 483);
INSERT INTO `option_info` VALUES (1941, '真实性', 0, '', 'C', 483);
INSERT INTO `option_info` VALUES (1942, '不可抵赖性', 0, '', 'D', 483);
INSERT INTO `option_info` VALUES (1943, '一个帐号或帐号组只能拥有必需的角色和必需的权限，一个角色只能拥有必需的权限，不分配不必要的权限。', 1, '', 'A', 484);
INSERT INTO `option_info` VALUES (1944, '权限划分的粒度尽可能最小化，帐号权限应基于“need-to-know”和“case-by-case”的原则', 1, '', 'B', 484);
INSERT INTO `option_info` VALUES (1945, '不使用“administrator”、 “Root”、”sa”、“sysman”、“Supervisor”和其他特权帐号来运行应用程序或连接Web服务接口、数据库和其它中间件。', 1, '', 'C', 484);
INSERT INTO `option_info` VALUES (1946, '根据运行所需的操作系统权限的不同以及暴露给用户的访问权限的不同，对其进行划分和授权，采用不同权限的帐号运行。', 1, '', 'D', 484);
INSERT INTO `option_info` VALUES (1947, '时间宏引起的差异', 1, '', 'A', 485);
INSERT INTO `option_info` VALUES (1948, '编译脚本中引入绝对路径', 0, '', 'B', 485);
INSERT INTO `option_info` VALUES (1949, '开源第三方引入差异', 0, '', 'C', 485);
INSERT INTO `option_info` VALUES (1950, '加密引起的差异', 0, '', 'D', 485);
INSERT INTO `option_info` VALUES (1951, 'JITTest.doubleIndex被内联', 1, '', 'A', 486);
INSERT INTO `option_info` VALUES (1952, 'JITTest.doubleIndex会被编译成机器码执行', 1, '', 'B', 486);
INSERT INTO `option_info` VALUES (1953, 'JITTest.sum会被编译成机器码执行', 1, '', 'C', 486);
INSERT INTO `option_info` VALUES (1954, '拆箱和装箱', 0, '', 'D', 486);
INSERT INTO `option_info` VALUES (1955, 'Full GC不对MetaSpace进行GC', 0, '', 'A', 487);
INSERT INTO `option_info` VALUES (1956, 'GC调优是追求消除Major GC和Minor GC', 0, '', 'B', 487);
INSERT INTO `option_info` VALUES (1957, '性能优化的三个指标：吞吐量、延迟、内存占用', 1, '', 'C', 487);
INSERT INTO `option_info` VALUES (1958, 'JVM垃圾收集三个基本原则：\nMinor GC最多原则、GC内存最大化原则、GC调优(吞吐量、延迟、内存占用)的3选2原则。', 1, '', 'D', 487);
INSERT INTO `option_info` VALUES (1959, '在java8中，-Xdebug可有可无', 1, '', 'A', 488);
INSERT INTO `option_info` VALUES (1960, 'transport类型可以是dt_socket和dt_shmem，其中dt_shmem只适用于windows平台', 1, '', 'B', 488);
INSERT INTO `option_info` VALUES (1961, '使用-Xrunjdwp后，将以调试模式启动java进程', 1, '', 'C', 488);
INSERT INTO `option_info` VALUES (1962, 'suspend指明是否支持断点   --- 调试客户端建立连接之后启动VM，调试启动问题', 0, '', 'D', 488);
INSERT INTO `option_info` VALUES (1963, 'onthrow指明是否在发生指定异常时中断执行，进行调试', 1, '', 'E', 488);
INSERT INTO `option_info` VALUES (1964, '语义分析及生成字节码', 1, '解析：词法分析 语法分析 填充符号表 语义分析 字节码生成', 'A', 489);
INSERT INTO `option_info` VALUES (1965, '词法分析及填充符号表', 1, '解析：词法分析 语法分析 填充符号表 语义分析 字节码生成', 'B', 489);
INSERT INTO `option_info` VALUES (1966, 'Server Compiler', 0, '解析：词法分析 语法分析 填充符号表 语义分析 字节码生成', 'C', 489);
INSERT INTO `option_info` VALUES (1967, '注解处理', 1, '解析：词法分析 语法分析 填充符号表 语义分析 字节码生成', 'D', 489);
INSERT INTO `option_info` VALUES (1968, 'Client Compiler', 0, '解析：词法分析 语法分析 填充符号表 语义分析 字节码生成', 'E', 489);
INSERT INTO `option_info` VALUES (1969, '构建脚本是源代码的一部分，要和源代码一起配置管理。', 0, '', 'A', 490);
INSERT INTO `option_info` VALUES (1970, '构建脚本在提交入库的时候，一样要进行规范检查。', 0, '', 'B', 490);
INSERT INTO `option_info` VALUES (1971, 'Committer在处理MR的时候，也要对构建脚本的正确性、简洁性、是否高效等进行把关。', 0, '', 'C', 490);
INSERT INTO `option_info` VALUES (1972, '为了提供开发和维护效率，各个子系统和模块可以自由选择最熟悉的脚本来编写构建脚本，可以多种脚本语言并存。', 1, '', 'D', 490);
INSERT INTO `option_info` VALUES (1973, '为了提供可移植性，不应该使用与OS强相关的脚本语言或者命令(如shell或bat脚本)，而是尽量选择maven,cmake,gradle这样的构建工具和对应的而语言。', 0, '', 'E', 490);
INSERT INTO `option_info` VALUES (1974, '构建脚本中必须使用相对路径，禁止使用绝对路径。', 0, '', 'A', 491);
INSERT INTO `option_info` VALUES (1975, '构建工程中禁止依赖特定的安装路径。', 0, '', 'B', 491);
INSERT INTO `option_info` VALUES (1976, '禁止在构建的时候使用网络共享驱动器', 0, '', 'C', 491);
INSERT INTO `option_info` VALUES (1977, '构建工程和脚本应该对工具安装路径做明确的要求，明确写在脚本中，比如工具必须安装在/usr/build/tools目录下，这样方便对构建环境进行规范化和溯源。', 1, '', 'D', 491);
INSERT INTO `option_info` VALUES (1978, 'compile：默认的依赖范围，编译、测试、运行期都需要', 1, '', 'A', 492);
INSERT INTO `option_info` VALUES (1979, 'provided：表示在编译和测试期需要，但是运行期不需要', 1, '', 'B', 492);
INSERT INTO `option_info` VALUES (1980, 'test：表示在测试期需要，编译和运行时都不需要', 1, '', 'C', 492);
INSERT INTO `option_info` VALUES (1981, 'system：表示非maven仓库引入的jar，使用时需要显式的用systemPath元素提供一个本地系统中jar文件的路径', 1, '', 'D', 492);
INSERT INTO `option_info` VALUES (1982, 'runtime：表示在测试和运行期需要，但在编译的时候不需要', 1, '', 'E', 492);
INSERT INTO `option_info` VALUES (1983, 'jmap –histo 17212', 1, '', 'A', 493);
INSERT INTO `option_info` VALUES (1984, 'top –Hp 17212', 0, '', 'B', 493);
INSERT INTO `option_info` VALUES (1985, 'jstack 17212', 0, '', 'C', 493);
INSERT INTO `option_info` VALUES (1986, 'jstat –gcutil 17212', 0, '', 'D', 493);
INSERT INTO `option_info` VALUES (1987, '通过-XX:ThreadStackSize可以设置线程堆栈大小', 0, '', 'A', 494);
INSERT INTO `option_info` VALUES (1988, '相比server模式，JVM client模式可以获得更好的性能', 1, '', 'B', 494);
INSERT INTO `option_info` VALUES (1989, '通过-Xms和-Xmx可以设置Java堆的大小', 0, '', 'C', 494);
INSERT INTO `option_info` VALUES (1990, '通过-XX:MetaspaceSize和-XX:MaxMetaspaceSize可以设置元数据区(Metaspace)的大小', 0, '', 'D', 494);
INSERT INTO `option_info` VALUES (1991, '自动化', 0, '', 'A', 495);
INSERT INTO `option_info` VALUES (1992, '可重复', 0, '', 'B', 495);
INSERT INTO `option_info` VALUES (1993, '运行稳定', 0, '', 'C', 495);
INSERT INTO `option_info` VALUES (1994, '独立性', 1, '', 'D', 495);
INSERT INTO `option_info` VALUES (1995, '2', 0, '', 'A', 496);
INSERT INTO `option_info` VALUES (1996, '3', 0, '', 'B', 496);
INSERT INTO `option_info` VALUES (1997, '4', 1, '', 'C', 496);
INSERT INTO `option_info` VALUES (1998, '5', 0, '', 'D', 496);
INSERT INTO `option_info` VALUES (1999, '@Test\npublic void canVote_throwIllegalArgumentExceptionForZeroAge0() {\nPerson person = new Person(0);\nperson.canVote();\n}', 0, '', 'A', 497);
INSERT INTO `option_info` VALUES (2000, '@Test(expected = IllegalArgumentException.class)\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nperson.canVote();\n}', 1, '', 'B', 497);
INSERT INTO `option_info` VALUES (2001, '@Rule\npublic ExpecetedException thrown = ExpecetedException.none();\n@Test\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nthrown.expect(IllegalArgumentException.class);\nperson.canVote();\n}', 1, '', 'C', 497);
INSERT INTO `option_info` VALUES (2002, '@Rule\npublic ExpecetedException thrown = ExpecetedException.none();\n@Test(expected = IllegalArgumentException.class)\npublic void canVote_throwIllegalArgumentExceptionForZeroAge() {\nPerson person = new Person(0);\nthrown.expect(IllegalArgumentException.class);\nthrown.expectMessage(\"age error\");\nperson.canVote();\n}', 0, '', 'D', 497);
INSERT INTO `option_info` VALUES (2003, '两个分支均修改了同一个文件的同一行，并且修改结果不同。', 0, '', 'A', 498);
INSERT INTO `option_info` VALUES (2004, '同一个文件在两个分支上被重命名为不同的文件名。', 0, '', 'B', 498);
INSERT INTO `option_info` VALUES (2005, '同一个文件在一个分支上被删除，在另一个分支上该文件被修改。', 0, '', 'C', 498);
INSERT INTO `option_info` VALUES (2006, '两个分支分别修改了不同文件的内容。', 1, '', 'D', 498);
INSERT INTO `option_info` VALUES (2007, '可以使用Excel文件来作为配置文件。', 1, '', 'A', 499);
INSERT INTO `option_info` VALUES (2008, '可以使用文本格式的ini文件座位配置文件。', 0, '', 'B', 499);
INSERT INTO `option_info` VALUES (2009, '可以使用yaml作为配置文件。', 0, '', 'C', 499);
INSERT INTO `option_info` VALUES (2010, '可以使用json格式的文件作为配置文件。', 0, '', 'D', 499);
INSERT INTO `option_info` VALUES (2011, '可以使用xml文件作为配置文件。', 0, '', 'E', 499);
INSERT INTO `option_info` VALUES (2012, '对单个软件项目的软件生产过程中产生业务对象的过程及对象间的关系的准确记录。', 1, '', 'A', 500);
INSERT INTO `option_info` VALUES (2013, '开发过程中软件跨项目的需求以及配套依赖的关系的准确记录。', 1, '', 'B', 500);
INSERT INTO `option_info` VALUES (2014, '产品支持不同业务平面的网络流量安全隔离。', 0, '', 'C', 500);
INSERT INTO `option_info` VALUES (2015, '敏感数据需要具备加密保存能力。', 0, '', 'D', 500);
INSERT INTO `option_info` VALUES (2016, '客户要求使用开源软件新版本，产品A集成使用的开源软件B近3年无人维护且无可替代软件，产品A将开源软件B及修改的代码在github以新项目C开源并且自行维护，再将开源软件C集成到产品A中进行使用。', 1, '', 'A', 501);
INSERT INTO `option_info` VALUES (2017, '开源软件的选用，是产品在需求分析和架构设计时决定的；产品需基于全量全视角管理产品和平台使用的开源及第三方软件，确保使用的开源及三方版本归一和满足生命周期要求。', 0, '', 'B', 501);
INSERT INTO `option_info` VALUES (2018, '产品A软件开发在编写代码时，拷贝Apache license 2.1、 的 XXC++ 开源代码中的排序算法实现代码，已提升开发效率。', 1, '', 'C', 501);
INSERT INTO `option_info` VALUES (2019, '产品A 使用的开源软件被爆出存在严重漏洞（CVSS>7）,产品A的安全SE分析发现该漏洞涉及的代码A未调用，可以不需要对产品A的现网版本打补丁。', 1, '', 'D', 501);
INSERT INTO `option_info` VALUES (2020, '某产品共130K行代码，其中仅10行代码与开源代码相似度较高; 该10行代码可以确认为自研代码。', 1, '', 'E', 501);
INSERT INTO `option_info` VALUES (2021, '为保证来源可靠，业务版本使用的开源及第三方软件必须来自保存在华为PDM库中的软件副本', 1, '', 'A', 502);
INSERT INTO `option_info` VALUES (2022, '非A/B类红线安全问题，如果是高风险(CVSS评分>=7)的安全问题则在版本发布前解决或规避，如果是中低风险(CVSS评分<7)的安全问题则可待供应商/合作方修复后再同步其修复版本', 1, '', 'B', 502);
INSERT INTO `option_info` VALUES (2023, '在业务版本的研发过程中，开源及第三方软件需随产品代码一起开展产品网络安全测试', 1, '', 'C', 502);
INSERT INTO `option_info` VALUES (2024, 'A类红线和高风险(CVSS评分>=7)的B类红线问题在版本发布前解决或规避，中低风险(CVSS评分<7)的B类红线问题则可待供应商/合作方修复后再同步修复版本', 1, '', 'D', 502);
INSERT INTO `option_info` VALUES (2025, '一种新的角色，同时具备开发和运维技能。', 0, '', 'A', 503);
INSERT INTO `option_info` VALUES (2026, '一个专门的团队，同时具备开发和运维能力。', 0, '', 'B', 503);
INSERT INTO `option_info` VALUES (2027, '是指开发和运维一起参与到整个软件生命周期过程的实践-从开发、测试、部署上线到维护。', 1, '', 'C', 503);
INSERT INTO `option_info` VALUES (2028, '和传统的运维区别不大，只是使用了一些新的工具去实现自动化。', 0, '', 'D', 503);
INSERT INTO `option_info` VALUES (2029, 'CFHGEBDK', 0, '', 'A', 504);
INSERT INTO `option_info` VALUES (2030, 'CDFEGHBK', 0, '', 'B', 504);
INSERT INTO `option_info` VALUES (2031, 'FGHCDEBK', 0, '', 'C', 504);
INSERT INTO `option_info` VALUES (2032, 'CFHGEDBK', 1, '', 'D', 504);
INSERT INTO `option_info` VALUES (2033, '1', 0, '', 'A', 505);
INSERT INTO `option_info` VALUES (2034, '2', 0, '', 'B', 505);
INSERT INTO `option_info` VALUES (2035, '3', 0, '', 'C', 505);
INSERT INTO `option_info` VALUES (2036, '没有错误', 1, '', 'D', 505);
INSERT INTO `option_info` VALUES (2037, 'InputStream in = ...;\nException ex = null;\ntry {\ntry {\n//code that might throw exceptions\n} catch (Exception e) {\nex = e;\nthrow e;\n}\n} finally {\ntry {\nin.close();\n} catch (Exception e) {\nif (ex == null) throw e;\n}\n}', 0, '', 'A', 506);
INSERT INTO `option_info` VALUES (2038, 'try (Scanner in = new Scanner(new FileInputStream(\"7usr/share/dict/words\"), \"UTF-8\"); PrintWriter out = new PrintWriter(\"out.txt\")) {\nwhile (in.hasNext()) {\nout.println(in.next().toUpperCase());\n}\n}', 1, '', 'B', 506);
INSERT INTO `option_info` VALUES (2039, 'InputStream in = ...\ntry {\n//code that might throw exceptions\n} finally {\nin.close();\n}', 0, '', 'C', 506);
INSERT INTO `option_info` VALUES (2040, '没有任何算法', 0, '', 'A', 507);
INSERT INTO `option_info` VALUES (2041, '基数排序', 1, '', 'B', 507);
INSERT INTO `option_info` VALUES (2042, '计数排序', 0, '', 'C', 507);
INSERT INTO `option_info` VALUES (2043, '快速排序', 0, '', 'D', 507);
INSERT INTO `option_info` VALUES (2044, '插入排序', 0, '', 'A', 508);
INSERT INTO `option_info` VALUES (2045, '冒泡排序', 0, '', 'B', 508);
INSERT INTO `option_info` VALUES (2046, '计数排序', 1, '', 'C', 508);
INSERT INTO `option_info` VALUES (2047, '选择排序', 0, '', 'D', 508);
INSERT INTO `option_info` VALUES (2048, 'ArrayList<String> list = ...;\nif (list.contains(\"Martin\")) {\n...\n}', 0, '', 'A', 509);
INSERT INTO `option_info` VALUES (2049, 'LinkedList<String> list = ...;\nfor (String value : list) {\nif (value.contains(\"Martin\")) {\n...\n}\n}', 0, '', 'B', 509);
INSERT INTO `option_info` VALUES (2050, 'HashSet<String> set = ...;\nif (set.contains(\"Martin\")) {\n...\n}', 1, '', 'C', 509);
INSERT INTO `option_info` VALUES (2051, 'Vector<String> vec = ...;\nif (vec.contains(\"Martin\")) {\n...\n}', 0, '', 'D', 509);
INSERT INTO `option_info` VALUES (2052, 'public final class Sinleton {\nprivate static Sinleton instance;\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nif (instance = null) {\nsynchronized (Sinleton.class) {\nif (instance == null) {\ninstance = new Sinleton();\n}\n}\n}\nreturn instance;\n}\n}', 0, '', 'A', 510);
INSERT INTO `option_info` VALUES (2053, 'public final class Sinleton {\nprivate static class Sinleton {\nprivate static Sinleton instance = new Sinleton();\n}\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nreturn SinletonHolder.instance;\n}\n}', 1, '', 'B', 510);
INSERT INTO `option_info` VALUES (2054, 'public final class Sinleton {\nprivate static volatile Sinleton instance;\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nif (instance == null) {\nsynchronized (Sinleton.class) {\nif (instance == null) {\ninstance = new Sinleton();\n}\n}\n}\nreturn instance;\n}\n}', 1, '', 'C', 510);
INSERT INTO `option_info` VALUES (2055, 'public final class Sinleton {\nprivate static Sinleton instance = new Sinleton();\nprivate Sinleton() {}\npublic static Sinleton getInstance() {\nreturn instance;\n}\n}', 1, '', 'D', 510);
INSERT INTO `option_info` VALUES (2056, 'static class Fruit{}\nstatic class Apple extends Fruit{}\nstatic class BigApple extends Apple {}\npublic static void main(String[] args) {\nList<? super Apple> list = new ArrayList<>();\nlist.add(new BigApple());\nlist.add(new Apple());\n}', 1, '', 'A', 511);
INSERT INTO `option_info` VALUES (2057, 'static class Fruit{}\nstatic class Apple extends Fruit{}\npublic static void main(String[] args) {\nList<? extends Fruit> list = new ArrayList<>();\nlist.add(new Apple());\n}', 0, '', 'B', 511);
INSERT INTO `option_info` VALUES (2058, 'public class ShowTest<T> {\npublic static void show(T t) {\nSystem.out.println(t.toString());\n}\n}', 0, '', 'C', 511);
INSERT INTO `option_info` VALUES (2059, 'static class Fruit {}\nstatic class Apple extends Fruit {}\npublic static void main(String[] args) {\nList<Fruit> fruitList = new ArrayList<>();\nList<Appler> appleList = new ArrayList<>();\nfruitList.addAll(appleList);\n}', 1, '', 'D', 511);
INSERT INTO `option_info` VALUES (2060, '线程DEADLOCK_TEST-1处于死锁状态', 1, '', 'A', 512);
INSERT INTO `option_info` VALUES (2061, '线程DEADLOCK_TEST-2处于死锁状态', 1, '', 'B', 512);
INSERT INTO `option_info` VALUES (2062, '线程DEADLOCK_TEST-3处于死锁状态', 1, '', 'C', 512);
INSERT INTO `option_info` VALUES (2063, 'DEADLOCK_TEST-1、DEADLOCK_TEST-2、DEADLOCK_TEST-3均没有处于死锁状态', 0, '', 'D', 512);
INSERT INTO `option_info` VALUES (2064, 'public class LeftRightLock {\nprivate final Object left = new Object();\nprivate final Object right = new Object();\npublic void functionA() {\nsynchronized (left) {\nsynchronized (right) {\ndoSomething();\n}\n}\n}\npublic void functionB() {\nsynchronized (right) {\nsynchronized(left) {\ndoSomething();\n}\n}\n}\n}\n......', 1, '', 'A', 513);
INSERT INTO `option_info` VALUES (2065, 'public void transferMony(Account fromAccount, Account toAccount, int amount) {\nsynchronized (fromAccount) {\nsynchronized(toAccount) {\nfromAccount.debit(amount);\ntoAccount.credit(amount);\n}\n}\n}', 1, '', 'B', 513);
INSERT INTO `option_info` VALUES (2066, 'public class Taxi {\nprivate Point location;\nprivate Point destinztion;\nprivate final Dispatcher dispatcher;\npublic Taxi(Dispatcher dispatcher) {\nthis.dispatcher = dispatcher;\n}\npublic synchronized Point getLocation() {\nreturn location;\n}\npublic synchronized void setLocation(Point location) {\nthis.location = location;\nif (this.location.equals(destinztion)) {\ndispatcher.notifyAvailable(this);\n}\n}\n......\n}\npublic class Dispatcher {\nprivate final Set<Taxi> taxis = new HashSet<>();\nprivate final Set<Taxi> availableTaxis = new HashSet<>();\npublic synchronized void notifyAvailable(Taxi taxi) {\navailableTaxis.add(taxi);\n}\npublic synchronized Image getImage() {\nfinal Image image = new Image();\nfor (final Taxi taxi : taxis) {\nimage.drawMarket(taxi.getLocation());\n}\nreturn image;\n}\n......\n}', 1, '', 'C', 513);
INSERT INTO `option_info` VALUES (2067, 'private final ExecutorService executor = Executors.newSingleThreadExecutor();\npublic void renderPage() throws InterruptedException, ExecutionException {\nFuture<String> page = executor.submit(new RenderPageTask());\nframe.set(page.get());\n}\npublic class RenderPageTask implements Callable<String> {\n@Override\npublic String call() throws Exception {\nfinal Future<String> header = executor.submit(new LoadFileTask(\"head.html\"));\nfinal Future<String> foot = executor.submit(new LoadFileTask(\"foot.html\"));\nreturn header.get() + \"page\" + foot.get();\n}\n}', 1, '', 'D', 513);
INSERT INTO `option_info` VALUES (2068, '平台软件包再发布时，对软件包实施数字签名', 0, '', 'A', 514);
INSERT INTO `option_info` VALUES (2069, '产品在使用平台发布的文件前，应进行数字签名校验，确保产品使用的文件与平台发布的文件是一致的。', 0, '', 'B', 514);
INSERT INTO `option_info` VALUES (2070, '平台版本通过正式的发布渠道发布', 0, '', 'C', 514);
INSERT INTO `option_info` VALUES (2071, '平台版本不需要实施数字签名', 1, '', 'D', 514);
INSERT INTO `option_info` VALUES (2072, '版本在GA前已经达到了源码交付能力，所以源码加交付前直接提取即可，无需验证，小王没有错。', 0, '', 'A', 515);
INSERT INTO `option_info` VALUES (2073, '源代码与二进制版本的对应关系应该通过配置库、产品软件全量信息树等手段进行管理，不能靠人的责任心保障正确性。', 1, '', 'B', 515);
INSERT INTO `option_info` VALUES (2074, '源码交付时，小王及时发现所传递的源代码存在的问题并纠正，说明人工确认可以保障源码交付的准确性。', 0, '', 'C', 515);
INSERT INTO `option_info` VALUES (2075, '小王没有使用已基线的配套的源码标签进行提取导致源码提取错误是个人问题，流程保障、系统管理没有问题。', 0, '', 'D', 515);
INSERT INTO `option_info` VALUES (2076, '-werror', 0, '', 'A', 516);
INSERT INTO `option_info` VALUES (2077, '-nowarn', 1, '', 'B', 516);
INSERT INTO `option_info` VALUES (2078, '-Xlint:none', 1, '', 'C', 516);
INSERT INTO `option_info` VALUES (2079, '-X', 0, '', 'D', 516);
INSERT INTO `option_info` VALUES (2080, '可以查看java进程的内存使用情况', 0, '', 'A', 517);
INSERT INTO `option_info` VALUES (2081, '可以查看java系统参数', 1, '', 'B', 517);
INSERT INTO `option_info` VALUES (2082, '可以调整JVM参数', 0, '', 'C', 517);
INSERT INTO `option_info` VALUES (2083, '可以查看某个JVM参数', 0, '', 'D', 517);
INSERT INTO `option_info` VALUES (2084, '原则上，为区分自研与开源代码、确保使用和修改可追溯，开源修改的patch文件需要独立存放管理。', 0, '', 'A', 518);
INSERT INTO `option_info` VALUES (2085, '华为修改开源软件的patch代码量，必须严格控制，修改代码建议不超过5%。', 0, '', 'B', 518);
INSERT INTO `option_info` VALUES (2086, '开源软件社区发布的补丁要和自研修改的补丁做成一个patch进行统一管理。', 1, '', 'C', 518);
INSERT INTO `option_info` VALUES (2087, '基于开源软件修改的自研Patch中可以包含开源权利人声明', 0, '', 'D', 518);
INSERT INTO `option_info` VALUES (2088, '3', 1, '', 'A', 519);
INSERT INTO `option_info` VALUES (2089, '1', 0, '', 'B', 519);
INSERT INTO `option_info` VALUES (2090, '6', 0, '', 'C', 519);
INSERT INTO `option_info` VALUES (2091, '2', 0, '', 'D', 519);
INSERT INTO `option_info` VALUES (2092, 'runtime：只在运行时使用', 0, '', 'A', 520);
INSERT INTO `option_info` VALUES (2093, 'test：只在测试时使用，用于编译和运行测试代码。不会随项目发布', 0, '', 'B', 520);
INSERT INTO `option_info` VALUES (2094, 'provided：期望JDK,容器或使用者会提供这个依赖。如servlet.jar 。', 0, '', 'C', 520);
INSERT INTO `option_info` VALUES (2095, 'system：适用于所有阶段，会随着项目一起发布。', 1, '', 'D', 520);
INSERT INTO `option_info` VALUES (2096, '为了进行高效共享，老张应该在本地磁盘修改后，将架构设计文档的最新版本及时共享给项目组成员，而不需要提交统一的配置库', 0, '', 'A', 521);
INSERT INTO `option_info` VALUES (2097, '老张应该将该架构设计文档提交评审流程，评审通过后进行基线', 1, '', 'B', 521);
INSERT INTO `option_info` VALUES (2098, '架构设计文档是关键的配置项，老张应该对架构设计文档进行配置项识别，按照配置项管理要求归档在统一的配置中', 1, '', 'C', 521);
INSERT INTO `option_info` VALUES (2099, '老张要按照配置项命名规范对架构设计文档进行规范化命名，而不能随意命名为相似的名称', 1, '', 'D', 521);
INSERT INTO `option_info` VALUES (2100, 'static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid, high, key);\n} else {\nreturn recursive(arr, low, mid - 1, key);\n}\n}', 1, '', 'A', 522);
INSERT INTO `option_info` VALUES (2101, 'static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high + low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid - 1, high, key);\n} else {\nreturn recursive(arr, low, mid + 1, key);\n}\n}', 1, '', 'B', 522);
INSERT INTO `option_info` VALUES (2102, 'static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, mid + 1, high, key);\n} else {\nreturn recursive(arr, low, mid - 1, key);\n}\n}', 0, '', 'C', 522);
INSERT INTO `option_info` VALUES (2103, 'static int recursive(int arr[], int low, int high, int key)\n{\nif (low > high) {\nreturn -1;\n}\nint mid = low + (high - low) / 2;\nif (arr[mid] == key) {\nreturn mid;\n} else if (arr[mid] < key) {\nreturn recursive(arr, low, mid - 1, key);\n} else {\nreturn recursive(arr, mid + 1, high, key);\n}\n}', 1, '', 'D', 522);
INSERT INTO `option_info` VALUES (2104, 'line 1', 1, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'A', 523);
INSERT INTO `option_info` VALUES (2105, 'line 4', 0, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'B', 523);
INSERT INTO `option_info` VALUES (2106, 'line 7', 0, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'C', 523);
INSERT INTO `option_info` VALUES (2107, 'line 6', 0, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'D', 523);
INSERT INTO `option_info` VALUES (2108, 'line 2', 1, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'E', 523);
INSERT INTO `option_info` VALUES (2109, 'line 5', 0, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'F', 523);
INSERT INTO `option_info` VALUES (2110, 'line 3', 1, '解析：http://image.huawei.com/tiny-lts/v1/images/903b726cc77e34713b5d_491x205.jpg@900-0-90-f.jpg', 'G', 523);
INSERT INTO `option_info` VALUES (2111, '3', 1, '', 'A', 524);
INSERT INTO `option_info` VALUES (2112, '2', 0, '', 'B', 524);
INSERT INTO `option_info` VALUES (2113, '0', 1, '', 'C', 524);
INSERT INTO `option_info` VALUES (2114, '1', 1, '', 'D', 524);
INSERT INTO `option_info` VALUES (2115, '1.0', 1, '解析：Maven依赖冲突解决原则是 1) 最短路径优先 2）同路径先声明优先', 'A', 525);
INSERT INTO `option_info` VALUES (2116, '1.0和2.0都会被引入', 0, '解析：Maven依赖冲突解决原则是 1) 最短路径优先 2）同路径先声明优先', 'B', 525);
INSERT INTO `option_info` VALUES (2117, '无法确定', 0, '解析：Maven依赖冲突解决原则是 1) 最短路径优先 2）同路径先声明优先', 'C', 525);
INSERT INTO `option_info` VALUES (2118, '2.0', 0, '解析：Maven依赖冲突解决原则是 1) 最短路径优先 2）同路径先声明优先', 'D', 525);
INSERT INTO `option_info` VALUES (2119, '可以保护堆的不可执行', 0, '', 'A', 526);
INSERT INTO `option_info` VALUES (2120, '只能保护栈的不可执行', 1, '', 'B', 526);
INSERT INTO `option_info` VALUES (2121, '可有效提高缓冲区溢出的难度，但仍可以被ret2lib、rop等攻击绕过', 0, '', 'C', 526);
INSERT INTO `option_info` VALUES (2122, '不能保护段的不可执行', 0, '', 'D', 526);
INSERT INTO `option_info` VALUES (2123, '根据函数处理流程方法，即怎么做。', 0, '', 'A', 527);
INSERT INTO `option_info` VALUES (2124, '根据函数所要达到的目的，即做什么', 1, '', 'B', 527);
INSERT INTO `option_info` VALUES (2125, '根据函数的使用场景，即何时用', 0, '', 'C', 527);
INSERT INTO `option_info` VALUES (2126, '根据函数的输入参数决定，即对哪些', 0, '', 'D', 527);
INSERT INTO `option_info` VALUES (2127, '重构尽量以微小的步伐修改程序，直接重构一个模块是非常冒险的行为，需要谨慎应对。', 0, '', 'A', 528);
INSERT INTO `option_info` VALUES (2128, '程序“如果没有坏（功能可用），就不要去修复它”，是代码是否需要选择重构的必要条件。', 1, '', 'B', 528);
INSERT INTO `option_info` VALUES (2129, '重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。', 1, '', 'C', 528);
INSERT INTO `option_info` VALUES (2130, '重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。', 1, '', 'D', 528);
INSERT INTO `option_info` VALUES (2131, '使用各种有利于解耦的设计模式常常回导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。', 1, '', 'E', 528);
INSERT INTO `option_info` VALUES (2132, '开发初期如果一个类中有一个字段location表示位置信息，但随着不断迭代开发，发现该字段需要提取出小区、楼栋号、单元号、房间号甚至更多的其他信息，这时可以通过在该类中不断增加新接口来完成这些新增信息的提取处理。', 1, '', 'A', 529);
INSERT INTO `option_info` VALUES (2133, '对象取代数据值，就是要求对象尽可能使用更具体的子类表示该对象，避免用通用的父类来标识。', 0, '', 'B', 529);
INSERT INTO `option_info` VALUES (2134, '对于数据结构，要求封装出增、删、改、查和遍历接口，封装后的语义要更稳定，便于后续修改，且对上层业务不用感知。', 0, '', 'C', 529);
INSERT INTO `option_info` VALUES (2135, '使用类名调用静态方法，而不要使用实例或表达式来调用', 0, '', 'A', 530);
INSERT INTO `option_info` VALUES (2136, '方法的代码块嵌套过深，超过4层', 0, '', 'B', 530);
INSERT INTO `option_info` VALUES (2137, '对于返回数组或者容器的方法，应返回长度为0的数组或容器', 1, '', 'C', 530);
INSERT INTO `option_info` VALUES (2138, 'Person Name变量没有判断是否为null', 0, '', 'D', 530);
INSERT INTO `option_info` VALUES (2139, '类的字段', 1, '', 'A', 531);
INSERT INTO `option_info` VALUES (2140, '方法参数', 1, '', 'B', 531);
INSERT INTO `option_info` VALUES (2141, '方法', 1, '', 'C', 531);
INSERT INTO `option_info` VALUES (2142, '局部变量', 1, '', 'D', 531);
INSERT INTO `option_info` VALUES (2143, '全量全视角的软件信息树设计', 0, '', 'A', 532);
INSERT INTO `option_info` VALUES (2144, '软件架构设计', 1, '', 'B', 532);
INSERT INTO `option_info` VALUES (2145, '配置识别和配置控制', 0, '', 'C', 532);
INSERT INTO `option_info` VALUES (2146, '版本管理', 0, '', 'A', 533);
INSERT INTO `option_info` VALUES (2147, '分支管理', 0, '', 'B', 533);
INSERT INTO `option_info` VALUES (2148, '配置状态发布', 1, '', 'C', 533);
INSERT INTO `option_info` VALUES (2149, '管理配置库', 0, '', 'D', 533);
INSERT INTO `option_info` VALUES (2150, '完整性', 1, '', 'A', 534);
INSERT INTO `option_info` VALUES (2151, '正确性', 0, '', 'B', 534);
INSERT INTO `option_info` VALUES (2152, '一致性', 1, '', 'C', 534);
INSERT INTO `option_info` VALUES (2153, '可追溯性', 1, '', 'D', 534);
INSERT INTO `option_info` VALUES (2154, '根据实际的特性接口变更规则，通过便跟过流程更新已基线的特性设计文档', 1, '', 'A', 535);
INSERT INTO `option_info` VALUES (2155, '更新特性设计文档，更新后的设计文档归档在小名工作电脑的专属文件夹，并共享给相关模块的开发工程师进行参考', 0, '', 'B', 535);
INSERT INTO `option_info` VALUES (2156, '由于特性设计文档不参与版本构建，所以特性设计文档没有人查阅，不用更新', 0, '', 'C', 535);
INSERT INTO `option_info` VALUES (2157, '由于该特性设计文档已经基线，所以不能更新', 0, '', 'D', 535);
INSERT INTO `option_info` VALUES (2158, '为增强团队对产品的敬畏心，防止类似事故出现，引发事故的产品经理开发测试以及实施变更运维人员全年绩效不得超过B+', 0, '', 'A', 536);
INSERT INTO `option_info` VALUES (2159, '引入灰度发布，功能先对小范围用户开放，然后增量开放给其他用户', 1, '', 'B', 536);
INSERT INTO `option_info` VALUES (2160, '引入自动化测试，减少测试人员手工测试可能导致的错误', 1, '', 'C', 536);
INSERT INTO `option_info` VALUES (2161, '自动化产品的部署和回滚，降低失败对用户的影响时间', 1, '', 'D', 536);
INSERT INTO `option_info` VALUES (2162, '预生产环境数据准备要接近生产环境，可以更好的针对生产环境数据进行验证', 1, '', 'E', 536);
INSERT INTO `option_info` VALUES (2163, '系统设计方案缺少对B单板业务的自动故障检测和故障恢复功能，是造成业务长时间中断的主要原因', 1, '', 'A', 537);
INSERT INTO `option_info` VALUES (2164, '原设计方案缺少对异常报文的容器处理能力，是导致B单板业务全部中断的主要原因', 1, '', 'B', 537);
INSERT INTO `option_info` VALUES (2165, '“0”字节报文属于异常报文，应要求局方改善网络质量，而不是对A设备打补丁或升级软件', 0, '', 'C', 537);
INSERT INTO `option_info` VALUES (2166, '维护人员水平低，不应该只拔插单板，而应进行系统复位，完全恢复业务', 0, '', 'D', 537);
INSERT INTO `option_info` VALUES (2167, '机密性', 1, '', 'A', 538);
INSERT INTO `option_info` VALUES (2168, '完整性', 1, '', 'B', 538);
INSERT INTO `option_info` VALUES (2169, '可用性', 1, '', 'C', 538);
INSERT INTO `option_info` VALUES (2170, '可靠性', 0, '', 'D', 538);
INSERT INTO `option_info` VALUES (2171, '通过分析利益相关人的可信诉求而确定', 1, '', 'A', 539);
INSERT INTO `option_info` VALUES (2172, '客户需求就是可信目标', 0, '', 'B', 539);
INSERT INTO `option_info` VALUES (2173, '参考相关行业共识而确定', 1, '', 'C', 539);
INSERT INTO `option_info` VALUES (2174, '参考相关国际标准而确定', 1, '', 'D', 539);
INSERT INTO `option_info` VALUES (2175, '参考产品相关可信认证要求而确定', 1, '', 'E', 539);
INSERT INTO `option_info` VALUES (2176, '根据产品开发的安全部测试用例而确定', 0, '', 'F', 539);
INSERT INTO `option_info` VALUES (2177, '仿冒', 1, '', 'A', 540);
INSERT INTO `option_info` VALUES (2178, '篡改', 1, '', 'B', 540);
INSERT INTO `option_info` VALUES (2179, '抵赖', 1, '', 'C', 540);
INSERT INTO `option_info` VALUES (2180, '信息泄露', 1, '', 'D', 540);
INSERT INTO `option_info` VALUES (2181, '拒绝服务', 1, '', 'E', 540);
INSERT INTO `option_info` VALUES (2182, '权限提升', 1, '', 'F', 540);
INSERT INTO `option_info` VALUES (2183, '隐私', 0, '', 'G', 540);
INSERT INTO `option_info` VALUES (2184, '组件', 1, '', 'A', 541);
INSERT INTO `option_info` VALUES (2185, '接口', 1, '', 'B', 541);
INSERT INTO `option_info` VALUES (2186, '报文', 0, '', 'C', 541);
INSERT INTO `option_info` VALUES (2187, '参数', 0, '', 'D', 541);
INSERT INTO `option_info` VALUES (2188, '基于产品架构视图进行威胁分析', 1, '', 'A', 542);
INSERT INTO `option_info` VALUES (2189, '重点分析业务组件和接口', 1, '', 'B', 542);
INSERT INTO `option_info` VALUES (2190, '基于产品数据流进行威胁分析', 0, '', 'C', 542);
INSERT INTO `option_info` VALUES (2191, '重点识别产品特性安全威胁', 0, '', 'D', 542);
INSERT INTO `option_info` VALUES (2192, '战略级(strategy level)', 0, '', 'A', 543);
INSERT INTO `option_info` VALUES (2193, '组织级(organization level)', 1, '', 'B', 543);
INSERT INTO `option_info` VALUES (2194, '业务级(business level)', 1, '', 'C', 543);
INSERT INTO `option_info` VALUES (2195, '技术级(system level)', 1, '', 'D', 543);
INSERT INTO `option_info` VALUES (2196, '韧性(Resilience)', 1, '', 'A', 544);
INSERT INTO `option_info` VALUES (2197, '安全(Security)', 1, '', 'B', 544);
INSERT INTO `option_info` VALUES (2198, '隐私(Privacy)', 1, '', 'C', 544);
INSERT INTO `option_info` VALUES (2199, '安全(Safety)', 1, '', 'D', 544);
INSERT INTO `option_info` VALUES (2200, '可靠(Reliability)', 1, '', 'E', 544);
INSERT INTO `option_info` VALUES (2201, '可用(Availability)', 1, '', 'F', 544);
INSERT INTO `option_info` VALUES (2202, '完整性(Integrity)', 0, '', 'G', 544);
INSERT INTO `option_info` VALUES (2203, '可维护(Maintainability)', 0, '', 'H', 544);
INSERT INTO `option_info` VALUES (2204, '故障检测', 1, '', 'A', 545);
INSERT INTO `option_info` VALUES (2205, '故障诊断', 1, '', 'B', 545);
INSERT INTO `option_info` VALUES (2206, '故障隔离', 1, '', 'C', 545);
INSERT INTO `option_info` VALUES (2207, '故障恢复', 1, '', 'D', 545);
INSERT INTO `option_info` VALUES (2208, '不可关联性', 0, '', 'A', 546);
INSERT INTO `option_info` VALUES (2209, '可干预性', 1, '', 'B', 546);
INSERT INTO `option_info` VALUES (2210, '透明性', 0, '', 'C', 546);
INSERT INTO `option_info` VALUES (2211, '机密性', 0, '', 'D', 546);
INSERT INTO `option_info` VALUES (2212, '非持久性是在有限时间内保留信息，服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会', 0, '', 'A', 547);
INSERT INTO `option_info` VALUES (2213, '分割可以根据系统的重要级别进行划分，以限制成功攻击的传播和损害', 0, '', 'B', 547);
INSERT INTO `option_info` VALUES (2214, '权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配用户和网络实体的权限，以最大限度地减少对手活动潜在的后果。', 0, '', 'C', 547);
INSERT INTO `option_info` VALUES (2215, '多样性使用异构技术（例如，硬件，软件，固件，协议），这样增加了网络建设的成本，运维的难度，是不可取的', 1, '', 'D', 547);
INSERT INTO `option_info` VALUES (2216, '同一个预共享密钥，既可以用于认证，又可以用于完整性保护', 1, '', 'A', 548);
INSERT INTO `option_info` VALUES (2217, '一个密钥可以通过算法派生两个密钥，一个用于计算MAC值以验证数据的完整性，一个用于敏感数据加密以保证数据的机密性', 0, '', 'B', 548);
INSERT INTO `option_info` VALUES (2218, '分组密码算法中的某些工作模式，如GCM、CCM，可以同时提供加密和消息认证服务', 0, '', 'C', 548);
INSERT INTO `option_info` VALUES (2219, '数字签名可以同时提供身份认证、数据完整性以及抗抵赖服务', 0, '', 'D', 548);
INSERT INTO `option_info` VALUES (2220, '身份管理和访问控制、数据安全、信息保护流程和步骤、安全运维', 1, '解析：Half of the people think the answer is ABD and the other half think the answer is ABCD(source)\n15 CSF(Cybersecurity Framework)核心框架包含5个功能IPDRR，其中P代表保护功能（Protect Function），保护功能可以限制或抑制网络安全事件的潜在影响。以下哪一组全部属于核心架构中的保护功能项(A)\nB. 身份管理和访问控制、数据安全、安全运维、安全连续监控\nC. 身份管理和访问控制、数据安全、安全运维、风险评估\nD. 身份管理和访问控制、数据安全、信息保护流程和步骤、安全连续监控', 'A', 549);
INSERT INTO `option_info` VALUES (2221, 'FMEA分析表', 1, '解析：安全编码Top问题\n17 FMEA是一种可靠性分析方法，可以用于产品的设计阶段。下列哪个选项不是设计阶段FMEA分析的输出(D)\nB. 软件故障需求管理\nC. 硬件故障需求管理\nD. 软件功能需求', 'A', 550);
INSERT INTO `option_info` VALUES (2222, '拒绝所有业务', 0, '', 'A', 551);
INSERT INTO `option_info` VALUES (2223, '接入所有业务', 0, '', 'B', 551);
INSERT INTO `option_info` VALUES (2224, '服务降级', 1, '', 'C', 551);
INSERT INTO `option_info` VALUES (2225, '复位系统', 0, '', 'D', 551);
INSERT INTO `option_info` VALUES (2226, '偶然失效期', 1, '', 'A', 552);
INSERT INTO `option_info` VALUES (2227, '早期失效期', 1, '', 'B', 552);
INSERT INTO `option_info` VALUES (2228, '生产失效期', 0, '', 'C', 552);
INSERT INTO `option_info` VALUES (2229, '耗损失效期', 1, '', 'D', 552);
INSERT INTO `option_info` VALUES (2230, '市场失效期', 0, '', 'E', 552);
INSERT INTO `option_info` VALUES (2231, '进程间通信（包括管道、消息、共享内存、socket、RPC等）', 1, '', 'A', 553);
INSERT INTO `option_info` VALUES (2232, '函数参数（对于API）、全局变量（在本函数内，其它线程会修改全局变量）', 1, '', 'B', 553);
INSERT INTO `option_info` VALUES (2233, '用户输入（包括命令行、界面）、用户态数据（对于内核程序）', 1, '', 'C', 553);
INSERT INTO `option_info` VALUES (2234, '文件（包括程序的配置文件）、注册表、网络、环境变量', 1, '', 'D', 553);
INSERT INTO `option_info` VALUES (2235, '资产的购买价值', 0, '', 'A', 554);
INSERT INTO `option_info` VALUES (2236, '已有的风险消减措施', 0, '', 'B', 554);
INSERT INTO `option_info` VALUES (2237, '社会工程', 0, '', 'C', 554);
INSERT INTO `option_info` VALUES (2238, '安全风险发生可能性和业务影响性', 1, '', 'D', 554);
INSERT INTO `option_info` VALUES (2239, '决定个人数据处理的目的及方式', 1, '', 'A', 555);
INSERT INTO `option_info` VALUES (2240, '管理数据分配时间', 0, '', 'B', 555);
INSERT INTO `option_info` VALUES (2241, '管理访问数据权限', 0, '', 'C', 555);
INSERT INTO `option_info` VALUES (2242, '决定数据存储方式', 0, '', 'D', 555);
INSERT INTO `option_info` VALUES (2243, '作为数据处理者的法国供应商，基于成本考虑将数据转移到德国处理', 1, '', 'A', 556);
INSERT INTO `option_info` VALUES (2244, '在中国的维护终端上，远程查看和分析德国服务器上的个人数据', 0, '', 'B', 556);
INSERT INTO `option_info` VALUES (2245, '德国子公司的个人数据传输到俄罗斯处理', 0, '', 'C', 556);
INSERT INTO `option_info` VALUES (2246, '德国子公司个人数据传输到美国处理', 0, '', 'D', 556);
INSERT INTO `option_info` VALUES (2247, '冗余系统中，主备用模块的故障都需要检测，避免静默故障', 0, '', 'A', 557);
INSERT INTO `option_info` VALUES (2248, '对于不引起系统故障只导致系统或服务KPI下降的亚健康异常不需要检测', 1, '', 'B', 557);
INSERT INTO `option_info` VALUES (2249, '故障定时检测的周期，需综合考虑对CPU占用率的影响和检测延迟对业务恢复速度的影响', 0, '', 'C', 557);
INSERT INTO `option_info` VALUES (2250, '应及时监控有特殊寿命（如Flash有撰写次数限制）要求的器件健康状态，通过提前预警采取维护措施', 0, '', 'D', 557);
INSERT INTO `option_info` VALUES (2251, '为反击取证和提供支撑', 0, '', 'A', 558);
INSERT INTO `option_info` VALUES (2252, '消耗攻击者的攻击能力和时间，为联动防御或反制等提供时间差', 0, '', 'B', 558);
INSERT INTO `option_info` VALUES (2253, '发现正在进行的攻击和潜在实施的攻击', 0, '', 'C', 558);
INSERT INTO `option_info` VALUES (2254, '将系统进行划分，以限制成功攻击的传播和损害', 1, '', 'D', 558);
INSERT INTO `option_info` VALUES (2255, '单板重启', 0, '', 'A', 559);
INSERT INTO `option_info` VALUES (2256, '软件复位', 0, '', 'B', 559);
INSERT INTO `option_info` VALUES (2257, '时间检查（如：心跳检测）', 1, '', 'C', 559);
INSERT INTO `option_info` VALUES (2258, '隔离仓设计', 0, '', 'D', 559);
INSERT INTO `option_info` VALUES (2259, '所有的软件bug都会导致安全漏洞', 1, '', 'A', 560);
INSERT INTO `option_info` VALUES (2260, '从成本上考虑，在验证阶段发现多数bug是比较好的', 0, '', 'B', 560);
INSERT INTO `option_info` VALUES (2261, '多数的安全bug不重要，因为攻击者不可能注意到', 0, '', 'C', 560);
INSERT INTO `option_info` VALUES (2262, '所有的软件都有bug，只有一些bug才是安全漏洞', 0, '', 'D', 560);
INSERT INTO `option_info` VALUES (2263, '最优惠的价格', 0, '', 'A', 561);
INSERT INTO `option_info` VALUES (2264, '设备平稳运行', 0, '', 'B', 561);
INSERT INTO `option_info` VALUES (2265, '网络安全', 1, '', 'C', 561);
INSERT INTO `option_info` VALUES (2266, '隐私保护', 1, '', 'D', 561);
INSERT INTO `option_info` VALUES (2267, '数据级', 1, '', 'A', 562);
INSERT INTO `option_info` VALUES (2268, '应用级', 1, '', 'B', 562);
INSERT INTO `option_info` VALUES (2269, '业务级', 1, '', 'C', 562);
INSERT INTO `option_info` VALUES (2270, '代码级', 0, '', 'D', 562);
INSERT INTO `option_info` VALUES (2271, '差分隐私', 1, '', 'A', 563);
INSERT INTO `option_info` VALUES (2272, '枚举', 0, '', 'B', 563);
INSERT INTO `option_info` VALUES (2273, '截断', 0, '', 'C', 563);
INSERT INTO `option_info` VALUES (2274, '掩码', 0, '', 'D', 563);
INSERT INTO `option_info` VALUES (2275, '　自保恢复原则：负荷下降到设计能力范围之内后，网元可以立即恢复处理能力', 0, '', 'A', 564);
INSERT INTO `option_info` VALUES (2276, '　业务保证原则：确保在出现大流量冲击时所有业务不被丢弃', 1, '', 'B', 564);
INSERT INTO `option_info` VALUES (2277, '　及早控制原则：应尽可能在业务流程处理前端或业务处理较早的处理单元（网元/单板/芯片等）或底层协议层次上控制业务接入', 0, '', 'C', 564);
INSERT INTO `option_info` VALUES (2278, '　优先级保证原则：系统过载时保证高优先级的业务能够优先获得资源，优先得到处理', 0, '', 'D', 564);
INSERT INTO `option_info` VALUES (2279, '不利情况发生后恢复业务', 1, '', 'A', 565);
INSERT INTO `option_info` VALUES (2280, '不利情况下维持核心业务', 1, '', 'B', 565);
INSERT INTO `option_info` VALUES (2281, '限制不利情况发生时的损害', 1, '', 'C', 565);
INSERT INTO `option_info` VALUES (2282, '降低攻击成功可能性', 1, '', 'D', 565);
INSERT INTO `option_info` VALUES (2283, '动态分析和Fuzz测试', 0, '', 'A', 566);
INSERT INTO `option_info` VALUES (2284, '测试方案设计', 1, '', 'B', 566);
INSERT INTO `option_info` VALUES (2285, '总体测试策略', 0, '', 'C', 566);
INSERT INTO `option_info` VALUES (2286, '静态分析', 0, '', 'D', 566);
INSERT INTO `option_info` VALUES (2287, '通过故障预测预防，用户可以根据故障出现的概率以及出现的位置，采取相应的手段提前避免这些有可能出现的故障', 0, '', 'A', 567);
INSERT INTO `option_info` VALUES (2288, '故障预测预防是一种被动故障处理技术', 1, '', 'B', 567);
INSERT INTO `option_info` VALUES (2289, '故障预测预防技术是一种有效的主动故障处理技术', 0, '', 'C', 567);
INSERT INTO `option_info` VALUES (2290, '故障预测可以在系统故障出现之前，通过分析系统的状态得到故障可能出现的概率以及出现的故障种类\"', 0, '', 'D', 567);
INSERT INTO `option_info` VALUES (2291, '在研发过程中对各个环节的关键基础设施落地严格的风险应对措施，如对代码仓尽心更严格的访问、完整性方案设计，保障产品软件开发过程的完整性，一致性，不因恶意篡改导致最终的功能特性与客户预期不相符，设置损害客户利益', 1, '', 'A', 568);
INSERT INTO `option_info` VALUES (2292, '产品要做到结果风险可控，须通过有效执行研发过程的安全活动控制项要求。', 1, '', 'B', 568);
INSERT INTO `option_info` VALUES (2293, '产品要做到具备威胁无处不在的视角，通过有效的基础设施及环境保护应对研发过程恶意篡改风险。', 1, '', 'C', 568);
INSERT INTO `option_info` VALUES (2294, '通过后端测试保证产品质量即可，研发过程风险无须过多关注', 0, '', 'D', 568);
INSERT INTO `option_info` VALUES (2295, '基于故障机理模型的故障预测', 1, '', 'A', 569);
INSERT INTO `option_info` VALUES (2296, '基于代码的故障预测', 0, '', 'B', 569);
INSERT INTO `option_info` VALUES (2297, '基于文档的故障预测', 0, '', 'C', 569);
INSERT INTO `option_info` VALUES (2298, '基于数据驱动的故障预测', 1, '', 'D', 569);
INSERT INTO `option_info` VALUES (2299, '重试设计', 1, '', 'A', 570);
INSERT INTO `option_info` VALUES (2300, '故障域划分设计', 0, '', 'B', 570);
INSERT INTO `option_info` VALUES (2301, '隔离舱设计', 0, '', 'C', 570);
INSERT INTO `option_info` VALUES (2302, '断路器隔离设计', 0, '', 'D', 570);
INSERT INTO `option_info` VALUES (2303, '一个账号或账号组只能拥有必须的角色和必须的权限，一个角色只能拥有必需的权限，不分配不必要的权限，符合“权限最小化原则”', 1, '', 'A', 571);
INSERT INTO `option_info` VALUES (2304, '账户登录失败N此后可以暂时锁定账户X分钟，符合“失败-默认安全原则”', 1, '', 'B', 571);
INSERT INTO `option_info` VALUES (2305, '对资源访问的共享数量和使用应尽可能最小化，符合“最小公共化原则”', 1, '', 'C', 571);
INSERT INTO `option_info` VALUES (2306, '将直接对外交互的高权限高风险进程拆分为两个进程，一个负责外部交互，一个负责内部业务逻辑，符合“权限分离原则”', 1, '', 'D', 571);
INSERT INTO `option_info` VALUES (2307, '产品架构采用必要的冗余设计措施', 1, '', 'A', 572);
INSERT INTO `option_info` VALUES (2308, '冗余设计相关的要素如故障检测和回复措施得到合理设计和验证', 1, '', 'B', 572);
INSERT INTO `option_info` VALUES (2309, '采用更高可靠性等级的器件', 1, '', 'C', 572);
INSERT INTO `option_info` VALUES (2310, '采用必要的简化设计措施，降低复杂度', 1, '', 'D', 572);
INSERT INTO `option_info` VALUES (2311, '容灾指除了生产站点以外，用户另外建立的冗余站点，当灾难发生后，生产站点受到破坏时，冗余站点管用户业务', 0, '', 'A', 573);
INSERT INTO `option_info` VALUES (2312, '容灾设计重点在于业务接管，数据可靠性不是其重点', 1, '', 'B', 573);
INSERT INTO `option_info` VALUES (2313, '衡量容灾系统的主要指标有RPO和RTO', 0, '', 'C', 573);
INSERT INTO `option_info` VALUES (2314, '容灾系统包括三个级别：数据级、应用级和业务级', 0, '', 'D', 573);
INSERT INTO `option_info` VALUES (2315, '冗余系统如果发生了影响业务的软、硬件故障后，应能通过主备倒换或符合分担实现自动的故障恢复', 1, '', 'A', 574);
INSERT INTO `option_info` VALUES (2316, '在非冗余系统中，对于影响业务的软件故障或硬件故障瞬间故障，可通过自动触发单板复位或局部复位等方式，系统恢复正常状态', 1, '', 'B', 574);
INSERT INTO `option_info` VALUES (2317, '系统自动执行故障恢复动作，可大大减少业务中断时间，但注意一定要保证判断的准确性，避免误动作。同需要在系统设计复杂性和减少业务中断时间之间权衡', 1, '', 'C', 574);
INSERT INTO `option_info` VALUES (2318, '通常的故障恢复技术包括进程复位、主备倒换', 0, '', 'D', 574);
INSERT INTO `option_info` VALUES (2319, '保证信息传输过程中的完整性', 0, '', 'A', 575);
INSERT INTO `option_info` VALUES (2320, '保证数据传输的机密性', 1, '', 'B', 575);
INSERT INTO `option_info` VALUES (2321, '发送者身份认证', 0, '', 'C', 575);
INSERT INTO `option_info` VALUES (2322, '防止交易中的抵赖行为发生', 0, '', 'D', 575);
INSERT INTO `option_info` VALUES (2323, '不修改使用', 0, '', 'A', 576);
INSERT INTO `option_info` VALUES (2324, '自研修改部分开源', 0, '', 'B', 576);
INSERT INTO `option_info` VALUES (2325, '动态链接使用，或者进程隔离', 1, '', 'C', 576);
INSERT INTO `option_info` VALUES (2326, '软件有明确的许可证或签订有相关使用协议', 0, '', 'A', 577);
INSERT INTO `option_info` VALUES (2327, '对于开源软件履行开源义务，避免导致产品开源或公司声誉受损', 0, '', 'B', 577);
INSERT INTO `option_info` VALUES (2328, '产品使用第三方软件须先使用后申请', 1, '', 'C', 577);
INSERT INTO `option_info` VALUES (2329, '建立优选库路标库，减少种类和数量，牵引使用优选软件，禁选软件禁止使用', 0, '', 'D', 577);
INSERT INTO `option_info` VALUES (2330, '已知安全问题及漏洞扫描，如：对业界公开的严重级别的安全漏洞已修复', 1, '', 'A', 578);
INSERT INTO `option_info` VALUES (2331, '病毒扫描', 1, '', 'B', 578);
INSERT INTO `option_info` VALUES (2332, '软件完整性及一致性检查', 1, '', 'C', 578);
INSERT INTO `option_info` VALUES (2333, '高风险模块静态代码扫描分析和代码人工检视', 0, '', 'D', 578);
INSERT INTO `option_info` VALUES (2334, '产品在TR4前必须进行开源认证', 1, '', 'A', 579);
INSERT INTO `option_info` VALUES (2335, '产品使用开源及第三方软件必须先申请后使用', 0, '', 'B', 579);
INSERT INTO `option_info` VALUES (2336, '在产品发布前，需进行开源认证', 0, '', 'C', 579);
INSERT INTO `option_info` VALUES (2337, '开源软件中心会定期将开源软件漏洞通知到产品', 0, '', 'D', 579);
INSERT INTO `option_info` VALUES (2338, '开源入库选型—>开源使用申请—>开源认证—>开源义务履行—>漏洞闭环处理', 1, '', 'A', 580);
INSERT INTO `option_info` VALUES (2339, '如果需要使用优选等级为‘DXX（禁选）’或者EOX的软件，或者应用技术风险为‘高’的软件，需要提供对应备案纪要', 1, '', 'A', 581);
INSERT INTO `option_info` VALUES (2340, '优先使用优选等级为‘B （优选）’的版本', 1, '', 'B', 581);
INSERT INTO `option_info` VALUES (2341, '不允许使用应用技术风险为‘高’的软件', 1, '', 'C', 581);
INSERT INTO `option_info` VALUES (2342, '不允许使用优选等级为‘DXX（禁选）’和EOX的软件', 1, '', 'D', 581);
INSERT INTO `option_info` VALUES (2343, '如果待入库的的开源及第三方软件在PDM中已存在，需要引入新版本', 1, '', 'A', 582);
INSERT INTO `option_info` VALUES (2344, '如果待入库的开源及第三方软件在PDM中已存在，且版本号未更新，但供应商因为修改bug等原因更新了软件包', 1, '', 'B', 582);
INSERT INTO `option_info` VALUES (2345, '如果待入库的开源及第三方软件在PDM中不存在', 1, '', 'C', 582);
INSERT INTO `option_info` VALUES (2346, '供应商提供的软件包本身没有变化，且已经入库PDM，我司人员在其上进行的二次开发/编译的部分需要入库PDM', 0, '', 'D', 582);
INSERT INTO `option_info` VALUES (2347, 'XXXX master', 0, '', 'A', 583);
INSERT INTO `option_info` VALUES (2348, 'XXXX 1.1.11-beta', 0, '', 'B', 583);
INSERT INTO `option_info` VALUES (2349, 'XXXX.3..19', 1, '', 'C', 583);
INSERT INTO `option_info` VALUES (2350, 'XXXX.1.1.12rc2', 0, '', 'D', 583);
INSERT INTO `option_info` VALUES (2351, '客户要求使用开源软件新版本，产品A集成使用的开源软件B近3年无人维护且无可代替软件，产品A将该开源软件B及修改的代码在GitHub以新项目C开源并自行维护，再将开源软件C集成到产品A中使用。', 1, '', 'A', 584);
INSERT INTO `option_info` VALUES (2352, '产品A使用的开源软件被爆出存在严重漏洞(CVSSL>7)，产品A的安全SE分析发现该漏洞涉及的代码产品A未调用，可以不需要对产品A的现网版本打补丁。', 1, '', 'B', 584);
INSERT INTO `option_info` VALUES (2353, '产品A软件开发人员在编写代码时，拷贝Apache license 2.0的XXC++开源软件中的排序算法实现代码，以提升开发效率。', 1, '', 'C', 584);
INSERT INTO `option_info` VALUES (2354, '某产品共130K行代码，其中仅10行diamante与开源代码相似度较高；该10行代码可以确认为自研代码。', 1, '', 'D', 584);
INSERT INTO `option_info` VALUES (2355, '开源软件的选用，是产品在需求分析和架构设计时决定的；产品需基于全量全视角视图管理产品和平台使用的开源及第三方软件，确保使用的开源及第三方版本归一和满足生命周期需求。', 0, '', 'E', 584);
INSERT INTO `option_info` VALUES (2356, '产品A自研开发且对外开源XXComb软件，并捐献到Apache基金会成为顶级项目，产品B选用社区XXComb软件，仍应认定XXComb软件为自研软件。', 1, '解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD', 'A', 585);
INSERT INTO `option_info` VALUES (2357, '某产品开发一款仅给内部一线行销员工使用的APP（必须华为员工账号才能使用），并上架华为手机应用市场供一线行销人员下载，该APP通过静态链接方式集成使用了一款AGPL开源软件，由于只是内部一线行销员工使用，可以不需要履行开源义务。', 1, '解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD', 'B', 585);
INSERT INTO `option_info` VALUES (2358, '某员工在业余时间以个人名义，在GitHub开源了X项目；该员工在公司办公环境下载该X项目代码集成到产品A中使用，产品A不需要履行开源义务。', 1, '解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD', 'C', 585);
INSERT INTO `option_info` VALUES (2359, '公有云服务产品A通过静态链接的方式集成使用了license为GPL V2.0的开源软件，服务产品A可以不履行代码开源义务。', 1, '解析：Some(b8398575, b8338303) think the answer is ABD while others(b8325823, b8302521, b8214821) think the answer is ABCD', 'D', 585);
INSERT INTO `option_info` VALUES (2360, '已EOSS/即将停止销售的第三方软件不建议引入', 0, '解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353', 'A', 586);
INSERT INTO `option_info` VALUES (2361, '业界无替代的第三方软件，可能存在供应风险，不建议引入', 1, '解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353', 'B', 586);
INSERT INTO `option_info` VALUES (2362, '未签署供应商网络安全协议的软件禁止引入', 1, '解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353', 'C', 586);
INSERT INTO `option_info` VALUES (2363, '供应商发布的软件正式版本，可以引入', 0, '解析：BC - b8302521, b8194499\nBCD - b8299143, b8262667, b8262667\nABC - b8214821, b8186353', 'D', 586);
INSERT INTO `option_info` VALUES (2364, '为保证来源可靠，业务版本使用的开源及第三方软件必须来自保存在华为PDM库中的软件副本', 1, '', 'A', 587);
INSERT INTO `option_info` VALUES (2365, 'A类红线和高风险(CVSS评分>=7)的B类红线问题在版本发布前解决或规避，中低风险(CVSS评分<7)的B类红线问题则可待供应商/合作方修复后再同步其修复版本', 1, '', 'B', 587);
INSERT INTO `option_info` VALUES (2366, '非A/B类红线安全问题，如果是高风险的安全问题则在版本发布前解决或规避，如果是中低风险的安全问题可待供应商/合作方修复后再同步其修复版本', 1, '', 'C', 587);
INSERT INTO `option_info` VALUES (2367, '在业务版本的研发过程中，开源及第三方软件需随产品代码一起开源产品网络安全测试', 1, '', 'D', 587);
INSERT INTO `option_info` VALUES (2368, '若无法直接进程隔离，则可制作隔离层，将该软件包装为一个进程（需开源），通过隔离层进行交互', 0, '', 'A', 588);
INSERT INTO `option_info` VALUES (2369, '在内核态中对Linux kernel进行调用，以避免GPL传染', 0, '', 'B', 588);
INSERT INTO `option_info` VALUES (2370, '可以采用进程隔离方式使用，即产品与GPL软件在不同进程中运行，通过进程间通信进行交互', 0, '', 'C', 588);
INSERT INTO `option_info` VALUES (2371, '以动态链接的方式使用GPL软件，使产品代码不会被GPL传染', 1, '', 'D', 588);
INSERT INTO `option_info` VALUES (2372, '修改的OpenSSL软件源码如果得到作者的认可，产品可以不用回馈社区直接引入选型OpenSSL', 0, '', 'A', 589);
INSERT INTO `option_info` VALUES (2373, '从官网下载OpenSSL源码太麻烦，可以直接使用git命令下载github上的openssl源码', 0, '', 'B', 589);
INSERT INTO `option_info` VALUES (2374, 'openssl-fips是OpenSSL的一个分支开源的独立项目，应该以新软件的方式引入', 1, '', 'C', 589);
INSERT INTO `option_info` VALUES (2375, '可以从任意网站下载OpenSSL源码包，只要扫描不出病毒', 0, '', 'D', 589);
INSERT INTO `option_info` VALUES (2376, '产品P引入XX开源软件，工程师小A分析&应用后认为将XX软件的其中几个接口再重新封装成新接口，可以更好支撑业务，于是小A在XX软件代码文件中新增一个功能接口，并且归档到开源软件目录支撑产品编译发布', 0, '', 'A', 590);
INSERT INTO `option_info` VALUES (2377, '产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，将开源软件归到开源代码目录，并通过部分编译的形式，仅编译需要的特性进行打包发布', 1, '', 'B', 590);
INSERT INTO `option_info` VALUES (2378, '产品P引入XX开源软件，工程师小A分析&应用后认为需要对开源代码进行少量修改才能满足产品需求，通过团队架构评审等确认后，将修改代码以Patch的方式进行管理', 1, '', 'C', 590);
INSERT INTO `option_info` VALUES (2379, '产品P引入XX开源软件，工程师小A分析&应用后确认只使用其中2个特性，于是将其它特性代码删除后，归档到开源代码目录支撑产品编译发布', 0, '', 'D', 590);
INSERT INTO `option_info` VALUES (2380, '判断原则是基于工具，如果FOSSID无法扫描出来，则都是自研代码', 0, '', 'A', 591);
INSERT INTO `option_info` VALUES (2381, '判断原则是基于事实，没看过开源代码的人写出来的东西叫自研，其他任何形式直接参考开源写的代码都算开源', 1, '', 'B', 591);
INSERT INTO `option_info` VALUES (2382, '判断原则是基于目录结构，自研目录下的都是自研代码，open_source目录下都是开源软件', 0, '', 'C', 591);
INSERT INTO `option_info` VALUES (2383, '判断原则是相似度，如果相似度很低，如低于5%可以判断为自研', 0, '', 'D', 591);
INSERT INTO `option_info` VALUES (2384, '切换第三方版本X的新版本，确保能享受供应商完整的保障能力', 1, '解析：b8299143 chooses C whereas others(b8302521, b8338303, b8395535, b8214821, b8194499, b8186353, b8194499) chooseA', 'A', 592);
INSERT INTO `option_info` VALUES (2385, '由于不是新产品，不考虑升级第三方软件X新版本', 0, '解析：b8299143 chooses C whereas others(b8302521, b8338303, b8395535, b8214821, b8194499, b8186353, b8194499) chooseA', 'B', 592);
INSERT INTO `option_info` VALUES (2386, '考虑测试成本，通过购买供应商延长维保服务，继续使用X的老版本', 0, '解析：b8299143 chooses C whereas others(b8302521, b8338303, b8395535, b8214821, b8194499, b8186353, b8194499) chooseA', 'C', 592);
INSERT INTO `option_info` VALUES (2387, '由于架构未调整，不考虑升级第三方软件X新版本', 0, '解析：b8299143 chooses C whereas others(b8302521, b8338303, b8395535, b8214821, b8194499, b8186353, b8194499) chooseA', 'D', 592);
INSERT INTO `option_info` VALUES (2388, '软件编码与构建', 1, '', 'A', 593);
INSERT INTO `option_info` VALUES (2389, '需求分析与设计', 1, '', 'B', 593);
INSERT INTO `option_info` VALUES (2390, '现网部署', 0, '', 'C', 593);
INSERT INTO `option_info` VALUES (2391, '验证发布', 1, '', 'D', 593);
INSERT INTO `option_info` VALUES (2392, '在社区邮件列表/issue列表里充分交流提交的方案，并根据意见反复修改', 0, '', 'A', 594);
INSERT INTO `option_info` VALUES (2393, '在社区线下会议上介绍自己的方案，赢得社区的认可', 0, '', 'B', 594);
INSERT INTO `option_info` VALUES (2394, '和社区维护者进行沟通，理解对方的规划思路', 0, '', 'C', 594);
INSERT INTO `option_info` VALUES (2395, '由于社区一直未采纳提交补丁，自己在社区中fork一个新项目出来维护', 1, '', 'D', 594);
INSERT INTO `option_info` VALUES (2396, '铲平A使用一款tinyxml软件，内存分配和解析速度均可满足产品要求，且现网已稳定运行10+年，社区近期发布了tinyxml2，且社区也表示后续主要在tinyxml2上进行维护，其解析速度为tinyxml的5倍，但综合考虑升级成本及新版本的影响，产品确定继续使用tinyxml', 0, '', 'A', 595);
INSERT INTO `option_info` VALUES (2397, 'Json-lib软件社区2013年后社区已无人贡献，建议产品独臂Jackson、fastJson、Gson等同类软件，结合产品使用场景，选择生态、license较友好的开源软件', 1, '', 'B', 595);
INSERT INTO `option_info` VALUES (2398, 'XML解析开源软件SAX性能比Dom4j快10倍，SAX 2004年发布最后一个稳定版本，当前平均每周下载量34+次，对性能要求较高，且使用场景为只读不写（xml文件）的产品可以考虑选择此软件', 0, '', 'C', 595);
INSERT INTO `option_info` VALUES (2399, 'Log4j日志组件的作者2015年发布log4j2.X和logback；性能比log4j1.X高10倍，建议使用log4j1.X的产品考虑切换到log2.X或logback', 1, '', 'D', 595);
INSERT INTO `option_info` VALUES (2400, '原则上只要使用了开源软件，就需要履行开源使用声明义务。', 0, '', 'A', 596);
INSERT INTO `option_info` VALUES (2401, '代码对外开源义务是值按照开源许可证要求将一定范围内的代码对外开源，开源范围视具体许可证要求的和产品使用具体方式而定。', 0, '', 'B', 596);
INSERT INTO `option_info` VALUES (2402, '修改声明是指公司做出的对修改过的开源软件就修改期间，修改的代码以及修改过的文件做出声明，无强制要求产品执行，但建议产品在修改GPL/LGPL类开源软件时，履行该义务。', 0, '', 'C', 596);
INSERT INTO `option_info` VALUES (2403, '不同许可证的开源代码不存在兼容性问题(如GPL License与BSD License)，只需要申请后即可按规范使用。', 1, '', 'D', 596);
INSERT INTO `option_info` VALUES (2404, '通过BepKit辅助消除python编译pyc文件时引入的时间差异', 0, '', 'A', 597);
INSERT INTO `option_info` VALUES (2405, '为消除自验代码中时间宏引入的二进制差异，可以选择删除DATE/TIME宏，并测试删除后是否影响业务功能', 0, '', 'B', 597);
INSERT INTO `option_info` VALUES (2406, '对于arj等压缩引入二进制差异的情况，可以通过反解的方式辅助进行差异消除', 0, '', 'C', 597);
INSERT INTO `option_info` VALUES (2407, 'gcc lto优化引入二进制差异，直接删除lto优化选项消除差异，无需对业务性能进行测试', 1, '', 'D', 597);
INSERT INTO `option_info` VALUES (2408, '合法合规', 1, '', 'A', 598);
INSERT INTO `option_info` VALUES (2409, '网络安全风险', 1, '', 'B', 598);
INSERT INTO `option_info` VALUES (2410, '生命周期情况', 1, '', 'C', 598);
INSERT INTO `option_info` VALUES (2411, '开源软件的技术生态', 1, '', 'D', 598);
INSERT INTO `option_info` VALUES (2412, 'BSD类license，如Apache/BSD/MIT等，原则上没有对外开源要求', 1, '', 'A', 599);
INSERT INTO `option_info` VALUES (2413, 'MPL类软件若无修改，则无需对外开源', 1, '', 'B', 599);
INSERT INTO `option_info` VALUES (2414, 'GPL软件本身须开源，且具有传染性，与该软件在同一进程中运行的代码都必须对外开源', 1, '', 'C', 599);
INSERT INTO `option_info` VALUES (2415, 'LGPL软件本身须开源，且具有传染性，与其动态链接部分的代码也必须以LGPL许可开源；静态链接则不被传染', 0, '', 'D', 599);
INSERT INTO `option_info` VALUES (2416, '假定软件A的License为GPL V2，软件B的License为BSD类，由于GPL V2的License可能导致产品整体被迫开源，而BSD类License商业更为友好，所以推荐使用软件B', 1, '', 'A', 600);
INSERT INTO `option_info` VALUES (2417, '假定软件B的License为LGPL V2，如果选择软件B，为防止自研代码被传染，则只允许动态链接方式使用', 1, '', 'B', 600);
INSERT INTO `option_info` VALUES (2418, '假定软件A的License为MPL类，如果选择软件A，则必须关注修改后对应的开源义务', 1, '', 'C', 600);
INSERT INTO `option_info` VALUES (2419, '假定软件A的License为Apache V2.0，软件B的License为WTFPL，虽然Apache V2.0 License的商业比较友好，但WTFPL的License限制更少，所以建议选择软件B', 0, '', 'D', 600);
INSERT INTO `option_info` VALUES (2420, 'B+树通常用于数据库和操作系统的文件系统中', 0, '', 'A', 601);
INSERT INTO `option_info` VALUES (2421, '非叶子节点中的每个索引顼通常只含有对应子树的最大关键字和指向该子树的指针', 0, '', 'B', 601);
INSERT INTO `option_info` VALUES (2422, '在B+树中的所有非叶子节点不仅起到索引的作用，还可以直接在非叶子节点中词到每个关键字对应的value', 1, '', 'C', 601);
INSERT INTO `option_info` VALUES (2423, 'B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度', 0, '', 'D', 601);
INSERT INTO `option_info` VALUES (2424, '若v不是T1的叶节点，则T1与T3可能不同', 1, '', 'A', 602);
INSERT INTO `option_info` VALUES (2425, '若v不是T1的叶节点，则T1与T3相同', 0, '', 'B', 602);
INSERT INTO `option_info` VALUES (2426, '若v是T1的叶节点，则T1与T3不同', 0, '', 'C', 602);
INSERT INTO `option_info` VALUES (2427, '若v是T1的叶节点，则T1与T3相同', 1, '', 'D', 602);
INSERT INTO `option_info` VALUES (2428, 'j-i+1', 0, '', 'A', 603);
INSERT INTO `option_info` VALUES (2429, 'i-j', 0, '', 'B', 603);
INSERT INTO `option_info` VALUES (2430, 'i-j-1', 0, '', 'C', 603);
INSERT INTO `option_info` VALUES (2431, '不确定', 1, '', 'D', 603);
INSERT INTO `option_info` VALUES (2432, '顺序表插入变动的时间复杂度为O(n)', 1, '', 'A', 604);
INSERT INTO `option_info` VALUES (2433, '顺序表按下表查找的时间复杂度为O(1)', 1, '', 'B', 604);
INSERT INTO `option_info` VALUES (2434, '顺序表在使用时，长度可随意变动', 0, '', 'C', 604);
INSERT INTO `option_info` VALUES (2435, '顺序表存储空间连续，即允许元素的随机访问', 1, '', 'D', 604);
INSERT INTO `option_info` VALUES (2436, '92,20,91,34,88,35', 0, '', 'A', 605);
INSERT INTO `option_info` VALUES (2437, '12,25,71,68,33,34', 0, '', 'B', 605);
INSERT INTO `option_info` VALUES (2438, '21,89,77,29,36,38', 0, '', 'C', 605);
INSERT INTO `option_info` VALUES (2439, '95,22,91,24,94,71', 1, '', 'D', 605);
INSERT INTO `option_info` VALUES (2440, '329', 0, '', 'A', 606);
INSERT INTO `option_info` VALUES (2441, '137', 1, '', 'B', 606);
INSERT INTO `option_info` VALUES (2442, '201', 0, '', 'C', 606);
INSERT INTO `option_info` VALUES (2443, '491', 1, '', 'D', 606);
INSERT INTO `option_info` VALUES (2444, '9', 1, '', 'A', 607);
INSERT INTO `option_info` VALUES (2445, '10', 1, '', 'B', 607);
INSERT INTO `option_info` VALUES (2446, '11', 1, '', 'C', 607);
INSERT INTO `option_info` VALUES (2447, '8', 0, '', 'D', 607);
INSERT INTO `option_info` VALUES (2448, 'CFHGEBDK', 0, '', 'A', 608);
INSERT INTO `option_info` VALUES (2449, 'CDFEGHBK', 0, '', 'B', 608);
INSERT INTO `option_info` VALUES (2450, 'FGHCDEBK', 0, '', 'C', 608);
INSERT INTO `option_info` VALUES (2451, 'CFHGEDBK', 1, '', 'D', 608);
INSERT INTO `option_info` VALUES (2452, 'edcba', 0, '', 'A', 609);
INSERT INTO `option_info` VALUES (2453, 'decba', 0, '', 'B', 609);
INSERT INTO `option_info` VALUES (2454, 'dceab', 1, '', 'C', 609);
INSERT INTO `option_info` VALUES (2455, 'abcde', 0, '', 'D', 609);
INSERT INTO `option_info` VALUES (2456, '2', 0, '', 'A', 610);
INSERT INTO `option_info` VALUES (2457, '1', 0, '', 'B', 610);
INSERT INTO `option_info` VALUES (2458, '3', 1, '', 'C', 610);
INSERT INTO `option_info` VALUES (2459, '6', 0, '', 'D', 610);
INSERT INTO `option_info` VALUES (2460, 'a、b、c、d', 1, '', 'A', 611);
INSERT INTO `option_info` VALUES (2461, 'd、b、c、a', 0, '', 'B', 611);
INSERT INTO `option_info` VALUES (2462, 'd、c、b、a', 0, '', 'C', 611);
INSERT INTO `option_info` VALUES (2463, 'a、c、b、d', 1, '', 'D', 611);
INSERT INTO `option_info` VALUES (2464, '仅修改队头指针', 0, '', 'A', 612);
INSERT INTO `option_info` VALUES (2465, '仅修改队尾指针', 0, '', 'B', 612);
INSERT INTO `option_info` VALUES (2466, '队头、队尾指针都要修改', 0, '', 'C', 612);
INSERT INTO `option_info` VALUES (2467, '队头、对位指针可能都要修改', 1, '', 'D', 612);
INSERT INTO `option_info` VALUES (2468, '所有的结点均无左孩子', 0, '', 'A', 613);
INSERT INTO `option_info` VALUES (2469, '所有的结点均无右孩子', 0, '', 'B', 613);
INSERT INTO `option_info` VALUES (2470, '只有一个叶子结点', 1, '', 'C', 613);
INSERT INTO `option_info` VALUES (2471, '是任意的一颗二叉树', 0, '', 'D', 613);
INSERT INTO `option_info` VALUES (2472, 'T(n) = T(n/10) + T(9n/10) + O(n) 和 O(nLogn）', 0, '', 'A', 614);
INSERT INTO `option_info` VALUES (2473, 'T(n) = 2T(n/2) + O(n) 和 O(nLogn)', 0, '', 'B', 614);
INSERT INTO `option_info` VALUES (2474, 'T(n) = T(n-1) + O(n) 和 O(n^2)', 1, '', 'C', 614);
INSERT INTO `option_info` VALUES (2475, 'T(n) = T(n-2) + O(n) 和 O(n^2)', 0, '', 'D', 614);
INSERT INTO `option_info` VALUES (2476, '在函数中直接调用自己成为函数的直接递归调用', 1, '', 'A', 615);
INSERT INTO `option_info` VALUES (2477, '递归是一种分而治之、将复杂问题转换成简单问题的求解方法', 1, '', 'B', 615);
INSERT INTO `option_info` VALUES (2478, '递归可以使编写的程序简洁、结构清晰', 1, '', 'C', 615);
INSERT INTO `option_info` VALUES (2479, '在使用递归时，可以无限递归下去，不需要考虑其他因素', 0, '', 'D', 615);
INSERT INTO `option_info` VALUES (2480, '函数f1调用了函数f2又再次调用了函数f1，这种调用的方式我们称之为间接递归调用', 1, '', 'E', 615);
INSERT INTO `option_info` VALUES (2481, '促进研发（应用程序/软件工程）、技术运营（运维）部门之间的沟通、协作与整合，持续交付可靠的软件产品和服务。', 1, '', 'A', 616);
INSERT INTO `option_info` VALUES (2482, 'DevOps是以业务驱动的软件交付方法。从需求到交付生产环境，研发与运维间紧密协的文化运动与实践。', 1, '', 'B', 616);
INSERT INTO `option_info` VALUES (2483, 'DevOps文化更注重沟通，快速获得用户反馈提升创新能力。', 1, '', 'C', 616);
INSERT INTO `option_info` VALUES (2484, '开发和运营关注点和目标不匹配，业务交付模式需要独立开展以提高效率', 0, '', 'D', 616);
INSERT INTO `option_info` VALUES (2485, '产品Backlog', 0, '', 'A', 617);
INSERT INTO `option_info` VALUES (2486, '冲刺', 1, '', 'B', 617);
INSERT INTO `option_info` VALUES (2487, '计划', 1, '', 'C', 617);
INSERT INTO `option_info` VALUES (2488, '每日站会', 1, '', 'D', 617);
INSERT INTO `option_info` VALUES (2489, '评审会议', 1, '', 'E', 617);
INSERT INTO `option_info` VALUES (2490, '回顾会议', 0, '', 'F', 617);
INSERT INTO `option_info` VALUES (2491, '个体与交互重于过程和工具', 1, '', 'A', 618);
INSERT INTO `option_info` VALUES (2492, '可工作的软件重于完备的文档', 1, '', 'B', 618);
INSERT INTO `option_info` VALUES (2493, '客户协作重于合同谈判', 1, '', 'C', 618);
INSERT INTO `option_info` VALUES (2494, '响应变更重于遵循计划', 1, '', 'D', 618);
INSERT INTO `option_info` VALUES (2495, '计划驱动，阶段分离，顺序执行', 0, '', 'E', 618);
INSERT INTO `option_info` VALUES (2496, '负责确保Scrum被理解并实施', 1, '', 'A', 619);
INSERT INTO `option_info` VALUES (2497, '按需推动Scrum事件', 1, '', 'B', 619);
INSERT INTO `option_info` VALUES (2498, '有权要求团队做事以及改变列表条目优先级', 0, '', 'C', 619);
INSERT INTO `option_info` VALUES (2499, '担当教练角色， 引领团队达到更高级的凝聚力、自组织和表现', 1, '', 'D', 619);
INSERT INTO `option_info` VALUES (2500, '开发文档', 0, '', 'A', 620);
INSERT INTO `option_info` VALUES (2501, '产品Backlog', 1, '', 'B', 620);
INSERT INTO `option_info` VALUES (2502, 'SprintBacklog', 1, '', 'C', 620);
INSERT INTO `option_info` VALUES (2503, '产品增量', 1, '', 'D', 620);
INSERT INTO `option_info` VALUES (2504, '产品负责人(Product Owner)', 1, '', 'A', 621);
INSERT INTO `option_info` VALUES (2505, 'Scrum Master', 1, '', 'B', 621);
INSERT INTO `option_info` VALUES (2506, '开发团队', 1, '', 'C', 621);
INSERT INTO `option_info` VALUES (2507, '软件工程师', 0, '', 'D', 621);
INSERT INTO `option_info` VALUES (2508, '模型简单过程易于理解', 1, '', 'A', 622);
INSERT INTO `option_info` VALUES (2509, '交付周期长', 0, '', 'B', 622);
INSERT INTO `option_info` VALUES (2510, '反馈周期短', 1, '', 'C', 622);
INSERT INTO `option_info` VALUES (2511, '无法应对需求快速变化的场景和领域', 1, '', 'D', 622);
INSERT INTO `option_info` VALUES (2512, '系统之系统中的系统的不同部分可分别对应不同的管理和控制策略和规则', 0, '', 'A', 623);
INSERT INTO `option_info` VALUES (2513, '系统之系统中并不存在一个对系统各个部分进行管理的管理者', 0, '', 'B', 623);
INSERT INTO `option_info` VALUES (2514, '系统之系统是两个或以上独立管理和治理的系统的集合', 0, '', 'C', 623);
INSERT INTO `option_info` VALUES (2515, '系统之系统不可能是最小规模系统，如包含不同提供商提供的服务的较小的系统，大规模系统经常是系统之系统\"', 1, '', 'D', 623);
INSERT INTO `option_info` VALUES (2516, '软件工程发展的目的就是希望找到合适的方法和技术适用软件系统', 0, '', 'A', 624);
INSERT INTO `option_info` VALUES (2517, '软件工程仅指实现软件生产开发的活动序列', 1, '', 'B', 624);
INSERT INTO `option_info` VALUES (2518, '软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科，它涉及程序设计语言、数据库、软件开发工具、系统平台、标准、设计模式灯方面', 0, '', 'C', 624);
INSERT INTO `option_info` VALUES (2519, '软件工程的目的是支持专业化的软件开发、而不仅仅是个人编程', 0, '', 'D', 624);
INSERT INTO `option_info` VALUES (2520, '功能测试自动化', 1, '', 'A', 625);
INSERT INTO `option_info` VALUES (2521, '自动化部署', 1, '', 'B', 625);
INSERT INTO `option_info` VALUES (2522, '软件开发过程引入敏捷、精益思维，最小化需求范围(MVP)', 1, '', 'C', 625);
INSERT INTO `option_info` VALUES (2523, '微服务拆分', 0, '', 'D', 625);
INSERT INTO `option_info` VALUES (2524, '服务提供商会公开服务的信息，任何获得授权的用户都可以使用相应服务', 1, '', 'A', 626);
INSERT INTO `option_info` VALUES (2525, '组织内部或外部的服务提供商都可以提供服务', 1, '', 'B', 626);
INSERT INTO `option_info` VALUES (2526, '服务的用户能根据使用而不是提供商提供的服务来付费', 1, '', 'C', 626);
INSERT INTO `option_info` VALUES (2527, '应用能够延迟服务绑定直到这些服务被部署或执行', 1, '', 'D', 626);
INSERT INTO `option_info` VALUES (2528, '软件产品工程SPLE', 1, '', 'A', 627);
INSERT INTO `option_info` VALUES (2529, '分布式系统', 0, '', 'B', 627);
INSERT INTO `option_info` VALUES (2530, '应用框架', 0, '', 'C', 627);
INSERT INTO `option_info` VALUES (2531, '应用系统复用', 0, '', 'D', 627);
INSERT INTO `option_info` VALUES (2532, '软件交付的主要工作是将程序代码和相关文档交给用户', 0, '解析：持续集成是一个将集成提前至开发周期早期阶段的软件开发实践方式，是指软件个人研发部分向软件整体部分交付，让构建、测试和集成代码更经常性地发生，并且每次集成都要通过自动化的构建来验证，使集成错误尽早被发现。', 'A', 628);
INSERT INTO `option_info` VALUES (2533, '持续集成是频繁持续地将团队成员的工作进行集成', 1, '解析：持续集成是一个将集成提前至开发周期早期阶段的软件开发实践方式，是指软件个人研发部分向软件整体部分交付，让构建、测试和集成代码更经常性地发生，并且每次集成都要通过自动化的构建来验证，使集成错误尽早被发现。', 'B', 628);
INSERT INTO `option_info` VALUES (2534, '用户培训是帮助用户理解产品并掌握系统的使用和操作', 0, '解析：持续集成是一个将集成提前至开发周期早期阶段的软件开发实践方式，是指软件个人研发部分向软件整体部分交付，让构建、测试和集成代码更经常性地发生，并且每次集成都要通过自动化的构建来验证，使集成错误尽早被发现。', 'C', 628);
INSERT INTO `option_info` VALUES (2535, '软件部署是通过配置、安装和激活等活动保证软件系统的正常运行', 0, '解析：持续集成是一个将集成提前至开发周期早期阶段的软件开发实践方式，是指软件个人研发部分向软件整体部分交付，让构建、测试和集成代码更经常性地发生，并且每次集成都要通过自动化的构建来验证，使集成错误尽早被发现。', 'D', 628);
INSERT INTO `option_info` VALUES (2536, 'SaaS和SOA本质都是基于服务的思想，只是说法不同', 0, '', 'A', 629);
INSERT INTO `option_info` VALUES (2537, 'SaaS必须以SOA技术为基础', 0, '', 'B', 629);
INSERT INTO `option_info` VALUES (2538, 'SaaS环境下考虑可伸缩模型时，我们一般采用增强扩展，SOA技术能很好地支持增强扩展', 0, '', 'C', 629);
INSERT INTO `option_info` VALUES (2539, 'SaaS是向用户交付应用功能的方法，而SOA是应用系统的一种设计技术', 1, '', 'D', 629);
INSERT INTO `option_info` VALUES (2540, '软件是庞大的逻辑产品', 0, '', 'A', 630);
INSERT INTO `option_info` VALUES (2541, '软件开发工具所提供的开发支持弱', 1, '', 'B', 630);
INSERT INTO `option_info` VALUES (2542, '软件的复杂程度高', 0, '', 'C', 630);
INSERT INTO `option_info` VALUES (2543, '软件系统的问题空间和解空间之间的巨大鸿沟', 0, '', 'D', 630);
INSERT INTO `option_info` VALUES (2544, '可以使用gcore输出进程的运行coredump快照作分析', 1, '', 'A', 631);
INSERT INTO `option_info` VALUES (2545, '两个线程可能发生了互锁', 1, '', 'B', 631);
INSERT INTO `option_info` VALUES (2546, '可以attach到进程，查看两个std::mutex的_owner信息，是否为对方线程ID', 1, '', 'C', 631);
INSERT INTO `option_info` VALUES (2547, '两个线程可能同时在访问一个锁', 0, '', 'D', 631);
INSERT INTO `option_info` VALUES (2548, 'GCC安全编译选项-fstack-protector-all的作用有哪些', 0, '', 'A', 632);
INSERT INTO `option_info` VALUES (2549, '在栈顶插入一个随机数防止栈溢出', 0, '', 'B', 632);
INSERT INTO `option_info` VALUES (2550, '设置栈为代码不可执行', 0, '', 'C', 632);
INSERT INTO `option_info` VALUES (2551, '将字符串数组调整到栈的高地址', 1, '', 'D', 632);
INSERT INTO `option_info` VALUES (2552, '在栈底插入一个随机数防止栈溢出', 1, '', 'E', 632);
INSERT INTO `option_info` VALUES (2553, '-fPIC\\-fPIE', 1, '', 'A', 633);
INSERT INTO `option_info` VALUES (2554, '-fstack-protector-all 栈溢出保护', 1, '', 'B', 633);
INSERT INTO `option_info` VALUES (2555, '-Wl,-z,relro          保护got表 - 部分重定向只读', 1, '', 'C', 633);
INSERT INTO `option_info` VALUES (2556, '-Wl,-z,noexecstack    堆+栈不可执行', 1, '', 'D', 633);
INSERT INTO `option_info` VALUES (2557, '-z,now                保护got表 - 全部重定向只读', 1, '', 'E', 633);
INSERT INTO `option_info` VALUES (2558, '-ftrapv', 0, '', 'F', 633);
INSERT INTO `option_info` VALUES (2559, '-Wpointer-arith', 0, '', 'A', 634);
INSERT INTO `option_info` VALUES (2560, '-s', 1, '', 'B', 634);
INSERT INTO `option_info` VALUES (2561, '-ftrapv', 0, '', 'C', 634);
INSERT INTO `option_info` VALUES (2562, '-Wl,-z,relro', 0, '', 'D', 634);
INSERT INTO `option_info` VALUES (2563, '设置程序启动时优先加载[path]路径下的共享库', 1, '', 'A', 635);
INSERT INTO `option_info` VALUES (2564, '设置只有[path]路径下的动态库才允许被加载', 0, '', 'B', 635);
INSERT INTO `option_info` VALUES (2565, '设置程序启动时优先加载[path]路径下的静态库', 0, '', 'C', 635);
INSERT INTO `option_info` VALUES (2566, '设置[path]路径没有代码可执行权限', 1, '', 'D', 635);
INSERT INTO `option_info` VALUES (2567, '将字符串数组调整到栈的低地址', 0, '', 'A', 636);
INSERT INTO `option_info` VALUES (2568, '在栈顶插入一个随机数防止栈溢出', 0, '', 'B', 636);
INSERT INTO `option_info` VALUES (2569, '设置栈代码为代码不可执行', 0, '', 'C', 636);
INSERT INTO `option_info` VALUES (2570, '将字符串数组调整到栈的高地址', 1, '', 'D', 636);
INSERT INTO `option_info` VALUES (2571, '在栈底插入一个随机数防止栈溢出', 1, '', 'E', 636);
INSERT INTO `option_info` VALUES (2572, '构建环境上的工具，可以由CIE从公司外网下载直接安装。', 0, '', 'A', 637);
INSERT INTO `option_info` VALUES (2573, '每一次构建成功后，都应该记录生成的版本包和构建环境镜像的关联关系,方便以后溯源。', 0, '', 'B', 637);
INSERT INTO `option_info` VALUES (2574, '为了方便开发人员定位构建问题，构建环境应该对所有开发者开放。', 0, '', 'C', 637);
INSERT INTO `option_info` VALUES (2575, '版本发布构建所用的环境，应该是封闭的，只能有任命的CIE可以访问环境。', 1, '', 'D', 637);
INSERT INTO `option_info` VALUES (2576, '基于相同源码、环境、生产与客户现网部署逐比特一致的二进制', 1, '', 'A', 638);
INSERT INTO `option_info` VALUES (2577, '随机差异要全部消除，除非能准确知晓这些差异的内容', 1, '', 'B', 638);
INSERT INTO `option_info` VALUES (2578, '随机差异优先消除，时间差异太大时没必要消除', 0, '', 'C', 638);
INSERT INTO `option_info` VALUES (2579, '交付源码和二进制要保持一致', 1, '', 'D', 638);
INSERT INTO `option_info` VALUES (2580, 'A平台二进制及源码没有进行配置标识及基线，导致源码缺失', 1, '', 'A', 639);
INSERT INTO `option_info` VALUES (2581, '产品正式发布的版本应配套使用A平台的正式发布版本，不应使用A平台的联调版本', 1, '', 'B', 639);
INSERT INTO `option_info` VALUES (2582, '联调版本没有通过联调版本发布流程发布，而是通过文件共享方式私下进行传递', 1, '', 'C', 639);
INSERT INTO `option_info` VALUES (2583, '具备在任意时刻都能交付二进制对应的准确源代码的能力', 1, '', 'D', 639);
INSERT INTO `option_info` VALUES (2584, '其他自定义格式：1990+月-日-天-小时-分-秒的偏移量', 1, '', 'A', 640);
INSERT INTO `option_info` VALUES (2585, '构建时刻距离1970/01/01秒数', 1, '', 'B', 640);
INSERT INTO `option_info` VALUES (2586, '\"NOV1,2016，21：04：16“字符串', 1, '', 'C', 640);
INSERT INTO `option_info` VALUES (2587, '“20170304180056\"字符串', 1, '', 'D', 640);
INSERT INTO `option_info` VALUES (2588, '-Fpic', 0, '', 'A', 641);
INSERT INTO `option_info` VALUES (2589, '-Wl,-z,relro', 1, '', 'B', 641);
INSERT INTO `option_info` VALUES (2590, '-pie', 1, '', 'C', 641);
INSERT INTO `option_info` VALUES (2591, '-Wl,-z,noexecstack', 1, '', 'D', 641);
INSERT INTO `option_info` VALUES (2592, '两者作用相似可以互相替换', 0, '', 'A', 642);
INSERT INTO `option_info` VALUES (2593, '-fPIC是编译选项', 1, '', 'B', 642);
INSERT INTO `option_info` VALUES (2594, '-fPIE -pie用于可执行程序', 1, '', 'C', 642);
INSERT INTO `option_info` VALUES (2595, '-fPIC用于静态库', 0, '', 'D', 642);
INSERT INTO `option_info` VALUES (2596, '允许使用-w选项屏蔽所有告警', 1, '', 'A', 643);
INSERT INTO `option_info` VALUES (2597, '使用虚拟化OS工具在Windows上来模拟Linux进行构建', 1, '', 'B', 643);
INSERT INTO `option_info` VALUES (2598, '构建输出的日志简洁明晰，信息应分级为error/warning/info；出现error信息表示构建失败，必须终止构建', 0, '', 'C', 643);
INSERT INTO `option_info` VALUES (2599, '构建模块较多时，对于子模块私有的配置，可以在模块内定义config.xml作为子模块的配置', 1, '', 'D', 643);
INSERT INTO `option_info` VALUES (2600, '构建脚本必须使用相对路径，禁止使用绝对路径', 1, '', 'A', 644);
INSERT INTO `option_info` VALUES (2601, '构建脚本成功返回0；构建失败，应以非0的退出码退出', 1, '', 'B', 644);
INSERT INTO `option_info` VALUES (2602, '每个文件开头包含一个注释，简要概述文件源代码的功能、版权声明', 1, '', 'C', 644);
INSERT INTO `option_info` VALUES (2603, '产品软件构建脚本语言智能选择一种，推荐Python', 0, '', 'D', 644);
INSERT INTO `option_info` VALUES (2604, '自保恢复原则：负荷下降到设计能力范围之内后，网元可以立即恢复处理能力', 0, '', 'A', 645);
INSERT INTO `option_info` VALUES (2605, '业务保证原则：确保在出现大流量冲击时所有业务不被丢弃', 1, '', 'B', 645);
INSERT INTO `option_info` VALUES (2606, '及早控制原则：应尽可能在业务流程处理前端或业务处理较早的处理单元（网元/单板/芯片等）或底层协议层次上控制业务接入', 0, '', 'C', 645);
INSERT INTO `option_info` VALUES (2607, '优先级保证原则：系统过载时保证高优先级的业务能够优先获得资源，优先得到处理', 0, '', 'D', 645);
INSERT INTO `option_info` VALUES (2608, '非持久性是在有限的时间内保留信息、服务和连接，从而减少攻击者利用漏洞并建立持久立足点的机会', 0, '', 'A', 646);
INSERT INTO `option_info` VALUES (2609, '权限限制是指根据关键性和信任模型，限制使用网络资源所需的权限，以及分配给用户和网络实体的权限，以最大限度的减少对手活动的潜在后果', 0, '', 'B', 646);
INSERT INTO `option_info` VALUES (2610, '多样性使用异构技术（例如 硬件、软件、固件、协议），这样增加了网络建设的成本，运维的难度，是不可取的', 1, '', 'C', 646);
INSERT INTO `option_info` VALUES (2611, '分割可以根据系统的重要级别进行划分，以限制成功攻击的传播或损害', 0, '', 'D', 646);
INSERT INTO `option_info` VALUES (2612, '主用单元和备用单元的故障检测率都直接影响冗余系统可用度', 0, '', 'A', 647);
INSERT INTO `option_info` VALUES (2613, '系统的冗余设计是硬件独立完成的，与软件关系不大', 1, '', 'B', 647);
INSERT INTO `option_info` VALUES (2614, '电信产品要求具备高可用性，但同时也需要考虑成本等多方面的因素，所有冗余设计并不是使用的越多越好', 0, '', 'C', 647);
INSERT INTO `option_info` VALUES (2615, '资源池冗余设计中要考虑负载均衡', 0, '', 'D', 647);
INSERT INTO `option_info` VALUES (2616, '用户规模不超过5千人时，登录密码验证时间不超过2秒，用户规模不超过2万人时，登录密码验证不超过5秒', 1, '', 'A', 648);
INSERT INTO `option_info` VALUES (2617, '课程属性与学生专业属性不符时不允许选课', 0, '', 'B', 648);
INSERT INTO `option_info` VALUES (2618, '系统应当在2018年9月1日之前上线部署运行', 0, '', 'C', 648);
INSERT INTO `option_info` VALUES (2619, '系统可按照院系统计学生选课请款个，指定统计范围后1秒内返回统计结果', 0, '', 'D', 648);
INSERT INTO `option_info` VALUES (2620, '威胁建模', 0, '', 'A', 649);
INSERT INTO `option_info` VALUES (2621, '软件包完整性保护', 0, '', 'B', 649);
INSERT INTO `option_info` VALUES (2622, '设计架构审查', 0, '', 'C', 649);
INSERT INTO `option_info` VALUES (2623, '代码检视', 1, '', 'D', 649);
INSERT INTO `option_info` VALUES (2624, '动态分析和Fuzz测试', 0, '', 'A', 650);
INSERT INTO `option_info` VALUES (2625, '测试方案设计', 1, '', 'B', 650);
INSERT INTO `option_info` VALUES (2626, '总体测试策略', 0, '', 'C', 650);
INSERT INTO `option_info` VALUES (2627, '静态分析', 0, '', 'D', 650);
INSERT INTO `option_info` VALUES (2628, '通过负荷分担保护业务', 0, '', 'A', 651);
INSERT INTO `option_info` VALUES (2629, '主备单板倒换', 0, '', 'B', 651);
INSERT INTO `option_info` VALUES (2630, '现场更换单板', 1, '', 'C', 651);
INSERT INTO `option_info` VALUES (2631, '自动复位单板', 0, '', 'D', 651);
INSERT INTO `option_info` VALUES (2632, '涉及加密算法选择时，多使用业界公开标准的成熟算法，而不要设计私有的，自以为安全可靠的算法', 0, '', 'A', 652);
INSERT INTO `option_info` VALUES (2633, '设计不应该是秘密的，不应依赖对设计和实现的保密，以及攻击者的无知', 0, '', 'B', 652);
INSERT INTO `option_info` VALUES (2634, '加密秘钥要公开开放', 1, '', 'C', 652);
INSERT INTO `option_info` VALUES (2635, '密钥禁止硬编码', 0, '', 'D', 652);
INSERT INTO `option_info` VALUES (2636, '通过故障预测预防，用户可以根据故障出现的概率以及出现的位置，采取相应的手段提前避免这些有可能出现的故障', 0, '', 'A', 653);
INSERT INTO `option_info` VALUES (2637, '故障预测预防是一种被动故障处理技术', 1, '', 'B', 653);
INSERT INTO `option_info` VALUES (2638, '故障预测预防技术是一种有效的主动故障处理技术', 0, '', 'C', 653);
INSERT INTO `option_info` VALUES (2639, '故障预测可以在系统故障出现之前，通过分析系统的状态得到故障可能出现的概率以及出现的故障种类', 0, '', 'D', 653);

SET FOREIGN_KEY_CHECKS = 1;
